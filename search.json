[{"title":"【Git】分布式版本控制工具","path":"/2025/03/21/【Git】分布式版本控制工具/","content":"Git工作流程 clone（克隆）: 从远程仓库中克隆代码到本地仓库 checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订 add（添加）: 在提交前先将代码提交到暂存区 commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本 fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少 pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库 Git基本配置设置用户信息设置：（+如果要查看，只输入双引号前面的就好了） 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; Git基本使用获取本地仓库git init，执行之后工作目录下就会产生.git隐藏目录。 Git工作目录下文件的状态 基本命令 git add ：工作区 –&gt; 暂存区，可以接单个文件名，也可以接通配符 git commit： 暂存区 –&gt; 本地仓库，可以接-m &lt;注释&gt; git status：查看修改的状态 git log [option]：查看提交日志，git-log以精简形式查看 --all 显示所有分支 --pretty=oneline 将提交信息显示为一行 --abbrev-commit 使得输出的commitId更简短 --graph 以图的形式显示 git reset --hard commitID：版本回退 添加文件到忽略列表：创建.gitignore文件，列出要忽略的文件模式 Git分支基本指令 查看本地分支：git branch 创建本地分支：git branch 分支名 切换分支：git checkout 分支名 可以直接切换到一个不存在的分支（创建并切换）：git checkout -b 分支名 合并分支：git merge 分支名称，一个分支上的提交可以合并到另一个分支 删除分支：不能删除当前分支，只能删除其他分支 git branch -d b1 删除分支时，需要做各种检查 git branch -D b1 不做任何检查，强制删除 解决冲突步骤： 处理文件中冲突的地方 将解决完冲突的文件加入暂存区(add) 提交到仓库(commit) 使用原则 master （生产） 分支：线上分支，主分支，中小规模项目作为线上运行的应用对应的分支； develop（开发）分支：是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线； feature/xxxx分支：从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完 成后合并到develop分支； hotfix/xxxx分支：从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支； 还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。 Git远程仓库基本命令 对接远程仓库： git remote add &lt;远端名称&gt; &lt;仓库路径&gt; 查看远程仓库： git remote 推送到远程仓库：git push [-f] [--set-upstream] [远端名称 [本地分支名]:[远端分支名]] 如果远程分支名和本地分支名称相同，则可以只写本地分支git push origin master -f 表示强制覆盖 --set-upstream 推送到远端的同时并且建立起和远端分支的关联关系 如果当前分支已经和远端分支关联，则可以省略分支名和远端名 查看本地分支与远程分支的关联关系：git branch -vv 从远程仓库克隆：git clone &lt;仓库路径&gt; [本地目录] 从远程仓库抓取&#x2F;拉取：（如果不指定远端名称和分支名，就抓取所有分支） git fetch [remote name] [branch name]：将仓库里的更新都抓取到本地，不进行合并。 git pull [remote name] [branch name]：将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 解决冲突远程分支也是分支，解决冲突的方式和本地相同（看上文）。 需要先拉取远程仓库的提交，经过合并后才能推送到远端分支： 铁令 切换分支前先提交本地的修改 代码及时提交，提交过了就不会丢 遇到任何问题都不要删除文件目录"},{"title":"【Go基础】常用环境变量设置","path":"/2025/03/19/【Go基础】常用环境变量设置/","content":"常用环境变量GOROOT： go的安装目录（go安装：https://golang.google.cn/dl/） GOPATH：一般给文件夹起名叫GoWorkstation、Go_WorkSpace等。 src：存放源代码 pkg：存放依赖包 bin：存放可执行文件 其他常用环境变量：GOOS，GOARCH，GOPROXY国内用户建议设置 goproxy：export GOPROXY&#x3D;https://goproxy.cn"},{"title":"【Go基础】错误处理","path":"/2025/03/19/【Go基础】错误处理/","content":"基本认识 在Go中，将错误当成值来进行处理，强调判断错误和处理错误，不支持try/catch捕获异常。 Go选择使用Error而非Exception来进行错误处理。 一般把错误作为函数或方法的最后一个返回值。 Error接口使用error接口表示错误类型。该接口只有一个Error()方法，返回描述错误信息的字符串。 123type error interface &#123; Error() string&#125; 接口类型的默认零值为nil，所以通常把调用函数时返回的错误和nil比较： 12345_, err := someFunc(some parameters)if err != nil&#123; fmt.Println(&quot;出现错误：&quot;, err) // 使用标准库fmt打印错误自动调用error类型的Error方法，打印错误描述信息 return&#125; Go这种机制的好处是，遇到error需要立即处理，而Java中是try/catch中包裹了一大堆代码，良性和致命的问题都会抛出错误，不容易排查问题。 创建错误由于error是接口，可以自定义错误类型（开发中间件使用较多）。 最简单的创建错误的方法是用errors包提供的New函数创建一个错误： 123func New(text string) error&#123; return &amp;errorString&#123;text&#125;\t// 返回一个指针，使得每次返回都是一个新的对象，否则在做等值判断时可能会出问题。&#125; 错误的两种类型error：可以被处理的错误；panic：非常严重不可恢复的错误。 errors包当需要传入格式化的错误描述信息，用fmt.Errorf更好，但是它提供很多描述错误的文本信息，会丢失原本的错误类型，导致错误在做等值判断时失效。为了解决这个缺陷，fmt.Errorf在1.13版本提供了特殊的格式化动词w%，可以基于已有错误再包装得到新的错误： 1fmt.Errorf(&quot;查询数据库失败，err:%w&quot;, err) 对于这种二次包装的错误，errors包提供了4个常用的方法： New：创建一个新的 error func Is(err, target error) bool ：判断err是否包含target，是不是特定的某个error func As(err error, target interface&#123;&#125;) bool：判断error是否为target类型，类型转换为特定的error（用得不多） func Unwrap(err error) error：获得error包含下一层错误，解除包装并返回被包装的 error 使用举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport (\t&quot;errors&quot;\t&quot;fmt&quot;)func main() &#123;\tvar err error = &amp;MyError&#123;&#125;\tprintln(err.Error())\tErrorsPkg()&#125;type MyError struct &#123;&#125;func (m *MyError) Error() string &#123;\treturn &quot;Hello, it&#x27;s my error&quot;&#125;func ErrorsPkg() &#123;\terr := &amp;MyError&#123;&#125;\t// 使用 %w 占位符，返回的是一个新错误\t// wrappedErr 是一个新类型，fmt.wrapError\twrappedErr := fmt.Errorf(&quot;this is an wrapped error %w&quot;, err)\t// 再解出来\tif err == errors.Unwrap(wrappedErr) &#123; fmt.Println(&quot;unwrapped&quot;)\t&#125; if errors.Is(wrappedErr, err) &#123; // 虽然被包了一下，但是 Is 会逐层解除包装，判断是不是该错误 fmt.Println(&quot;wrapped is err&quot;)\t&#125;\tcopyErr := &amp;MyError&#123;&#125;\t// 这里尝试将 wrappedErr转换为 MyError\t// 注意我们使用了两次的取地址符号\tif errors.As(wrappedErr, &amp;copyErr) &#123; fmt.Println(&quot;convert error&quot;)\t&#125;&#125; panic意味着fatal error，调用者不能解决，彻底结束。可能遇到的场景： 调用别人的代码，别人没有合理使用panic（自己写代码还是用error）。 数组越界、不可恢复的环境、栈溢出等错误。 从panic中恢复： ​\trecover可以进行兜底，把这一次的request放弃，go的runtime会退出，可以去执行其他的request，但是风险比较大，revover一般就是记录个日志之类的，，示例： 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123;\tdefer func() &#123; if data := recover(); data != nil &#123; fmt.Printf(&quot;hello, panic: %v &quot;, data) &#125; fmt.Println(&quot;恢复之后从这里继续执行&quot;)\t&#125;()\tpanic(&quot;Boom&quot;)\tfmt.Println(&quot;这里将不会执行下来&quot;)&#125; 使用原则 遇事不决选 error 当怀疑可以用 error 的时候，就说明不需要 panic 一般情况下，只有快速失败的过程，才会考虑panic defer用于在方法返回之前执行某些动作（类似于Java中的finally），一般用来释放资源（如锁等）。执行顺序：像栈一样，先进后出。 处理错误正常流程的代码推荐的写法，err处理缩进，正常的代码是一条直线。 12345678910111213/////////推荐写法////////f, err := os.Open(path)if err != nil &#123; // handle error&#125;// do stuff//////////不推荐///////f, err := os.Open(path)if err == nil &#123; // do stuff&#125;// handle error 少写if err !&#x3D; nil的技巧 返回err或者nil，可以直接return： 12345678910111213//////原来的写法func AuthenticateRequest(r *Request) error &#123; err := authenticate(r.User) if err != nil &#123; return err &#125; return nil&#125;//////推荐的写法 //毕竟函数的返回值就要error类型，而且调用函数之后就返回一个error类型，那直接return就好了func AuthenticateRequest(r *Request) error &#123; return authenticate(r.User)&#125; 用io.Reader统计读取内容的行数 1234567891011121314151617181920212223242526272829//////原来的写法func CountLines(r io.Reader) (int, error) &#123; var ( br = bufio.NewReader(r) lines int err error ) for &#123; _, err = br.ReadString(&#x27; &#x27;) lines++ if err != nil &#123; break &#125; &#125; if err != io.EOF &#123; return 0, err &#125; return lines, nil&#125;//////推荐的写法 //func CountLines(r io.Reader) (int, error) &#123; sc := bufio.NewScanner(r) lines := 0 for sc.Scan() &#123; lines++ &#125; return lines, sc.Err()&#125; 利用bufio.Scanner方法，这个里面封装了按行读取的逻辑，并且其Scan方法读取时遇到错误会记录下来，最终通过 sc.Err()统一返回。 包装错误类型，缓存错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758////////////原来的写法type Header struct &#123; Key, Value string&#125;type Status struct &#123; Code int Reason string&#125;func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123; _, err := fmt.Fprintf(w, &quot;HTTP/1.1 %d %s\\r &quot;, st.Code, st.Reason) if err != nil &#123; return err &#125; for _, h := range headers &#123; _, err := fmt.Fprintf(w, &quot;%s: %s\\r &quot;, h.Key, h.Value) if err != nil &#123; return err &#125; &#125; if _, err := fmt.Fprintf(w, &quot;\\r &quot;); err != nil &#123; return err &#125; _, err = io.Copy(w, body) return err&#125;//////////////推荐的写法 //type errWriter struct &#123; io.Writer err error\t// 用来暂存&#125;func (e *errWriter) Write(buf []byte) (int, error) &#123; if e.err != nil &#123; return 0, e.err &#125; var n int n, e.err = e.Writer.Write(buf) return n, e.err&#125;func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123; ew := &amp;errWriter&#123;Writer: w&#125; fmt.Fprintf(ew, &quot;HTTP/1.1 %d %s\\r &quot;, st.Code, st.Reason) for _, h := range headers &#123; fmt.Fprintf(ew, &quot;%s: %s\\r &quot;, h.Key, h.Value) &#125; fmt.Fprintf(ew, &quot;\\r &quot;) io.Copy(ew, body) return ew.err&#125; 下面这种写法，不用做任何err的判定，相当于在包装类里面复用了，更优雅。 使用errors包装错误-从根本上解决上一小节只是减少了if err !&#x3D; nil的数量，但是并没有从根本上解决不能提供详细上下文的问题。一方面，破坏原始错误，担心上层调用的人用做等值判定，只能一层层向上透传，最终输出没有堆栈没有上下文的信息，令人崩溃；另一方面，又想包装更多详细错误信息。 error.Wrap()：保留原始错误信息，捎带一些附加信息。 errors.Cause()：用来获取原始错误（根因，root error）。 errors.WithMessage()：不保存堆栈信息。 实际应用时： 自己的应用代码中，使用errors.New()或者errors.Errorf()返回错误； 如果调用其他包内的函数，直接返回，往上抛，不要在错误的地方到处打日志。（满足原则：只处理一次。） 如果使用三方库&#x2F;标准库，使用errors.Wrap()或errors.Wrapf()保存堆栈信息。 程序的顶部或者工作的goroutine顶部，用%+v详细记录堆栈。 处理错误的原则处理的原则是：如果遇到错误，只处理一次。 一些经常出现的错误代码，在错误处理中，既记录了日志，又返回了错误： 12345678func WriteAll(w io.Writer, buf []byte) error &#123; _, err := w.Write(buf) if err != nil &#123; log.Println(&quot;unable to write:&quot;, err) return err &#125; return nil&#125; 这个时候又尬住了，一方面，不记录日志，找不到是谁报错；另一方面，记录日志接下来调用者层层打印，在控制台的输出可能就层层割裂，没有完整的堆栈信息。 继续讲处理的原则：错误处理契约规定，出现错误时，不能对其他返回值的内容做任何假设。如果程序员忘记return，函数返回的结果可能是正确的，但是其他返回值的内容是错误的。 那么应该如何记录日志？原则： 错误要被日志记录 *应用程序处理错误，保证**100%*完整性 之后不再报告当前错误 结合上一小节，包装错误的原则： 如果你提供的库很多人使用，不应该使用任何wrap包装错误 如果你的函数无法处理错误，携带足够多的上下文，用wrap.Errors往上抛（足够的上下文：能帮助解决问题，一般是什么人调用了什么接口，返回成功还是失败） 如果这个错误被处理过，就不要再抛了。 【参考资料】 https://www.liwenzhou.com/posts/Go/error/"},{"title":"【Go基础】并发编程基本概念","path":"/2025/03/19/【Go基础】并发编程基本概念/","content":"并发编程基本概念串行、并发与并行 串行：我们都是先读小学，小学毕业后再读初中，读完初中再读高中。 并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。 并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。 进程、线程和协程 进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。 协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。 并发模型4种常见的实现方式： 线程&amp;锁模型 Actor模型 CSP模型（communicating sequential processes，Go中主要是基于CSP的goroutine和channel实现） Fork&amp;Join模型"},{"title":"【Go基础】垃圾回收演进 三色标记法","path":"/2025/03/19/【Go基础】垃圾回收演进三色标记法/","content":"GO1.3标记清除，整体需要STW：1.暂停，找到可达和不可达对象，2. 标记可达对象，3. 清除未标记对象，4. 结束暂停 GO1.5三色标记法，堆启动写屏障，栈不启动，全部扫描一次后，需要重新扫描栈（STW），效率低 如果没有STW，对象丢失的2个条件： 黑色对象指向白色对象（白色挂在黑色下面） 灰色对象与其可达白色对象之间遭到破坏（灰色也丢失了该白色） 屏障机制，保障对象不丢失的2种方式： 强三色不变式：不允许黑色对象指向白色对象 弱三色不变式：允许黑色对象指向白色对象，但是该白色对象要被灰色对象可达 为此，go初步得到两种屏障方式： 插入写屏障：只使用在堆中，将黑色指向的白色对象标记为灰色；栈要启动STW重新三色标记扫描（仍然需要STW重新扫描栈） 删除写屏障：被删除的白色节点标记为灰色（保护灰色对象到白色对象的路径不会断），所以最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉（回收精度低，开始时STW记录初始快照） 为什么在栈中不使用： GO1.8三色标记法，混合写屏障，栈不启动，堆启动，几乎不需要STW，效率高 结合得到混合写屏障（满足弱三色不变）： 开始时将所有栈上的可达节点标记为黑色，在GC期间栈上新增的也标记为黑色（无需STW） 删除和新增的全部标记为灰色 参考资料： https://www.bilibili.com/video/BV1wz4y1y7Kd/"},{"title":"【Go基础】Go入门与实践资源帖","path":"/2025/03/19/【Go基础】Go入门与实践资源帖/","content":"看到好的持续更新…… Go系统教程 从语法讲起：李文周博客 七天快速上手项目 Go测试驱动开发博客 孔令飞项目开发实战课程，孔令飞图文教程 《Go 语言高级编程》书籍 Go算法刷题模板 Go实战项目 KV系统 crawlab分布式爬虫平台 seaweedfs分布式文件系统 Cloudreve云盘系统 gfast后台管理系统（基于Go Frame） alist多存储文件列表（基于Gin、React） Yearning开源SQL审核平台 Go要点 GMP机制 并发编程机制 编辑解释运行机制 GC机制 看过的帖子 腾讯技术工程：协程调度的本质 通用技术面试相关 极客时间面试指导视频课"},{"title":"【Go基础】微服务概念与演进","path":"/2025/03/19/【Go基础】微服务概念与演进/","content":"微服务概念与演进巨石架构到微服务的演进传统网页应用虽然进行了模块化设计，但是最终仍然是打包成一个war包进行部署，启动慢，无法拓展，可靠性很低。 什么是微服务是面向服务的架构模式（SOA）的最佳实践。定义：围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。 如何实现微服务组件服务化，例如在Go中实现需要：• kit：一个微服务的基础库（框架）• service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务• RPC + message queue：轻量级通讯按业务组织服务，常见的模式：大前端（移动&#x2F;Web） &gt; 网关接入 &gt; 业务服务 &gt; 平台服务 &gt; 基础设施（PaaS&#x2F;Saas） 微服务的优点和缺点优点：原子服务、独立进程、隔离部署、去中心化服务治理。 缺点：基础设施的建设、复杂度高。固有的复杂性：① 必须使用RPC或者消息传递实现进程间的通信，处理通信慢与局部失效的问题；② 不同服务可能使用不同数据库。 要搞定这些缺点，需要做怎样的基础设施建设做什么事情–可用性设计、API设计等引申话题 微服务组件微服务设计中常见的角色三大组件：API Gateway、BFF层、底层服务Microservices。API网关分层： 流量入口：协议转换&#x2F;路由分发 安全边界：统一认证&#x2F;权限控制 流量治理：限流熔断&#x2F;日志监控 BFF适配层：为不同终端提供定制化APICQRS模式：读写分离（通过binlog实现数据同步） 演进过程Microservices拆分: 按垂直功能性能角度，含久必分分久必合 可以考虑中间加一层(例如统一接入账号) 按照业务领域抽象（DDD） 按照功能拆分：CQRS，应用程序分为命令端和查询端。 安全问题外部的安全保障：API Gateway统一认证拦截 -&gt; BFF校验Token -&gt; Service 服务内部的安全保障：① 认证：知道是谁调用的；② 授权：RBAC，控制能访问哪些接口。 信任等级：Full&#x2F;Half&#x2F;Zero Trust。 gRPC概念A high-performance, open-source universal RPC framework. 高性能开源框架。特性： 支持多语言； 序列化支持Protocol Buffer和Json； HTTP&#x2F;2多路复用。 其中最重要的是标准健康监测协议，应用如下：应用1：服务稳定与不稳定时摘除与恢复；应用2：外挂容器健康检测；应用3：生产者与消费者之间的检测；应用4：平滑发布。 服务发现的模型① 客户端发现（微服务的核心是去中心化，用这种更好）；② 服务端发现（如果服务很大，可能用service mesh）。 多集群与多租户多集群why?——单集群坏处：一般布N+2来冗余节点。出现故障时后果严重。how?——物理上两套资源，逻辑上维护cluster概念。好处？——不同集群使用多套独占的缓存，性能好。坏处？——缓存命中率下降，不同业务形态数据正交。拓展：从全集群中选取一批节点（子集），利用划分子集限制连接池大小。——子集算法。 多租户why？保障代码隔离性，基于流量租户做路由决策。问题：[并行测试]时混用环境不可靠，而多布环境成本高，也难以做压测。解决方法：染色发布，基于流量类型做路由。本质是从源头传递一个标签，挂在go的上下文中，基于RPC负载均衡的流量做路由,路由到指定的节点。 参考资料：https://microservices.io/index.htmlhttps://blog.csdn.net/mindfloating/article/details/51221780https://www.cnblogs.com/dadadechengzi/p/9373069.htmlhttps://www.cnblogs.com/viaiu/archive/2018/11/24/10011376.htmlhttps://www.cnblogs.com/lfs2640666960/p/9543096.htmlhttps://mp.weixin.qq.com/s/L6OKJK1ev1FyVDu03CQ0OAhttps://www.bookstack.cn/read/API-design-guide/API-design-guide-02-面向资源的设计.mdhttps://www.programmableweb.com/news/how-to-design-great-apis-api-first-design-and-raml/how-to/2015/07/10http://www.dockone.io/article/394https://www.jianshu.com/p/3c7a0e81451ahttps://www.jianshu.com/p/6e539caf662dhttps://my.oschina.net/CraneHe/blog/70317https://my.oschina.net/CraneHe/blog/703169https://my.oschina.net/CraneHe/blog/703160 学习笔记，侵删。"},{"title":"【JavaWeb】HTML、CSS","path":"/2024/04/11/【JavaWeb】HTML、CSS/","content":"Web开发Web介绍 Web：全球广域网，也称为万维网(www World Wide Web)，能够通过浏览器访问的网站。 Web 网站的工作流程 整个流程如下： 浏览器先向前端服务器请求前端资源，也就是我们所说的网页； 浏览器再向后台服务器发起请求，获取数据； 浏览器将得到的后台数据填充到网页上，然后展示给用户去看。 网站的开发模式**Web开发&#x3D;开发网站~**主要有2种：前端台分离和混合开发，目前流行的是前后端分离开发模式。 前后台分离：（目前企业开发的主流，市场占有率70%以上）这种开发模式的特点如下 前端人员开发前端程序，前端程序单独部署到前端服务器上 后端人员开开发后端程序，后端程序单独部署到后端服务器上 网站开发技术前端 技术 描述 HTML 用于构建网站的基础结构的 css 用于美化页面的，作用和化妆或者整容作用一样 JavaScript 实现网页和用户的交互 Vue 主要用于将数据填充到html页面上的 Element 主要提供了一些非常美观的组件 Nginx 一款web服务器软件，可以用于部署我们的前端工程 后端 技术 描述 Maven 一款java中用于管理项目的软件 Mysql 最常用的一款数据库软件之一 SpringBoot spring家族的产品，当前最为主流的项目开发技术。 Mybatis 用于操作数据库的框架 前端开发整体认知 网页有哪些部分组成 ? ​\t文字、图片、音频、视频、超链接、表格等等。 我们看到的网页，背后的本质是什么 ? 程序员写的前端代码 (备注：在前后端分离的开发模式中。) 前端的代码是如何转换成用户眼中的网页的 ? 通过浏览器转化（解析和渲染）成用户看到的网页。 浏览器中对代码进行解析和渲染的部分，称为 浏览器内核。 Web标准即网页标准，一系列，大部分由W3C（ World Wide Web Consortium，万维网联盟）负责制定。由三个组成部分： HTML：负责网页的结构（页面元素和内容）。 CSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。 JavaScript：负责网页的行为（交互效果）。 HTML &amp; CSS快速入门什么是HTML ?**HTML: **HyperText Markup Language，超文本标记语言。 超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。 标记语言：由标签构成的语言 HTML标签都是预定义好的。例如：使用 &lt;h1&gt; 标签展示标题，使用&lt;a&gt;展示超链接，使用&lt;img&gt;展示图片，&lt;video&gt;展示视频。 HTML代码直接在浏览器中运行，HTML标签由浏览器解析。 html的固定基本结构123456789&lt;html&gt;\t&lt;head&gt; &lt;title&gt;HTML 快速入门&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt; &lt;h1&gt;Hello HTML&lt;/h1&gt; &lt;img src=&quot;1.jpg&quot;/&gt;\t&lt;/body&gt;&lt;/html&gt; &lt;html&gt;是根标签，&lt;head&gt;和&lt;body&gt;是子标签，&lt;head&gt;中的字标签&lt;title&gt;是用来定义网页的标题的，里面定义的内容会显示在浏览器网页的标题位置。 &lt;body&gt; 中编写的内容，就网页中显示的核心内容。 HTML中的标签特点 HTML标签不区分大小写 HTML标签的属性值，采用单引号、双引号都可以 HTML语法相对比较松散 (建议大家编写HTML标签的时候尽量严谨一些) 什么是CSS ?CSS: Cascading Style Sheet，层叠样式表，用于控制页面的样式（表现）。 基础标签 &amp; 样式标题【标题排版】图片标签：&lt;img&gt; src：指定图像的url（绝对路径 &#x2F; 相对路径） width：图像的宽度（像素 &#x2F; 相对于父元素的百分比） height：图像的高度（像素 &#x2F; 相对于父元素的百分比） 1234567891011121314151617181920A. 图片标签: &lt;img&gt;B. 常见属性: src: 指定图像的url (可以指定 绝对路径 , 也可以指定 相对路径)\twidth: 图像的宽度 (像素 / 百分比 , 相对于父元素的百分比)\theight: 图像的高度 (像素 / 百分比 , 相对于父元素的百分比) 备注: 一般width 和 height 我们只会指定一个，另外一个会自动的等比例缩放。\tC. 路径书写方式: 绝对路径: 1. 绝对磁盘路径: C:\\Users\\Administrator\\Desktop\\HTML\\img ews_logo.png &lt;img src=&quot;C:\\Users\\Administrator\\Desktop\\HTML\\img ews_logo.png&quot;&gt; 2. 绝对网络路径: https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png &lt;img src=&quot;https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png&quot;&gt; 相对路径: ./ : 当前目录 , ./ 可以省略的 ../: 上一级目录 标题标签h系列 标题标签：&lt;h1&gt; - &lt;h6&gt; 水平线标签：&lt;hr&gt;图片 12345678910A. 标题标签: &lt;h1&gt; - &lt;h6&gt; &lt;h1&gt;111111111111&lt;/h1&gt;\t&lt;h2&gt;111111111111&lt;/h2&gt;\t&lt;h3&gt;111111111111&lt;/h3&gt;\t&lt;h4&gt;111111111111&lt;/h4&gt;\t&lt;h5&gt;111111111111&lt;/h5&gt;\t&lt;h6&gt;111111111111&lt;/h6&gt;\tB. 效果 : h1为一级标题，字体也是最大的 ； h6为六级标题，字体是最小的。 注意：HTML标签都是预定义好的，不能自己随意定义。 [补充]&lt;span&gt;标签 &lt;span&gt; 是一个在开发网页时大量会用到的没有语义的布局标签 特点：一行可以显示多个(组合行内元素)，宽度和高度默认由内容撑开 [补充]路径选择 (1)绝对路径：绝对磁盘路径（D:&#x2F;xxxx）、绝对网络路径（https://xxxx） (2)相对路径：从当前文件开始查找。 （.&#x2F; : 当前目录, ..&#x2F; : 上级目录） 【标题样式】CSS引入方式： (1)行内样式：写在标签的style属性中（不推荐），属性值是css属性键值对。 1&lt;h1 style=&quot;xxx: xxx; xxx: xxx;&quot;&gt;中国新闻网&lt;/h1&gt; (2)内嵌样式：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中），在标签内部定义css样式。 123456&lt;style&gt; h1 &#123; xxx: xxx; xxx: xxx; &#125;&lt;/style&gt; (3)外联样式：写在一个单独的.css文件中（需要通过 link 标签在网页中引入，通过href属性引入外部css文件。） 123456h1 &#123; xxx: xxx; xxx: xxx;&#125;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/news.css&quot;&gt; 上述3种引入方式，企业开发的使用情况如下： 内联样式会出现大量的代码冗余，不方便后期的维护，所以不常用。 内部样式，通过定义css选择器，让样式作用于当前页面的指定的标签上。 外部样式，html和css实现了完全的分离，企业开发常用方式。 [补充]CSS属性-颜色设置方式 表示方式 表示含义 取值 关键字 预定义的颜色名 red、green、blue… rgb表示法 红绿蓝三原色，每项取值范围：0-255 rgb(0,0,0)、rgb(255,255,255)、rgb(255,0,0) 十六进制表示法 #开头，将数字转换成十六进制表示 #000000、#ff0000、#cccccc，简写：#000、#ccc 颜色属性：color: 设置文本内容的颜色 [补充]CSS选择器：来选取需要设置样式的元素(标签) (1)元素（标签）选择器： 选择器的名字必须是标签的名字 作用：选择器中的样式会作用于所有同名的标签上 123元素名称 &#123; css样式名:css样式值；&#125; 例子如下： 123div&#123; color: red;&#125; (2)id选择器: 选择器的名字前面需要加上# 作用：选择器中的样式会作用于指定id的标签上，而且有且只有一个标签（由于id是唯一的） 123#id属性值 &#123; css样式名:css样式值；&#125; 例子如下： 123#did &#123; color: blue;&#125; (3)类选择器： 选择器的名字前面需要加上 . 作用：选择器中的样式会作用于所有class的属性值和该名字一样的标签上，可以是多个 123.class属性值 &#123; css样式名:css样式值；&#125; 例子如下： 123.cls&#123; color: green; &#125; [补充]css属性 font-size：字体大小 （注意：记得加px） 【超链接】标签： 1&lt;a href=&quot;...&quot; target=&quot;...&quot;&gt;央视网&lt;/a&gt; 属性： href：指定资源访问的url target：指定在何处打开资源链接 _self：默认值，在当前页面打开 _blank：在空白页面打开 [补充]CSS属性 text-decoration：规定添加到文本的修饰，none表示定义标准的文本。 color：定义文本的颜色。 正文【正文排版】 视频标签：&lt;video&gt; src：规定视频的url controls：显示播放控件 width：播放器的宽度 height：播放器的高度 音频标签：&lt;audio&gt; src：规定音频的url controls：显示播放控件 段落标签：换行~&lt;br&gt; , 段落：&lt;p&gt; 显示结果 描述 占位符 空格 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; “ 引号 &amp;quot; ‘ 撇号 &amp;apos; ​ 4. 文本加粗标签: &lt;b&gt; &#x2F; &lt;strong&gt; 效果 标签 标签(强调) 加粗 b strong 倾斜 i em 下划线 u ins 删除线 s del [补充]CSS属性-文本排版样式 line-height：设置行高 text-indent：定义第一个行内容的缩进 text-align：规定元素中的文本的水平对齐方式 【页面布局】盒子模型 盒子：页面中所有的元素（标签），都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局。 盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）。 布局标签实际开发网页中，会大量频繁的使用 div 和 span 这两个没有语义的布局标签。 标签：&lt;div&gt; &lt;span&gt; 特点： div标签： 一行只显示一个（独占一行） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高（width、height） span标签： 一行可以显示多个 宽度和高度默认由内容撑开 不可以设置宽高（width、height） [补充]CSS盒子模型 组成：内容（content）、内边距（padding）、边框（border）、外边距（margin） [补充]CSS属性 width：设置宽度 height：设置高度 border：设置边框的属性，如：1px solid #000； padding：内边距 margin：外边距 注意：如果只需要设置某一个方位的边框、内边距、外边距，可以在属性名后加上 – 位置，如：padding-top、padding-left、padding-right … 布局实现 需要将body中的新闻标题部分、正文部分使用一个 div 布局标签将其包裹起来，方便通过css设置内容占用的宽度，比如：65%。 通过css为该div设置外边距，左右的外边距分别为：17.5%，上下外边距靠边展示即可，为：0%。 表格、表单标签表格标签场景：在网页中以表格（行、列）形式整齐展示数据，如：班级表。标签： 标签 描述 属性&#x2F;备注 &lt;table&gt; 定义表格整体，可以包裹多个 &lt;tr&gt; border：规定表格边框的宽度 width：规定表格的宽度 cellspacing: 规定单元之间的空间。 &lt;tr&gt; 表格的行，可以包裹多个 &lt;td&gt; &lt;td&gt; 表格单元格(普通)，可以包裹内容 如果是表头单元格，可以替换为 &lt;th&gt; 表单标签场景：在网页中主要负责数据采集功能，如 注册、登录等数据采集。 标签：&lt;form&gt; 表单项：不同类型的 input 元素、下拉列表、文本域等。 &lt;input&gt;：定义表单项，通过type属性控制输入形式 &lt;select&gt;：定义下拉列表，&lt;option&gt;定义列表项 &lt;textarea&gt;：定义文本域 属性： action：规定当提交表单时向何处发送表单数据，URL method：规定用于发送表单数据的方式。GET、POST GET：表单数据是拼接在url后面的， 如： xxxxxxxxxxx?username&#x3D;Tom&amp;age&#x3D;12，url中能携带的表单数据大小是有限制的。 POST： 表单数据是在请求体（消息体）中携带的，大小没有限制。 注意事项 表单中的所有表单项，要想能够正常的采集数据，在提交的时候能提交到服务端，表单项必须指定name属性。 否则，无法提交该表单项。 1用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 表单标签-表单项&lt;input&gt; type取值 描述 形式 text 默认值，定义单行的输入字段 password 定义密码字段 radio 定义单选按钮 checkbox 定义复选框 file 定义文件上传按钮 date&#x2F;time&#x2F;datetime-local 定义日期&#x2F;时间&#x2F;日期时间 number 定义数字输入框 email 定义邮件输入框 hidden 定义隐藏域 submit &#x2F; reset &#x2F; button 定义提交按钮 &#x2F; 重置按钮 &#x2F; 可点击按钮 文档查阅文档地址: https://www.w3school.com.cn/index.html"},{"title":"【Java基础】【java.lang.reflect】Junit单元测试、反射","path":"/2024/04/10/【Java基础】【java.lang.reflect】Junit单元测试、反射/","content":"单元测试快速入门单元测试 单元测试就是针对最小的功能单元(方法)，编写测试代码对该功能进行正确性测试。 目前测试方法是怎么进行的？ 存在什么问题 ？ 只能编写main方法，并在main方法中再去调用其他方法进行测试。 使用起来很不灵活，无法实现自动化测试。 无法得到测试的报告，需要程序员自己去观察测试是否成功。 Junit单元测试框架 JUnit是使用Java语言实现的单元测试框架，它是第三方公司开源出来的，很多开发工具已经集成了Junit框架，比如IDEA。 优点 编写的测试代码很灵活，可以指某个测试方法执行测试，也支持一键完成自动化测试。 不需要程序员去分析测试的结果，会自动生成测试报告出来。 提供了更强大的测试能力。 需求 某个系统，有多个业务方法，请使用Junit框架完成对这些方法的单元测试。 具体步骤 将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要我们自己手工导入了）。 编写测试类、测试类方法（注意：测试方法必须是公共的，无参数，无返回值的非静态方法）。 【灵魂】必须在测试方法上使用@Test注解（标注该方法是一个测试方法）。（在报错的地方使用alt+enter，导入JUnit4。这个是经典版本，但是版本5可读性更好。） 在测试方法中，编写程序调用被测试的方法即可。（测试某个方法直接右键该方法启动测试。测试全部方法，可以选择类或者模块启动。） 选中测试方法，右键选择“JUnit运行” ，如果测试通过则是绿色；如果测试失败，则是红色。 先准备一个类，假设写了一个StringUtil工具类，代码如下 12345public class StringUtil&#123; public static void printNumber(String name)&#123; System.out.println(&quot;名字长度：&quot;+name.length()); &#125;&#125; 接下来，写一个测试类，测试StringUtil工具类中的方法能否正常使用。 1234567public class StringUtilTest&#123; @Test public void testPrintNumber()&#123; StringUtil.printNumber(&quot;admin&quot;); StringUtil.printNumber(null); &#125;&#125; 写完代码之后，我们会发现测试方法左边，会有一个绿色的三角形按钮。点击这个按钮，就可以运行测试方法。 单元测试断言断言：意思是程序员可以预测程序的运行结果，检查程序的运行结果是否与预期一致。** 我们在StringUtil类中新增一个测试方法 123456public static int getMaxIndex(String data)&#123; if(data == null)&#123; return -1; &#125; return data.length();&#125; 接下来，我们在StringUtilTest类中写一个测试方法 12345678910111213public class StringUtilTest&#123; @Test public void testGetMaxIndex()&#123; int index1 = StringUtil.getMaxIndex(null); System.out.println(index1); int index2 = StringUtil.getMaxIndex(&quot;admin&quot;); System.out.println(index2); //断言机制：预测index2的结果 Assert.assertEquals(&quot;方法内部有Bug&quot;,4,index2); &#125;&#125; 运行测试方法，结果预期值与实际值不一致。 Junit框架的常见注解常见注解(Junit 4.xxxx版本) @Test。测试方法。 @Before。用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。 @After。用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。 @BeforeClass。用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。 @AfterClass。用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。 特点如下 12341.被@BeforeClass标记的方法,执行在所有方法之前2.被@AfterCalss标记的方法，执行在所有方法之后3.被@Before标记的方法，执行在每一个@Test方法之前4.被@After标记的方法，执行在每一个@Test方法之后 常见注解(Junit 5.xxxx版本) @Test。测试方法。 @BeforeEach。用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。 @AfterEach。用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。 @BeforeAll。用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。 @AfterAll。用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。 开始执行的方法:初始化资源。 执行完之后的方法:释放资源。 作用？应用场景？ 假设我想在每个测试方法中使用Socket对象，并且用完之后，需要把Socket关闭。代码就可以按照下面的结构来设计 1234567891011121314151617181920212223public class StringUtilTest&#123; private static Socket socket; @Before public void test1()&#123; System.out.println(&quot;--&gt; test1 Before 执行了&quot;); &#125; @BeforeClass public static void test11()&#123; System.out.println(&quot;--&gt; test11 BeforeClass 执行了&quot;); //初始化Socket对象 socket = new Socket(); &#125; @After public void test2()&#123; System.out.println(&quot;--&gt; test2 After 执行了&quot;); &#125; @AfterCalss public static void test22()&#123; System.out.println(&quot;--&gt; test22 AfterCalss 执行了&quot;); //关闭Socket socket.close(); &#125;&#125; 反射认识反射Reflection【核心思想】得到编译以后的class文件对象。 反射指的是允许以编程方式访问已加载类的成分（成员变量、方法、构造器等）。 在java.lang.reflect包中。 主要是用来做框架的。好理解一点，我们在写代码的时候，IDEA给我们提示的可以调用的方法。 反射学什么？ 加载类，获取类的字节码：Class对象。 反射第一步：获取类：Class。 获取类的构造器：Constructor。 获取类的成员变量：Field。 获取类的成员方法：Method。 获取类的构造器：Constructor对象。 获取类的成员变量：Field对象。 获取类的成员方法：Method对象。 之后再看反射的应用场景。 获取类反射第一步，获取Class类的对象。（3种方式。） Class c1 &#x3D; 类名.class。 调用Class提供的方法：public static Class.forName(String package)。 Object提供的方法：public Class getClass()。 1234567891011121314public class Test1Class&#123; public static void main(String[] args)&#123; Class c1 = Student.class; System.out.println(c1.getName()); //获取全类名 System.out.println(c1.getSimpleName()); //获取简单类名 Class c2 = Class.forName(&quot;com.itheima.d2_reflect.Student&quot;); System.out.println(c1 == c2); //true Student s = new Student(); Class c3 = s.getClass(); System.out.println(c2 == c3); //true &#125;&#125; 获取类的构造器Class类提供的几个方法 Constructor&lt;?&gt;[] getConstructors()。返回所有构造器对象的数组（只能拿public的）。 Constructor&lt;?&gt;[] getDeclaredConstructors()。返回所有构造器对象的数组，存在就能拿到。 Constructor getConstructor(Class&lt;?&gt;… parameterTypes)。返回单个构造器对象（只能拿public的）。 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)。返回单个构造器对象，存在就能拿到。 方便记忆： 1234get:获取Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个public修饰的Constructor: 构造方法的意思后缀s: 表示可以获取多个，没有后缀s只能获取一个 假设现在有一个Cat类，里面有几个构造方法，代码如下： 123456789101112public class Cat&#123; private String name; private int age; public Cat()&#123; &#125; private Cat(String name, int age)&#123; &#125;&#125; 接下来，我们写一个测试方法，来测试获取类中所有的构造器： 1234567891011121314public class Test2Constructor()&#123; @Test public void testGetConstructors()&#123; //1、反射第一步：必须先得到这个类的Class对象 Class c = Cat.class; //2、获取类的全部构造器 Constructor[] constructors = c.getDeclaredConstructors(); //3、遍历数组中的每一个构造器对象。 for(Constructor constructor: constructors)&#123; System.out.println(constructor.getName()+&quot;---&gt; 参数个数：&quot;+constructor.getParameterCount()); &#125; &#125;&#125; 刚才的是获取Cat类中所有的构造器，接下来试一试单个构造器： 123456789101112131415161718public class Test2Constructor()&#123; @Test public void testGetConstructor()&#123; //1、反射第一步：必须先得到这个类的Class对象 Class c = Cat.class; //2、获取类public修饰的空参数构造器 Constructor constructor1 = c.getConstructor(); System.out.println(constructor1.getName()+&quot;---&gt; 参数个数：&quot;+constructor1.getParameterCount()); //3、获取private修饰的有两个参数的构造器，第一个参数String类型，第二个参数int类型 Constructor constructor2 = c.getDeclaredConstructor(String.class,int.class); System.out.println(constructor2.getName()+&quot;---&gt; 参数个数：&quot;+constructor1.getParameterCount()); &#125;&#125; 获取类构造器的作用初始化对象返回。注意：这两个方法时属于Constructor的，需要用Constructor对象来调用。 T newInstance(Object… initargs)。根据指定的构造器创建对象。（反射后的构造器依然是创建对象的。） public void setAccessible(boolean flag)。设置为true,表示取消访问检查，进行暴力反射。（–&gt;反射会破坏封装性，私有的也可以执行了。） 代码演示constructor1和constructor2分别表示Cat类中的两个构造器。现在我要把这两个构造器执行起来 由于构造器是private修饰的，先需要调用setAccessible(true) 表示禁止检查访问控制，然后再调用newInstance(实参列表) 就可以执行构造器，完成对象的初始化了。 代码如下：为了看到构造器真的执行， 故意在两个构造器中分别加了两个打印语句 注意：上面这种代码风格，看起来没什么必要，可以先稍微记一记，以后学习框架的时候有用。 获取类的成员变量&amp;使用Class类中提供的获取成员变量的方法 Field[] getFields()。返回所有成员变量对象的数组（只能拿public的）。 Field[] getDeclaredFields()。返回所有成员变量对象的数组，存在就能拿到。 Field getField(String name)。返回单个成员变量对象（只能拿public的）。 Field getDeclaredField(String name)。返回单个成员变量对象，存在就能拿到。 记忆规则 1234get:获取Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个public修饰的Field: 成员变量的意思后缀s: 表示可以获取多个，没有后缀s只能获取一个 获取成员变量的作用依然是在某个对象中取值、赋值。 Field类中用于取值、赋值的方法 void set(Object obj, Object value)。赋值。 Object get(Object obj)。获取值。 setAccessible(boolean)。如果某成员变量是非public的，需要打开权限（暴力反射），然后再取值、赋值。 代码演示 设有一个Cat类它有若干个成员变量，用Class类提供 的方法将成员变量的对象获取出来。 执行完上面的代码之后，我们可以看到控制台上打印输出了，每一个成员变量的名称和它的类型。 获取到成员变量的对象之后该如何使用呢？ 在Filed类中提供给给成员变量赋值和获取值的方法： void set(object obj,Object value)。赋值。 object get(object obj)。取值。 public voidsetAccessible(boolean flag)。设置为true，表示禁止检查访问控制(暴力反射)。 再次强调一下设置值、获取值的方法时Filed类的需要用Filed类的对象来调用，而且不管是设置值、还是获取值，都需要依赖于该变量所属的对象。代码如下 获取类的成员方法使用反射技术获取方法对象并使用 反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。 Class类中用于获取成员方法的方法 Method[] getMethods()。返回所有成员方法对象的数组（只能拿public的）。 Method[] getDeclaredMethods()。返回所有成员方法对象的数组，存在就能拿到。 Method getMethod(String name, Class&lt;?&gt;… parameterTypes)。返回单个成员方法对象（只能拿public的）。 Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)。返回单个成员方法对象，存在就能拿到。 使用反射技术获取方法对象并使用 获取成员方法的作用依然是在某个对象中进行执行此方法。 Method类中用于触发执行的方法 Object invoke(Object obj, Object… args)。 参数一：用obj对象调用该方法 参数二：调用方法的传递的参数（如果没有就不写） 返回值：方法的返回值（如果没有就不写） setAccessible(boolean)。如果某成员方法是非public的，需要打开权限（暴力反射），然后再触发执行。 把run()方法和eat(String name)方法执行起来。看分割线之下的代码 1234567891011121314151617181920212223242526272829public class Test3Method&#123; public static void main(String[] args)&#123; //1、反射第一步：先获取到Class对象 Class c = Cat.class; //2、获取类中的全部成员方法 Method[] methods = c.getDecalaredMethods(); //3、遍历这个数组中的每一个方法对象 for(Method method : methods)&#123; System.out.println(method.getName()+&quot;--&gt;&quot;+method.getParameterCount()+&quot;--&gt;&quot;+method.getReturnType()); &#125; System.out.println(&quot;-----------------------&quot;); //4、获取private修饰的run方法，得到Method对象 Method run = c.getDecalaredMethod(&quot;run&quot;); //执行run方法,在执行前需要取消权限检查 Cat cat = new Cat(); run.setAccessible(true); Object rs1 = run.invoke(cat); System.out.println(rs1) //5、获取private 修饰的eat(String name)方法，得到Method对象 Method eat = c.getDeclaredMethod(&quot;eat&quot;,String.class); eat.setAccessible(true); Object rs2 = eat.invoke(cat,&quot;鱼儿&quot;); System.out.println(rs2) &#125;&#125; 作用、应用场景作用 基本作用：得到一个类的全部成分然后操作； 破坏封装性； 最重要的用途：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。 一个简易的框架 步骤 1234567891.先写好两个类，一个Student类和Teacher类2.写一个ObjectFrame类代表框本架\t在ObjectFrame类中定义一个saveObject(Object obj)方法，用于将任意对象存到文件中去\t参数：Object obj: 就表示要存入文件中的对象\t3.编写方法内部的代码，往文件中存储对象的属性名和属性值\t1)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。\t2)接着就通过反射获取类的成员变量信息了（变量名、变量值）\t3)把变量名和变量值写到文件中去 写一个ObjectFrame表示自己设计的框架，代码如下图所示 12345678910111213141516171819public class ObjectFrame&#123; public static void saveObject(Object obj) throws Exception&#123; PrintStream ps = new PrintStream(new FileOutputStream(&quot;模块名\\\\src\\\\data.txt&quot;,true)); //1)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。 //2)接着就通过反射获取类的成员变量信息了（变量名、变量值） Class c = obj.getClass(); //获取字节码 ps.println(&quot;---------&quot;+class.getSimpleName()+&quot;---------&quot;); Field[] fields = c.getDeclaredFields(); //获取所有成员变量 //3)把变量名和变量值写到文件中去 for(Field field : fields)&#123; String name = field.getName(); Object value = field.get(obj)+&quot;&quot;; ps.println(name); &#125; ps.close(); &#125;&#125; 使用自己设计的框架，往文件中写入Student对象的信息和Teacher对象的信息。 先准备好Student类和Teacher类 1234567public class Student&#123; private String name; private int age; private char sex; private double height; private String hobby;&#125; 1234public class Teacher&#123; private String name; private double salary;&#125; 创建一个测试类，在测试中类创建一个Student对象，创建一个Teacher对象，用ObjectFrame的方法把这两个对象所有的属性名和属性值写到文件中去。 12345678910public class Test5Frame&#123; @Test public void save() throws Exception&#123; Student s1 = new Student(&quot;黑马吴彦祖&quot;,45, &#x27;男&#x27;, 185.3, &quot;篮球，冰球，阅读&quot;); Teacher s2 = new Teacher(&quot;播妞&quot;,999.9); ObjectFrame.save(s1); ObjectFrame.save(s2); &#125;&#125; 注解认识注解&amp;定义注解 Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。 Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。 自定义注解 — 格式自定义注解就是自己做一个注解来使用。 123public @interface 注解名称 &#123;\tpublic 属性类型 属性名() default 默认值 ;&#125; 属性类型：Java支持的数据类型基本上都支持。 注解的作用 对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。 例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。 特殊属性 value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!! 但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。 比如：现在我们自定义一个MyTest注解 12345public @interface MyTest&#123; String aaa(); boolean bbb() default true;\t//default true 表示默认值为true,使用时可以不赋值。 String[] ccc();&#125; 定义好MyTest注解之后，我们可以使用MyTest注解在类上、方法上等位置做标记。注意使用注解时需要加@符号，如下 1234567@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)public class AnnotationTest1&#123; @MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;) public void test1()&#123; &#125;&#125; 注意：注解的属性名如何是value的话，并且只有value没有默认值，使用注解时value名称可以省略。比如现在重新定义一个MyTest2注解 1234public @interface MyTest2&#123; String value(); //特殊属性 int age() default 10;&#125; 定义好MyTest2注解后，再将@MyTest2标记在类上，此时value属性名可以省略，代码如下 12345678@MyTest2(&quot;孙悟空&quot;) //等价于 @MyTest2(value=&quot;孙悟空&quot;)@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)public class AnnotationTest1&#123; @MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;) public void test1()&#123; &#125;&#125; 注解的本质是接口 想要搞清楚注解本质是什么东西，我们可以把注解的字节码进行反编译，使用XJad工具进行反编译。经过对MyTest1注解字节码反编译我们会发现： 12341.MyTest1注解本质上是接口，每一个注解接口都继承子Annotation接口2.MyTest1注解中的属性本质上是抽象方法3.@MyTest1实际上是作为MyTest接口的实现类对象4.@MyTest1(aaa=&quot;孙悟空&quot;,bbb=false,ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)里面的属性值，可以通过调用aaa()、bbb()、ccc()方法获取到。 【别着急，继续往下看，再解析注解时会用到】 元注解元注解：注解注解的注解。 元注解有两个： @Target: 约束自定义注解只能在哪些地方使用。 @Retention：申明注解的生命周期。 @Target注解和@Retention注解12@Target是用来声明注解只能用在那些位置，比如：类上、方法上、成员变量上等@Retetion是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期 @Target元注解的使用：比如定义一个MyTest3注解，并添加@Target注解用来声明MyTest3的使用位置 1234@Target(ElementType.TYPE)\t//声明@MyTest3注解只能用在类上public @interface MyTest3&#123; &#125; 接下来，把@MyTest3用来类上观察是否有错，再把@MyTest3用在方法上、变量上再观察是否有错。 如果我们定义MyTest3注解时，使用@Target注解属性值写成下面样子 12345//声明@MyTest3注解只能用在类上和方法上@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)\tpublic @interface MyTest3&#123; &#125; 再观察，@MyTest用在类上、方法上、变量上是否有错。 @Retetion元注解的使用定义MyTest3注解时，给MyTest3注解添加@Retetion注解来声明MyTest3注解保留的时期。 12345@Retetion是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期\t@Retetion(RetetionPloicy.SOURCE): 注解保留到源代码时期、字节码中就没有了\t@Retetion(RetetionPloicy.CLASS): 注解保留到字节码中、运行时注解就没有了\t@Retetion(RetetionPloicy.RUNTIME)：注解保留到运行时期\t【自己写代码时，比较常用的是保留到运行时期】 1234567//声明@MyTest3注解只能用在类上和方法上@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)\t//控制使用了@MyTest3注解的代码中，@MyTest3保留到运行时期@Retetion(RetetionPloicy.RUNTIME)public @interface MyTest3&#123; &#125; 解析注解注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。 可以通过反射技术把类上、方法上、变量上的注解对象获取出来，然后通过调用方法就可以获取注解上的属性值了。 解析注解套路如下 12341.如果注解在类上，先获取类的字节码对象，再获取类上的注解2.如果注解在方法上，先获取方法对象，再获取方法上的注解3.如果注解在成员变量上，先获取成员变量对象，再获取变量上的注解总之：注解在谁身上，就先获取谁，再用谁获取谁身上的注解 Class 、Method、Field,Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。 public Annotation[]getDeclaredAnnotations()。获取当前对象上面的注解。 public TgetDeclaredAnnotation(ClassannotationClass)。获取指定的注解对象。 public boolean isAnnotationPresent(class annotationclass)。判断当前对象上是否存在某个注解。 案例需求 定义注解MyTest4，要求如 包含属性:String value()。 包含属性:double aaa()，默认值为 100。 包含属性:Stringllbbb()。 限制注解使用的位置:类和成员方法上。 指定注解的有效范围:一直到运行时。 定义一个类叫:Demo，在类中定义一个test1方法，并在该类和其方法上使用MyTest4注解。 定义AnnotationTest3测试类，解析Demo类中的全部注解。 代码： ① 先定义一个MyTest4注解 123456789//声明@MyTest4注解只能用在类上和方法上@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)\t//控制使用了@MyTest4注解的代码中，@MyTest4保留到运行时期@Retetion(RetetionPloicy.RUNTIME)public @interface MyTest4&#123; String value(); double aaa() default 100; String[] bbb();&#125; ② 定义有一个类Demo 1234567@MyTest4(value=&quot;蜘蛛侠&quot;,aaa=99.9, bbb=&#123;&quot;至尊宝&quot;,&quot;黑马&quot;&#125;)public class Demo&#123; @MyTest4(value=&quot;孙悟空&quot;,aaa=199.9, bbb=&#123;&quot;紫霞&quot;,&quot;牛夫人&quot;&#125;) public void test1()&#123; &#125;&#125; ③ 写一个测试类AnnotationTest3解析Demo类上的MyTest4注解 12345678910111213141516171819202122232425262728293031323334public class AnnotationTest3&#123; @Test public void parseClass()&#123; //1.先获取Class对象 Class c = Demo.class; //2.解析Demo类上的注解 if(c.isAnnotationPresent(MyTest4.class))&#123; //获取类上的MyTest4注解 MyTest4 myTest4 = (MyTest4)c.getDeclaredAnnotation(MyTest4.class); //获取MyTests4注解的属性值 System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(myTest4.bbb()); &#125; &#125; @Test public void parseMethods()&#123; //1.先获取Class对象 Class c = Demo.class; //2.解析Demo类中test1方法上的注解MyTest4注解 Method m = c.getDeclaredMethod(&quot;test1&quot;); if(m.isAnnotationPresent(MyTest4.class))&#123; //获取方法上的MyTest4注解 MyTest4 myTest4 = (MyTest4)m.getDeclaredAnnotation(MyTest4.class); //获取MyTests4注解的属性值 System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(myTest4.bbb()); &#125; &#125;&#125; 注解的应用场景注解是用来写框架的，比如现在我们要模拟Junit写一个测试框架，要求有@MyTest注解的方法可以被框架执行，没有@MyTest注解的方法不能被框架执行。 第一步：先定义一个MyTest注解 12345@Target(ElementType.METHOD)\t@Retetion(RetetionPloicy.RUNTIME)public @interface MyTest&#123; &#125; 第二步：写一个测试类AnnotationTest4，在类中定义几个被@MyTest注解标记的方法 1234567891011121314151617181920212223242526272829303132public class AnnotationTest4&#123; @MyTest public void test1()&#123; System.out.println(&quot;=====test1====&quot;); &#125; @MyTest public void test2()&#123; System.out.println(&quot;=====test2====&quot;); &#125; public void test3()&#123; System.out.println(&quot;=====test2====&quot;); &#125; public static void main(String[] args)&#123; AnnotationTest4 a = new AnnotationTest4(); //1.先获取Class对象 Class c = AnnotationTest4.class; //2.解析AnnotationTest4类中所有的方法对象 Method[] methods = c.getDeclaredMethods(); for(Method m: methods)&#123; //3.判断方法上是否有MyTest注解，有就执行该方法 if(m.isAnnotationPresent(MyTest.class))&#123; m.invoke(a); &#125; &#125; &#125;&#125; 动态代理代理思想就是被代理者没有能力，或者不愿意去完成某件事情，需要找个人（代理）代替自己去完成这件事。 动态代理主要是对被代理对象的行为进行代理。是一个对象。 先把有唱歌和跳舞功能的接口，和实现接口的大明星类定义出来： 动态代理的开发步骤 必须定义接口，里面定义一些行为，用来约束被代理对象和代理对象都要完成的事情。 定义一个实现类实现接口，这个实现类的对象代表被代理的对象。 定义一个测试类，在里面创建被代理对象，然后为其创建一个代理对象返回。（重点） 代理对象中，需要模拟收首付款，真正触发被代理对象的行为，然后接收尾款操作。 通过返回的代理对象进行方法的调用，观察动态代理的执行流程。 如何创建代理对象 Java中代理的代表类是：java.lang.reflect.Proxy，它提供了一个静态方法，用于为被代理对象，产生一个代理对象返回。 1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) 为被代理对象返回一个代理对象。参数一：类加载器 加载代理类，产生代理对象。，。参数二：真实业务对象的接口。(被代理的方法交给代理对象)参数三：代理的核心处理程序。 写一个为BigStar生成动态代理对象的工具类。这里需要用Java为开发者提供的一个生成代理对象的类叫Proxy类。 通过Proxy类的newInstance(…)方法可以为实现了同一接口的类生成代理对象。 调用方法时需要传递三个参数： 123456789101112131415161718192021222324252627public class ProxyUtil &#123; public static Star createProxy(BigStar bigStar)&#123; /* newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 参数1：用于指定一个类加载器 参数2：指定生成的代理长什么样子，也就是有哪些方法 参数3：用来指定生成的代理对象要干什么事情 */ // Star starProxy = ProxyUtil.createProxy(s); // starProxy.sing(&quot;好日子&quot;) starProxy.dance() Star starProxy = (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), new Class[]&#123;Star.class&#125;, new InvocationHandler() &#123; @Override // 回调方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理对象要做的事情，会在这里写代码 if(method.getName().equals(&quot;sing&quot;))&#123; System.out.println(&quot;准备话筒，收钱20万&quot;); &#125;else if(method.getName().equals(&quot;dance&quot;))&#123; System.out.println(&quot;准备场地，收钱1000万&quot;); &#125; return method.invoke(bigStar, args); &#125; &#125;); return starProxy; &#125;&#125; 调用我们写好的ProxyUtil工具类，为BigStar对象生成代理对象 1234567891011public class Test &#123; public static void main(String[] args) &#123; BigStar s = new BigStar(&quot;杨超越&quot;); Star starProxy = ProxyUtil.createProxy(s); String rs = starProxy.sing(&quot;好日子&quot;); System.out.println(rs); starProxy.dance(); &#125;&#125; 通过代理对象调用方法，执行流程？ 先走向代理。 代理中可以真正触发被代理对象的方法执行。 回到代理中，由代理负责返回结果给调用者。 案例需求 模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时。 分析 定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。 定义一个实现类UserServiceImpl实现UserService，并完成相关功能，且统计每个功能的耗时。 定义测试类，创建实现类对象，调用方法。 现有如下代码 1234567891011/** * 用户业务接口 */public interface UserService &#123; // 登录功能 void login(String loginName,String passWord) throws Exception; // 删除用户 void deleteUsers() throws Exception; // 查询用户，返回数组的形式。 String[] selectUsers() throws Exception;&#125; UserService接口的实现类，每一个方法中要计算方法运行时间： 12345678910111213141516171819202122232425262728293031323334353637/** * 用户业务实现类（面向接口编程） */public class UserServiceImpl implements UserService&#123; @Override public void login(String loginName, String passWord) throws Exception &#123; long time1 = System.currentTimeMillis(); if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123; System.out.println(&quot;您登录成功，欢迎光临本系统~&quot;); &#125;else &#123; System.out.println(&quot;您登录失败，用户名或密码错误~&quot;); &#125; Thread.sleep(1000); long time2 = System.currentTimeMillis(); System.out.println(&quot;login方法耗时：&quot;+(time2-time1)); &#125; @Override public void deleteUsers() throws Exception&#123; long time1 = System.currentTimeMillis(); System.out.println(&quot;成功删除了1万个用户~&quot;); Thread.sleep(1500); long time2 = System.currentTimeMillis(); System.out.println(&quot;deleteUsers方法耗时：&quot;+(time2-time1)); &#125; @Override public String[] selectUsers() throws Exception&#123; long time1 = System.currentTimeMillis(); System.out.println(&quot;查询出了3个用户&quot;); String[] names = &#123;&quot;张全蛋&quot;, &quot;李二狗&quot;, &quot;牛爱花&quot;&#125;; Thread.sleep(500); long time2 = System.currentTimeMillis(); System.out.println(&quot;selectUsers方法耗时：&quot;+(time2-time1)); return names; &#125;&#125; 本案例存在哪些问题？ 答：业务对象的的每个方法都要进行性能统计，存在大量重复的代码。 每一个方法中计算耗时的代码都是重复的，这些重复的代码并不属于UserSerivce的主要业务代码。接下来打算把计算每一个方法的耗时操作交给代理对象来做。 优化的关键步骤 必须有接口，实现类要实现接口（代理通常是基于接口实现的）。 创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。 先在UserService类中把计算耗时的代码删除，代码如下 123456789101112131415161718192021222324252627282930/** * 用户业务实现类（面向接口编程） */public class UserServiceImpl implements UserService&#123; @Override public void login(String loginName, String passWord) throws Exception &#123; if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123; System.out.println(&quot;您登录成功，欢迎光临本系统~&quot;); &#125;else &#123; System.out.println(&quot;您登录失败，用户名或密码错误~&quot;); &#125; Thread.sleep(1000); &#125; @Override public void deleteUsers() throws Exception&#123; System.out.println(&quot;成功删除了1万个用户~&quot;); Thread.sleep(1500); &#125; @Override public String[] selectUsers() throws Exception&#123; System.out.println(&quot;查询出了3个用户&quot;); String[] names = &#123;&quot;张全蛋&quot;, &quot;李二狗&quot;, &quot;牛爱花&quot;&#125;; Thread.sleep(500); return names; &#125;&#125; 然后为UserService生成一个动态代理对象，在动态代理中调用目标方法，在调用目标方法之前和之后记录毫秒值，并计算方法运行的时间。代码如下 123456789101112131415161718192021222324252627282930public class ProxyUtil &#123; public static UserService createProxy(UserService userService)&#123; UserService userServiceProxy = (UserService) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), new Class[]&#123;UserService.class&#125;, new InvocationHandler() &#123; @Override public Object invoke( Object proxy, Method method, Object[] args) throws Throwable &#123; if( method.getName().equals(&quot;login&quot;) || method.getName().equals(&quot;deleteUsers&quot;)|| method.getName().equals(&quot;selectUsers&quot;))&#123; //方法运行前记录毫秒值 long startTime = System.currentTimeMillis(); //执行方法 Object rs = method.invoke(userService, args); //执行方法后记录毫秒值 long endTime = System.currentTimeMillis(); System.out.println(method.getName() + &quot;方法执行耗时：&quot; + (endTime - startTime)/ 1000.0 + &quot;s&quot;); return rs; &#125;else &#123; Object rs = method.invoke(userService, args); return rs; &#125; &#125; &#125;); //返回代理对象 return userServiceProxy; &#125;&#125; 在测试类中为UserService创建代理对象 123456789101112131415161718192021/** * 目标：使用动态代理解决实际问题，并掌握使用代理的好处。 */public class Test &#123; public static void main(String[] args) throws Exception&#123; // 1、创建用户业务对象。 UserService userService = ProxyUtil.createProxy(new UserServiceImpl()); // 2、调用用户业务的功能。 userService.login(&quot;admin&quot;, &quot;123456&quot;); System.out.println(&quot;----------------------------------&quot;); userService.deleteUsers(); System.out.println(&quot;----------------------------------&quot;); String[] names = userService.selectUsers(); System.out.println(&quot;查询到的用户是：&quot; + Arrays.toString(names)); System.out.println(&quot;----------------------------------&quot;); &#125;&#125; 动态代理对象的执行流程如下图所示，每次用代理对象调用方法时，都会执行InvocationHandler中的invoke方法。 动态代理的优点 可以在不改变方法源码的情况下，实现对方法功能的增强，提高了代码的复用。 简化了编程工作、提高了开发效率，同时提高了软件系统的可扩展性。 可以为被代理对象的所有方法做代理。 非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。"},{"title":"【Java基础】【java.lang】多线程","path":"/2024/04/09/【Java基础】【java.lang】多线程/","content":"概述线程 线程(Thread)是一个程序内部的一条执行流程。 程序中如果只有一条执行流程，那这个程序就是单线程的程序。 多线程 多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）。 例如：买票系统、百度网盘下载、消息通信、淘宝、京东系统都离不开多线程技术。 创建方法Java是通过java.lang.Thread 类的对象来代表线程的。 注意main方法由一条默认的主线负责执行。在main里面启动的线程称为子线程。 方式1：继承Thread类步骤 定义一个子类MyThread继承线程类java.lang.Thread。 重写run()方法。 创建MyThread类的对象。 调用线程对象的start()方法启动线程（启动后还是执行run方法的）。 优缺点 优点：编码简单。 缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。 注意事项 启动线程必须是调用start方法，不是调用run方法。 如果直接调用run方法就不认为是一条线程启动了，而是把Thread当做一个普通对象，此时run方法中的执行的代码会成为主线程的一部分。 不要把主线程任务放在启动子线程之前（否则先跑完主线程才启动子线程）。 直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。 只有调用start方法才是启动一个新的线程执行。 这样主线程一直是先跑完的，相当于是一个单线程的效果了。 12345678910public class MyThread extends Thread&#123; // 2、必须重写Thread类的run方法 @Override public void run() &#123; // 描述线程的执行任务。 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程MyThread输出：&quot; + i); &#125; &#125;&#125; 再定义一个测试类，在测试类中创建MyThread线程对象，并启动线程。 12345678910111213public class ThreadTest1 &#123; // main方法是由一条默认的主线程负责执行。 public static void main(String[] args) &#123; // 3、创建MyThread线程类的对象代表一个线程 Thread t = new MyThread(); // 4、启动线程（自动执行run方法的） t.start(); for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;主线程main输出：&quot; + i); &#125; &#125;&#125; MyThread和main线程在相互抢夺CPU的执行权（注意：哪一个线程先执行，哪一个线程后执行，目前我们是无法控制的，每次输出结果都会不一样）。 方式2：实现Runnable接口步骤 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法。 创建MyRunnable任务对象。 把MyRunnable任务对象交给Thread线程对象处理。 public Thread(Runnable target)。封装Runnable对象成为线程对象。 调用线程对象的start()方法启动线程。 优缺点 优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强。 缺点：需要多一个Runnable对象。 先准备一个Runnable接口的实现类： 12345678910111213/** * 1、定义一个任务类，实现Runnable接口 */public class MyRunnable implements Runnable&#123; // 2、重写runnable的run方法 @Override public void run() &#123; // 线程要执行的任务。 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程输出 ===》&quot; + i); &#125; &#125;&#125; 再写一个测试类，在测试类中创建线程对象，并执行线程： 12345678910111213public class ThreadTest2 &#123; public static void main(String[] args) &#123; // 3、创建任务对象。 Runnable target = new MyRunnable(); // 4、把任务对象交给一个线程对象处理。 // public Thread(Runnable target) new Thread(target).start(); for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;主线程main输出 ===》&quot; + i); &#125; &#125;&#125; 匿名内部类写法（简化代码风格） 可以创建Runnable的匿名内部类形式（任务对象）。 再交给Thread线程对象。 再调用线程对象的start()启动线程。 1234567891011121314151617181920212223242526272829303132333435public class ThreadTest2_2 &#123; public static void main(String[] args) &#123; // 1、直接创建Runnable接口的匿名内部类形式（任务对象） Runnable target = new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程1输出：&quot; + i); &#125; &#125; &#125;; new Thread(target).start(); // 简化形式1： new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程2输出：&quot; + i); &#125; &#125; &#125;).start(); // 简化形式2： new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程3输出：&quot; + i); &#125; &#125;).start(); for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;主线程main输出：&quot; + i); &#125; &#125;&#125; 方式3：实现Callable接口原因： 前面两种的问题：假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果。 解决方案： JDK 5.0提供了Callable接口和FutureTask类来实现（多线程的第三种创建方式）。 这种方式最大的优点：可以返回线程执行完毕后的结果。 步骤 创建任务对象 定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。 把Callable类型的对象封装成FutureTask（线程任务对象）。 把线程任务对象交给Thread对象。 调用Thread对象的start方法启动线程。 线程执行完毕后，通过FutureTask对象的的get方法去获取线程任务执行的结果。 未来任务对象的作用？ 是一个任务对象，实现了Runnable对象。 可以在线程执行完毕后，通过FutureTask对象的的get方法去获取线程任务执行的结果。 先准备一个Callable接口的实现类： 12345678910111213/** * 1、让子类继承Thread线程类。 */public class MyThread extends Thread&#123; // 2、必须重写Thread类的run方法 @Override public void run() &#123; // 描述线程的执行任务。 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程MyThread输出：&quot; + i); &#125; &#125;&#125; 再定义一个测试类，在测试类中创建线程并启动线程，还要获取返回结果： 12345678910111213141516171819202122232425262728public class ThreadTest3 &#123; public static void main(String[] args) throws Exception &#123; // 3、创建一个Callable的对象 Callable&lt;String&gt; call = new MyCallable(100); // 4、把Callable的对象封装成一个FutureTask对象（任务对象） // 未来任务对象的作用？ // 1、是一个任务对象，实现了Runnable对象. // 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。 FutureTask&lt;String&gt; f1 = new FutureTask&lt;&gt;(call); // 5、把任务对象交给一个Thread对象 new Thread(f1).start(); Callable&lt;String&gt; call2 = new MyCallable(200); FutureTask&lt;String&gt; f2 = new FutureTask&lt;&gt;(call2); new Thread(f2).start(); // 6、获取线程执行完毕后返回的结果。 // 注意：如果执行到这儿，假如上面的线程还没有执行完毕 // 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。 String rs = f1.get(); System.out.println(rs); String rs2 = f2.get(); System.out.println(rs2); &#125;&#125; FutureTask的API 构造器：public FutureTask&lt;&gt;(Callable call)。把Callable对象封装成FutureTask对象。 方法：public V get() throws Exception。获取线程执行call方法返回的结果。 优缺点 优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。 缺点：编码复杂一点。 3种方法比较 方式 优点 缺点 继承Thread类 编程比较简单，可以直接使用Thread类中的方法 扩展性较差，不能再继承其他的类，不能返回线程执行的结果 实现Runnable接口 扩展性强，实现该接口的同时还可以继承其他的类。 编程相对复杂，不能返回线程执行的结果 实现Callable接口 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 编程相对复杂 Thread的常用方法常用方法 public void run()。线程的任务方法。 public void start()。线程的任务方法。 public String getName()。获取当前线程的名称，线程名称默认是Thread-索引。 public void setName(String name)。为线程设置名称。 public static Thread currentThread()。获取当前执行的线程对象。 public static void sleep(long time)。让当前执行的线程休眠多少毫秒后，再继续执行。 public final void join()…。让调用当前这个方法的线程先执行完！ 构造器 public Thread(String name)。可以为当前线程指定名称。 public Thread(Runnable target)。封装Runnable对象成为线程对象。 public Thread(Runnable target, String name)。封装Runnable对象成为线程对象，并指定线程名称。 其他 Thread类还提供了诸如：yield、interrupt、守护线程、线程优先级等线程的控制方法，在开发中很少使用，用到再说。 线程安全什么是线程安全问题 多个线程，同时访问同一个共享资源，并存在修改该资源的时候，可能会出现业务安全问题。 取钱的线程安全问题 场景：小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元，如果小明和小红同时来取钱，并且2人各自都在取钱10万元，可能会出现什么问题呢？ 用程序模拟线程安全问题先定义一个共享的账户类 123456789101112131415161718192021222324252627282930313233343536373839404142public class Account &#123; private String cardId; // 卡号 private double money; // 余额。 public Account() &#123; &#125; public Account(String cardId, double money) &#123; this.cardId = cardId; this.money = money; &#125; // 小明 小红同时过来的 public void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); // 1、判断余额是否足够 if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125; &#125; public String getCardId() &#123; return cardId; &#125; public void setCardId(String cardId) &#123; this.cardId = cardId; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125;&#125; 再定义一个是取钱的线程类 123456789101112public class DrawThread extends Thread&#123; private Account acc; public DrawThread(Account acc, String name)&#123; super(name); this.acc = acc; &#125; @Override public void run() &#123; // 取钱(小明，小红) acc.drawMoney(100000); &#125;&#125; 最后，再写一个测试类，在测试类中创建两个线程对象 123456789public class ThreadTest &#123; public static void main(String[] args) &#123; // 1、创建一个账户对象，代表两个人的共享账户。 Account acc = new Account(&quot;ICBC-110&quot;, 100000); // 2、创建两个线程，分别代表小明 小红，再去同一个账户对象中取钱10万。 new DrawThread(acc, &quot;小明&quot;).start(); // 小明 new DrawThread(acc, &quot;小红&quot;).start(); // 小红 &#125;&#125; 运行程序，会发现两个人都取了10万块钱，余额为-10万了。 线程同步认识线程同步 线程同步：解决线程安全问题的方案。 思想：让多个线程实现先后依次访问共享资源，这样就解决了安全问题。 常见方案 加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来。 方式1：同步代码块 作用：把访问共享资源的核心代码给上锁，以此保证线程安全。 12345678synchronized(同步锁) &#123;\t访问共享资源的核心代码&#125;//快捷键：ctrl+alt+enter，选择第9个//同步锁例如可以写“黑马”，因为它在常量中只有一份//但是有个问题，就是小明来取锁住了自己家的账户，其他家的人也取不了钱了……（锁的对象太大！影响无关线程的执行）//所以同步锁可以用“this”//拓展：假设遇到多个线程调用静态方法，官方建议使用“类名.class”作为锁 原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行。 同步锁的注意事项：对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。 只需要修改DrawThread类中的代码 12345678910111213141516// 小明 小红线程同时过来的public void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); // 1、判断余额是否足够 // this正好代表共享资源！ synchronized (this) &#123; if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125; &#125;&#125; 【锁对象如何选择的问题】 1231.建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象2.对于实例方法，建议使用this作为锁对象3.对于静态方法，建议把类的字节码(类名.class)当做锁对象 方式2：同步方法 作用：把访问共享资源的核心方法给上锁，以此保证线程安全。 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。 同步方法底层原理 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。 如果方法是实例方法：同步方法默认用this作为的锁对象。 如果方法是静态方法：同步方法默认用类名.class作为的锁对象。 同步方法 123修饰符 synchronized 返回值类型 方法名称(形参列表) &#123;\t操作共享资源的代码&#125; 同步代码块好还是同步方法好？ 范围上：同步代码块锁的范围更小，同步方法锁的范围更大。（锁的范围越小，性能越好~） 可读性：同步方法更好。（计算机性能上去了，前一个差别不大~） 12345678910111213// 同步方法public synchronized void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); // 1、判断余额是否足够 if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125;&#125; 方式3：Lock锁 Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。 Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象。 构造器 public ReentrantLock()。获得Lock锁的实现类对象。 常用方法 void lock()。获得锁。 void unlock()。释放锁。 格式 1234561.首先在成员变量位子，需要创建一个Lock接口的实现类对象（这个对象就是锁对象）\tprivate final Lock lk = new ReentrantLock();2.在需要上锁的地方加入下面的代码 lk.lock(); // 加锁 //...中间是被锁住的代码... lk.unlock(); // 解锁 使用Lock锁改写前面DrawThread中取钱的方法 1234567891011121314151617181920212223// 创建了一个锁对象private final Lock lk = new ReentrantLock();public void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); try &#123; lk.lock(); // 加锁 // 1、判断余额是否足够 if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lk.unlock(); // 解锁 &#125; &#125;&#125; 记得用try-catch-finally来保证一定会解锁！ 线程通信[了解]当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺。 线程通信的常见模型（生产者与消费者模型） 生产者线程负责生产数据。 消费者线程负责消费生产者生产的数据。 注意：生产者生产完数据应该等待自己，通知消费者消费；消费者消费完数据也应该等待自己，再通知生产者生产！ Object类的等待和唤醒方法： void wait()。让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法。 void notify()。唤醒正在等待的单个线程。 void notifyAll()。唤醒正在等待的所有线程。 注意 上述方法应该使用当前同步锁对象进行调用。 分析一下完成这个案例的思路 12345678910111213141516171.先确定在这个案例中，什么是共享数据？\t答：这里案例中桌子是共享数据，因为厨师和顾客都需要对桌子上的包子进行操作。2.再确定有那几条线程？哪个是生产者，哪个是消费者？\t答：厨师是生产者线程，3条生产者线程； 顾客是消费者线程，2条消费者线程 3.什么时候将哪一个线程设置为什么状态\t生产者线程(厨师)放包子： 1)先判断是否有包子 2)没有包子时，厨师开始做包子, 做完之后把别人唤醒，然后让自己等待 3)有包子时，不做包子了，直接唤醒别人、然后让自己等待 消费者线程(顾客)吃包子： 1)先判断是否有包子 2)有包子时，顾客开始吃包子, 吃完之后把别人唤醒，然后让自己等待 3)没有包子时，不吃包子了，直接唤醒别人、然后让自己等待 先写桌子类，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Desk &#123; private List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 放1个包子的方法 // 厨师1 厨师2 厨师3 public synchronized void put() &#123; try &#123; String name = Thread.currentThread().getName(); // 判断是否有包子。 if(list.size() == 0)&#123; list.add(name + &quot;做的肉包子&quot;); System.out.println(name + &quot;做了一个肉包子~~&quot;); Thread.sleep(2000); // 唤醒别人, 等待自己 this.notifyAll(); this.wait(); &#125;else &#123; // 有包子了，不做了。 // 唤醒别人, 等待自己 this.notifyAll(); this.wait(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 吃货1 吃货2 public synchronized void get() &#123; try &#123; String name = Thread.currentThread().getName(); if(list.size() == 1)&#123; // 有包子，吃了 System.out.println(name + &quot;吃了：&quot; + list.get(0)); list.clear(); Thread.sleep(1000); this.notifyAll(); this.wait(); &#125;else &#123; // 没有包子 this.notifyAll(); this.wait(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再写测试类，在测试类中，创建3个厨师线程对象，再创建2个顾客对象，并启动所有线程 123456789101112131415161718192021222324252627282930313233343536373839public class ThreadTest &#123; public static void main(String[] args) &#123; // 需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上 // 2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。 Desk desk = new Desk(); // 创建3个生产者线程（3个厨师） new Thread(() -&gt; &#123; while (true) &#123; desk.put(); &#125; &#125;, &quot;厨师1&quot;).start(); new Thread(() -&gt; &#123; while (true) &#123; desk.put(); &#125; &#125;, &quot;厨师2&quot;).start(); new Thread(() -&gt; &#123; while (true) &#123; desk.put(); &#125; &#125;, &quot;厨师3&quot;).start(); // 创建2个消费者线程（2个吃货） new Thread(() -&gt; &#123; while (true) &#123; desk.get(); &#125; &#125;, &quot;吃货1&quot;).start(); new Thread(() -&gt; &#123; while (true) &#123; desk.get(); &#125; &#125;, &quot;吃货2&quot;).start(); &#125;&#125; 线程池认识线程池线程池就是一个可以复用线程的技术。 不使用线程池的问题 用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的， 而创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。 线程池：正在进行的称为工作线程WorkThread，等待执行的任务在任务队列（WorkQueue）。这些任务对象必须要实现Runnable或者Callable对象。 如何创建线程池？JDK 5.0起提供了代表线程池的接口：ExecutorService。 如何得到线程池对象? 方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象。 方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象。 ThreadPoolExecutor构造器【重要】1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数一：corePoolSize : 指定线程池的核心线程的数量。 参数二：maximumPoolSize：指定线程池的最大线程数量。（一般要大于corePoolSize，多出来的就是临时线程。） 参数三：keepAliveTime ：指定临时线程的存活时间。 参数四：unit：指定临时线程存活的时间单位(秒、分、时、天）。 参数五：workQueue：指定线程池的任务队列。 参数六：threadFactory：指定线程池的线程工厂。（负责创建线程。） 参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理）。 理解 用构造器创建线程池对象的代码 123456789ExecutorService pool = new ThreadPoolExecutor( 3,\t//核心线程数有3个 5, //最大线程数有5个。 临时线程数=最大线程数-核心线程数=5-3=2 8,\t//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。 TimeUnit.SECONDS,//时间单位（秒） new ArrayBlockingQueue&lt;&gt;(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待 Executors.defaultThreadFactory(), //用于创建线程的工厂对象 new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略); 注意事项核心线程–&gt;任务队列–&gt;临时线程–&gt;until占满最大线程–&gt;拒绝新任务。 (1)临时线程什么时候创建？ 新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。 (2)什么时候开始拒绝新的任务？ 核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。 程池执行的任务可以有2种： Runnable任务； callable任务。 线程池处理Runnable任务ExecutorService常用方法 void execute(Runnable command)。执行 Runnable 任务。 Future submit(Callable task)。执行 Callable 任务，返回未来任务对象，用于获取线程返回的结果。 void shutdown()。等全部任务执行完毕后，再关闭线程池！（关闭线程池的2种方法：1.点红方块停止，2.调用本方法。注意，执行了含有线程池的程序之后，线程池不停止是正常现象！） List shutdownNow()。立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务。 新任务拒绝策略（参数七：handler） ThreadPoolExecutor.AbortPolicy。丢弃任务并抛出。RejectedExecutionException异常。是默认的策略。 ThreadPoolExecutor.DiscardPolicy。丢弃任务，但是不抛出异常，这是不推荐的做法。 ThreadPoolExecutor.DiscardOldestPolicy。抛弃队列中等待最久的任务， 然后把当前任务加入队列中。 ThreadPoolExecutor.CallerRunsPolicy。由主线程负责调用任务的run()方法从而绕过线程池直接执行。 代码先准备一个线程任务类 12345678910111213public class MyRunnable implements Runnable&#123; @Override public void run() &#123; // 任务是干啥的？ System.out.println(Thread.currentThread().getName() + &quot; ==&gt; 输出666~~&quot;); //为了模拟线程一直在执行，这里睡久一点 try &#123; Thread.sleep(Integer.MAX_VALUE); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。 12345678910111213141516171819202122232425ExecutorService pool = new ThreadPoolExecutor( 3,\t//核心线程数有3个 5, //最大线程数有5个。 临时线程数=最大线程数-核心线程数=5-3=2 8,\t//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。 TimeUnit.SECONDS,//时间单位（秒） new ArrayBlockingQueue&lt;&gt;(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待 Executors.defaultThreadFactory(), //用于创建线程的工厂对象 new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略);Runnable target = new MyRunnable();pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！//下面4个任务在任务队列里排队pool.execute(target);pool.execute(target);pool.execute(target);pool.execute(target);//下面2个任务，会被临时线程的创建时机了pool.execute(target);pool.execute(target);// 到了新任务的拒绝时机了！pool.execute(target); 执行上面的代码，结果输出如下 线程池处理Callable任务Callable任务与Runnable任务最大的不同：执行完毕后可以返回结果。 上一小节提到的submit()方法。 先准备一个Callable线程任务 123456789101112131415161718public class MyCallable implements Callable&lt;String&gt; &#123; private int n; public MyCallable(int n) &#123; this.n = n; &#125; // 2、重写call方法 @Override public String call() throws Exception &#123; // 描述线程的任务，返回线程执行返回后的结果。 // 需求：求1-n的和返回。 int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; sum += i; &#125; return Thread.currentThread().getName() + &quot;求出了1-&quot; + n + &quot;的和是：&quot; + sum; &#125;&#125; 再准备一个测试类，在测试类中创建线程池，并执行callable任务。 12345678910111213141516171819202122232425public class ThreadPoolTest2 &#123; public static void main(String[] args) throws Exception &#123; // 1、通过ThreadPoolExecutor创建一个线程池对象。 ExecutorService pool = new ThreadPoolExecutor( 3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); // 2、使用线程处理Callable任务。 Future&lt;String&gt; f1 = pool.submit(new MyCallable(100)); Future&lt;String&gt; f2 = pool.submit(new MyCallable(200)); Future&lt;String&gt; f3 = pool.submit(new MyCallable(300)); Future&lt;String&gt; f4 = pool.submit(new MyCallable(400)); // 3、执行完Callable任务后，需要获取返回结果。 System.out.println(f1.get()); System.out.println(f2.get()); System.out.println(f3.get()); System.out.println(f4.get()); &#125;&#125; 执行后，结果如下图所示 说明线程2复用了。 Executors工具类实现线程池是一个线程池的工具类，提供了很多静态方法用于返回不同特点的线程池对象。 常用方法： public static ExecutorService newFixedThreadPool(int nThreads)。创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。 public static ExecutorService newSingleThreadExecutor()。创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。（不会死掉！） public static ExecutorService newCachedThreadPool()。线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)。创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。 注意 ：这些方法的底层，都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象。 【核心线程数量配置多少？】行业通用—&gt; 计算密集型的任务：核心线程数量 &#x3D; CPU核数 + 1； IO密集型的任务：核心线程数量 &#x3D; CPU核数 * 2； 【Executors使用可能存在的陷阱】 大型并发系统环境中使用Executors如果不注意可能会出现系统风险。（小的系统也最好不要用，容易留安全隐患。） 其他细节知识：并发、并行进程 正在运行的程序（软件）就是一个独立的进程。 线程是属于进程的，一个进程中可以同时运行很多个线程。 进程中的多个线程其实是并发和并行执行的。 并发 进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。 并行 在同一个时刻上，同时有多个线程在被CPU调度执行。 【多线程到底是怎么执行的？】 并发和并行同时进行的！ 并发：CPU分时轮询的执行线程。 并行：同一个时刻同时在执行。 其他细节知识：线程的生命周期线程的生命周期 也就是线程从生到死的过程中，经历的各种状态及状态转换。 理解线程这些状态有利于提升并发编程的理解能力。 Java线程的状态 Java总共定义了6种状态。 6种状态都定义在Thread类的内部枚举类中。(Thread.State可以调出来。) 123456789101112public class Thread&#123; ... public enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; &#125; ...&#125; 线程状态 说明 NEW(新建) 线程刚被创建，但是并未启动。 Runnable(可运行) 线程已经调用了start()，等待CPU调度 Blocked(锁阻塞) 线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态；。 Waiting(无限等待) 一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒 Timed Waiting(计时等待) 同waiting状态，有几个方法（sleep,wait）有超时参数，调用他们将进入Timed Waiting状态。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 线程的6种状态互相转换"},{"title":"【Java基础】【java.net】网络编程","path":"/2024/04/09/【Java基础】【java.net】网络编程/","content":"网络编程概述基本的通信架构基本的通信架构有2种形式：CS架构（ Client客户端&#x2F;Server服务端 ） 、 BS架构(Browser浏览器&#x2F;Server服务端)。 无论是CS架构，还是BS架构的软件都必须依赖网络编程！ CS架构例如微信、IDEA。 Client客户端 需要程序员开发。 用户需要安装。 Server服务端 需要程序员开发实现。 BS架构例如浏览器、网页。 Browser浏览器 不需要程序员开发实现。 用户需要安装浏览器。 Server服务端 需要程序员开发实现。 网络编程三要素 IP地址：设备在网络中的地址，是唯一的标识。 端口号：应用程序在设备中唯一的标识。 协议：连接和数据在网络中传输的规则。 IP地址设备在网络中的地址，是唯一的标识。 IP（Internet Protocol）：全称“互联网协议地址”，是分配给上网设备的唯一标志。 IP地址有两种形式：IPv4、IPv6。 IPv4地址是用32bit(4Bytes)来表示，分成4段表示，使用点分十进制表示法来表示。 IPv6地址是用共128bit来表示，分成8段表示，使用冒分十六进制表示法来表示。即，每段每四位编码成一个十六进制位表示， 数之间用冒号（:）分开。 IP域名： 例如，https://www.baidu.com/。本机先去DNS服务器查，查到ip地址并返回，如果查不到，就去运营商服务器那里去查。 公网IP、内网IP： 公网IP：是可以连接互联网的IP地址；内网IP：也叫局域网IP，只能组织机构内部使用。 192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。 特殊IP地址： 127.0.0.1、localhost：代表本机IP，只会寻找当前所在的主机。 IP常用命令： ipconfig：查看本机IP地址。 ping IP地址：检查网络是否连通。 在Java中的代表类： 代表IP地址。 InetAddress的常用方法： public static InetAddress getLocalHost()。获取本机IP，会以一个InetAddress的对象返回。 public static InetAddress getByName(String host)。根据ip地址或者域名，返回一个InetAdress对象。 public String getHostName()。获取该ip地址对象对应的主机名。 public String getHostAddress()。获取该ip地址对象中的ip地址信息。 public boolean isReachable(int timeout)。在指定毫秒内，判断主机与该ip对应的主机是否能连通。 12345678910111213141516public class InetAddressTest &#123; public static void main(String[] args) throws Exception &#123; // 1、获取本机IP地址对象的 InetAddress ip1 = InetAddress.getLocalHost(); System.out.println(ip1.getHostName()); System.out.println(ip1.getHostAddress()); // 2、获取指定IP或者域名的IP地址对象。 InetAddress ip2 = InetAddress.getByName(&quot;www.baidu.com&quot;); System.out.println(ip2.getHostName()); System.out.println(ip2.getHostAddress()); // ping www.baidu.com System.out.println(ip2.isReachable(6000)); &#125;&#125; 端口号应用程序在设备中唯一的标识。标记正在计算机设备上运行的应用程序的，被规定为一个 16 位的二进制，范围是 0~65535。 分类 周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） 注册端口：1024~49151，分配给用户进程或某些应用程序。（注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。） 动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。 协议连接和数据在网络中传输的规则。网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议。（为了让全球所有的上网设备都能够互联。） 开放式网络互联标准：OSI网络参考模型 OSI网络参考模型：全球网络互联标准。 TCP&#x2F;IP网络模型：事实上的国际标准。 传输层的2个通信协议 UDP(User Datagram Protocol)：用户数据报协议。 TCP(Transmission Control Protocol)：传输控制协议。 UDP协议 特点：无连接、不可靠通信。 不事先建立连接，数据按照包发，一包数据包含：自己的IP、程序端口，目的地IP、程序端口和数据（限制在64KB内）等。 发送方不管对方是否在线，数据在中间丢失也不管，如果接收方收到数据也不返回确认，故是不可靠的 。（但是通信效率高，用于语音通话、视频直播。） TCP协议 特点：面向连接、可靠通信。 TCP的最终目的：要保证在不可靠的信道上实现可靠的传输。 TCP主要有三个步骤实现可靠传输：三次握手建立连接，传输数据进行确认，四次挥手断开连接。（通信效率相对不高，用于网页、文件下载、支付。） 可以进行大数据量的传输。 TCP协议：三次握手建立可靠连接 可靠连接：确定通信双方，收发消息都是正常无问题的！（全双工） 传输数据会进行确认，以保证数据传输的可靠性。 TCP协议：四次握手断开连接 目的：确保双方数据的收发都已经完成！ UDP通信代码（入门案例） 特点：无连接、不可靠通信。 不事先建立连接；发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。（类似于拿盘子扔韭菜……） Java提供了一个java.net.DatagramSocket类来实现UDP通信。 DatagramSocket: 用于创建客户端、服务端构造器 public DatagramSocket()。创建客户端的Socket对象, 系统会随机分配一个端口号。 public DatagramSocket(int port)。创建服务端的Socket对象, 并指定端口号。 方法 public void send(DatagramPacket dp)。发送数据包。 public void receive(DatagramPacket p)。使用数据包接收数据。 DatagramPacket：创建数据包构造器 public DatagramPacket(byte[] buf, int length, InetAddress address, int port)。创建发出去的数据包对象。 public DatagramPacket(byte[] buf, int length)。创建用来接收数据的数据包。 方法 public int getLength()。获取数据包，实际接收到的字节个数。 使用UDP通信实现：发送消息、接收消息客户端实现步骤 创建DatagramSocket对象（客户端对象） –&gt; 扔韭菜的人。 创建DatagramPacket对象封装需要发送的数据（数据包对象） –&gt; 韭菜盘子。 使用DatagramSocket对象的send方法，传入DatagramPacket对象 –&gt; 开始抛出韭菜。 释放资源。 123456789101112131415161718192021222324252627/** * 目标：完成UDP通信快速入门：实现1发1收。 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建客户端对象（发韭菜出去的人） DatagramSocket socket = new DatagramSocket(7777); // 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子） /* public DatagramPacket(byte buf[], int length, InetAddress address, int port) 参数一：封装要发出去的数据。 参数二：发送出去的数据大小（字节个数） 参数三：服务端的IP地址（找到服务端主机） 参数四：服务端程序的端口。 */ byte[] bytes = &quot;我是快乐的客户端，我爱你abc&quot;.getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 3、开始正式发送这个数据包的数据出去了 socket.send(packet); System.out.println(&quot;客户端数据发送完毕~~~&quot;); socket.close(); // 释放资源！ &#125;&#125; 服务端实现步骤 创建DatagramSocket对象并指定端口（服务端对象） –&gt; 接韭菜的人。 创建DatagramPacket对象接收数据（数据包对象） –&gt; 韭菜盘子。 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 –&gt; 开始接收韭菜。 释放资源。 123456789101112131415161718192021222324252627public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;----服务端启动----&quot;); // 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口 DatagramSocket socket = new DatagramSocket(6666); // 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子） byte[] buffer = new byte[1024 * 64]; // 64KB. DatagramPacket packet = new DatagramPacket(buffer, buffer.length); // 3、开始正式使用数据包来接收客户端发来的数据 socket.receive(packet); // 4、从字节数组中，把接收到的数据直接打印出来 // 接收多少就倒出多少 // 获取本次数据包接收了多少数据。 int len = packet.getLength(); String rs = new String(buffer, 0 , len); System.out.println(rs); System.out.println(packet.getAddress().getHostAddress()); System.out.println(packet.getPort()); socket.close(); // 释放资源 &#125;&#125; UDP通信代码（多发多收）客户端可以反复发送数据 客户端实现步骤 创建DatagramSocket对象（发送端对象） –&gt; 扔韭菜的人。 使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序。 如果用户输入的不是exit, 把数据封装成DatagramPacket –&gt; 韭菜盘子。 使用DatagramSocket对象的send方法将数据包对象进行发送 –&gt; 开始抛出韭菜。 释放资源。 12345678910111213141516171819202122232425262728293031323334353637/** * 目标：完成UDP通信快速入门：实现客户端反复的发。 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建客户端对象（发韭菜出去的人） DatagramSocket socket = new DatagramSocket(); // 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子） /* public DatagramPacket(byte buf[], int length, InetAddress address, int port) 参数一：封装要发出去的数据。 参数二：发送出去的数据大小（字节个数） 参数三：服务端的IP地址（找到服务端主机） 参数四：服务端程序的端口。 */ Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(&quot;请说：&quot;); String msg = sc.nextLine(); // 一旦发现用户输入的exit命令，就退出客户端 if(&quot;exit&quot;.equals(msg))&#123; System.out.println(&quot;欢迎下次光临！退出成功！&quot;); socket.close(); // 释放资源 break; // 跳出死循环 &#125; byte[] bytes = msg.getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 3、开始正式发送这个数据包的数据出去了 socket.send(packet); &#125; &#125;&#125; 服务端实现步骤 创建DatagramSocket对象并指定端口（接收端对象）–&gt; 接韭菜的人。 创建DatagramPacket对象接收数据（数据包对象） –&gt; 韭菜盘子。 使用DatagramSocket对象的receive方法传入DatagramPacket对象。 使用while死循环不断的进行第3步。 12345678910111213141516171819202122232425262728293031/** * 目标：完成UDP通信快速入门-服务端反复的收 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;----服务端启动----&quot;); // 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口 DatagramSocket socket = new DatagramSocket(6666); // 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子） byte[] buffer = new byte[1024 * 64]; // 64KB. DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while (true) &#123; // 3、开始正式使用数据包来接收客户端发来的数据 socket.receive(packet); // 4、从字节数组中，把接收到的数据直接打印出来 // 接收多少就倒出多少 // 获取本次数据包接收了多少数据。 int len = packet.getLength(); String rs = new String(buffer, 0 , len); System.out.println(rs); System.out.println(packet.getAddress().getHostAddress()); System.out.println(packet.getPort()); System.out.println(&quot;--------------------------------------&quot;); &#125; &#125;&#125; 提问：UDP的接收端为什么可以接收很多发送端的消息？ 接收端只负责接收数据包，无所谓是哪个发送端的数据包。 TCP通信（一发一收） 特点：面向连接、可靠通信。 通信双方事先会采用“三次握手”方式建立可靠连接，实现端到端的通信；底层能保证数据成功传给服务端。 Java提供了一个java.net.Socket类来实现TCP通信。 TCP通信之-客户端开发 客户端程序就是通过java.net包下的Socket类来实现的。 构造器 public Socket(String host , int port)。根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket。 常用方法 public OutputStream getOutputStream()。获得字节输出流对象。（发） public InputStream getInputStream()。获得字节输入流对象。（收） 客户端发送消息 创建客户端的Socket对象，请求与服务端的连接。 使用socket对象调用getOutputStream()方法得到字节输出流。（注意用的是字节流，所以使用的时候可能需要包装一下。） 使用字节输出流完成数据的发送。 释放资源：关闭socket管道。 123456789101112131415161718192021/** * 目标：完成TCP通信快速入门-客户端开发：实现1发1收。 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建Socket对象，并同时请求与服务端程序的连接。 Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); // 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。 OutputStream os = socket.getOutputStream(); // 3、把低级的字节输出流包装成数据输出流 DataOutputStream dos = new DataOutputStream(os); // 4、开始写数据出去了 dos.writeUTF(&quot;在一起，好吗？&quot;); dos.close(); socket.close(); // 释放连接资源 &#125;&#125; TCP通信-服务端程序的开发 服务端是通过java.net包下的ServerSocket类来实现的。 构造器 public ServerSocket(int port)。为服务端程序注册端口。 常用方法 public Socket accept()。阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。 实现步骤 创建ServerSocket对象，注册服务端端口。 调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。 通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。 释放资源：关闭socket管道。 12345678910111213141516171819202122232425262728/** * 目标：完成TCP通信快速入门-服务端开发：实现1发1收。 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、从socket通信管道中得到一个字节输入流。 InputStream is = socket.getInputStream(); // 4、把原始的字节输入流包装成数据输入流 DataInputStream dis = new DataInputStream(is); // 5、使用数据输入流读取客户端发送过来的消息 String rs = dis.readUTF(); System.out.println(rs); // 其实我们也可以获取客户端的IP地址 System.out.println(socket.getRemoteSocketAddress()); dis.close(); socket.close(); &#125;&#125; TCP通信（多发多收） 客户端使用死循环，让用户不断输入消息。 123456789101112131415161718192021222324252627282930313233/** * 目标：完成TCP通信快速入门-客户端开发：实现客户端可以反复的发消息出去 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建Socket对象，并同时请求与服务端程序的连接。 Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); // 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。 OutputStream os = socket.getOutputStream(); // 3、把低级的字节输出流包装成数据输出流 DataOutputStream dos = new DataOutputStream(os); Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(&quot;请说：&quot;); String msg = sc.nextLine(); // 一旦用户输入了exit，就退出客户端程序 if(&quot;exit&quot;.equals(msg))&#123; System.out.println(&quot;欢迎您下次光临！退出成功！&quot;); dos.close(); socket.close(); break; &#125; // 4、开始写数据出去了 dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; 服务端也使用死循环，控制服务端收完消息，继续等待接收下一个消息。 1234567891011121314151617181920212223242526272829303132/** * 目标：完成TCP通信快速入门-服务端开发：实现服务端反复发消息 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、从socket通信管道中得到一个字节输入流。 InputStream is = socket.getInputStream(); // 4、把原始的字节输入流包装成数据输入流 DataInputStream dis = new DataInputStream(is); while (true) &#123; try &#123; // 5、使用数据输入流读取客户端发送过来的消息 String rs = dis.readUTF(); System.out.println(rs); &#125; catch (Exception e) &#123; System.out.println(socket.getRemoteSocketAddress() + &quot;离线了！&quot;); dis.close(); socket.close(); break; &#125; &#125; &#125;&#125; TCP通信（多线程改进）目前我们开发的服务端程序，可否支持与多个客户端同时通信 ？ 不可以的。因为服务端现在只有一个主线程，只能处理一个客户端的消息。 本次是如何实现服务端同时接收多个客户端的消息的？ 主线程定义了循环负责接收客户端Socket管道连接。 每接收到一个Socket通信管道后分配一个独立的线程负责处理它。 首先，我们需要写一个服务端的读取数据的线程类，代码如下 123456789101112131415161718192021222324252627public class ServerReaderThread extends Thread&#123; private Socket socket; public ServerReaderThread(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true)&#123; try &#123; String msg = dis.readUTF(); System.out.println(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;有人下线了：&quot; + socket.getRemoteSocketAddress()); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 接下来，再改写服务端的主程序代码，如下： 1234567891011121314151617181920/** * 目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); while (true) &#123; // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress()); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 new ServerReaderThread(socket).start(); &#125; &#125;&#125; 拓展案例-【群聊的实现】-思路 客户端和客户端是不能直接通信的。全群聊的效果必须要有服务端在中间做中转。 客户端 —&gt; 服务端。 客户端 —&gt; 多个客户端。 是指一个客户端把消息发出去，其他在线的全部客户端都可以收到消息。 需要用到端口转发的设计思想。 服务端需要把在线的Socket管道存储起来，一旦收到一个消息要推送给其他管道。 可以在服务端创建一个存储Socket的集合，每当一个客户端连接服务端，就可以把客户端Socket存储起来；当一个客户端给服务端发消息时，再遍历集合通过每个Socket将消息再转发给其他客户端。 然后改造服务端代码 由于服务端读取数据是在线程类中完成的，所以我们改SerReaderThread类就可以了。服务端的主程序不用改。 123456789101112131415161718192021222324252627282930313233343536373839public class ServerReaderThread extends Thread&#123; private Socket socket; public ServerReaderThread(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true)&#123; try &#123; String msg = dis.readUTF(); System.out.println(msg); // 把这个消息分发给全部客户端进行接收。 sendMsgToAll(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;有人下线了：&quot; + socket.getRemoteSocketAddress()); Server.onLineSockets.remove(socket); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void sendMsgToAll(String msg) throws IOException &#123; // 发送给全部在线的socket管道接收。 for (Socket onLineSocket : Server.onLineSockets) &#123; OutputStream os = onLineSocket.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; BS架构程序（简易版）案例： 要求从浏览器中访问服务器，并立即让服务器响应一个很简单的网页给浏览器展示，网页内容就是“黑马程序员666”。 BS架构的基本原理 客户端使用浏览器发起请求（不需要开发客户端）。 注意：服务器必须给浏览器响应HTTP协议规定的数据格式，否则浏览器不识别返回的数据。 http:&#x2F;&#x2F;服务器IP:服务器端口，例如，http://127.0.0.1:8080。 HTTP协议规定 必须满足如下形式： 注意：数据是由多行组成的，必须按照规定的格式来写。 先写一个线程类，用于按照HTTP协议的格式返回数据 12345678910111213141516171819202122public class ServerReaderThread extends Thread&#123; private Socket socket; public ServerReaderThread(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; // 立即响应一个网页内容：“黑马程序员”给浏览器展示。 try &#123; OutputStream os = socket.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;HTTP/1.1 200 OK&quot;); ps.println(&quot;Content-Type:text/html;charset=UTF-8&quot;); ps.println(); // 必须换行 ps.println(&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;); ps.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再写服务端的主程序 1234567891011121314151617181920/** * 目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8080); while (true) &#123; // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress()); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 new ServerReaderThread(socket).start(); &#125; &#125;&#125; 拓展 每次请求都开一个新线程，到底好不好？ 高并发时，容易宕机！ 可以使用线程池进行优化。 为了避免服务端创建太多的线程，可以把服务端用线程池改进，提高服务端的性能。 先写一个给浏览器响应数据的线程任务 12345678910111213141516171819202122public class ServerReaderRunnable implements Runnable&#123; private Socket socket; public ServerReaderRunnable(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; // 立即响应一个网页内容：“黑马程序员”给浏览器展示。 try &#123; OutputStream os = socket.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;HTTP/1.1 200 OK&quot;); ps.println(&quot;Content-Type:text/html;charset=UTF-8&quot;); ps.println(); // 必须换行 ps.println(&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;); ps.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再改写服务端的主程序，使用ThreadPoolExecutor创建一个线程池，每次接收到一个Socket就往线程池中提交任务就行。 1234567891011121314151617181920public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8080); // 创建出一个线程池，负责处理通信管道的任务。 ThreadPoolExecutor pool = new ThreadPoolExecutor(16 * 2, 16 * 2, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(8) , Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); while (true) &#123; // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 pool.execute(new ServerReaderRunnable(socket)); &#125; &#125;&#125;"},{"title":"【LeeCode】刷题记录.md","path":"/2024/04/08/【LeeCode】刷题记录/","content":"作者：力扣官方题解 来源：力扣（LeetCode） LeeCode热题10049、字母异位词分组（中）https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/ 题面给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 为什么是哈希表相关的题？ 思路： 当把单词中所有字母按照字母顺序表排列时，字母异位词的排序后的单词是相同的。 可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词。 哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。 具体做法：遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。 方法1：字母排序 构造单词的字符排序，作为键。 将单词加入散列表。 返回答案。 1234567891011121314class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; char[] array = str.toCharArray(); Arrays.sort(array); String key = new String(array); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 复习 char[] toCharArray() 。将此字符串转换为新的字符数组。 getOrDefault。HashMap的一个方法，返回指定键映射到的值，如果此映射不包含键的映射，则返回 defaultValue 。 向list中新增元素用add方法。 向哈希表中新增元素用put方法，同时传入键和值。 复杂度分析 方法2：计数 互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。 字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。 首先统计字符的出现顺序，然后构造键，把具有相通特征的字符串的单词们放在一组，最后返回结果。 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; int[] counts = new int[26]; int length = str.length(); for (int i = 0; i &lt; length; i++) &#123; counts[str.charAt(i) - &#x27;a&#x27;]++; &#125; // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); //可变字符串对象 for (int i = 0; i &lt; 26; i++) &#123; if (counts[i] != 0) &#123; sb.append((char) (&#x27;a&#x27; + i)); sb.append(counts[i]); &#125; &#125; String key = sb.toString(); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 复杂度分析 面试要点 通过分析，能否意识到单词和键的映射关系。 利用散列表高效储存结果。 数据结构和常见的库函数。"},{"title":"【Java基础】特殊文本文件、日志技术","path":"/2024/04/08/【Java基础】特殊文本文件、日志技术/","content":"特殊文件概述认识 普通文件.txt。 属性文件.properties。 XML文件.xml。 为什么要用特殊文件？ 存储多个用户的用户名和密码，txt不可以解析，但是properties、xml可以。 存储多个用户的用户名、密码、家乡和性别，txt、properties不可以解析，xml可以。 可以存储有关系的数据，作为系统的配置文件，作为信息进行传输。 我们主要学什么？ 了解它们的特点、作用。 学习使用程序读取它们里面的数据。 学习使用程序把数据存储到这些文件里。（用得不多。） 日志技术把程序运行的信息，记录到文件中，方便程序员定位bug、并了解程序的执行情况等。 特殊文件：properties属性文件 是一个Map集合（键值对集合），但是我们一般不会当集合使用。 核心作用：Properties是用来代表属性文件的，通过Properties可以读写属性文件里的键值对。 （读）构造器 public Properties()。用于构建Properties集合对象（空容器）。 （读）常用方法 public void load(InputStream is)。通过字节输入流，读取属性文件里的键值对数据。 public void load(Reader reader)。通过字符输入流，读取属性文件里的键值对数据。 public String getProperty(String key)。根据键获取值(其实就是get方法的效果)。 public Set stringPropertyNames()。获取全部键的集合（其实就是ketSet方法的效果）。 读取步骤 1231、创建一个Properties的对象出来（键值对集合，空容器）2、调用load(字符输入流/字节输入流)方法，开始加载属性文件中的键值对数据到properties对象中去3、调用getProperty(键)方法，根据键取值 代码 12345678910111213141516171819202122232425262728293031/** * 目标：掌握使用Properties类读取属性文件中的键值对信息。 */public class PropertiesTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个Properties的对象出来（键值对集合，空容器） Properties properties = new Properties(); System.out.println(properties); // 2、开始加载属性文件中的键值对数据到properties对象中去 properties.load(new FileReader(&quot;properties-xml-log-app\\\\src\\\\users.properties&quot;)); System.out.println(properties); // 3、根据键取值 System.out.println(properties.getProperty(&quot;赵敏&quot;)); System.out.println(properties.getProperty(&quot;张无忌&quot;)); // 4、遍历全部的键和值。 //获取键的集合 Set&lt;String&gt; keys = properties.stringPropertyNames(); for (String key : keys) &#123; //再根据键获取值 String value = properties.getProperty(key); System.out.println(key + &quot;----&gt;&quot; + value); &#125; properties.forEach((k, v) -&gt; &#123; System.out.println(k + &quot;----&gt;&quot; + v); &#125;); &#125;&#125; （写）构造器 public Properties()。用于构建Properties集合对象（空容器）。 （写）常用方法 public Object setProperty(String key, String value)。保存键值对数据到Properties对象中去。 public void store(OutputStream os, String comments)。把键值对数据，通过字节输出流写出到属性文件里去。注意这里需要写评论信息。 public void store(Writer w, String comments)。把键值对数据，通过字符输出流写出到属性文件里去。 步骤 123451、先准备一个.properties属性文件，按照格式写几个键值对1、创建Properties对象出来，2、调用setProperty存储一些键值对数据3、调用store(字符输出流/字节输出流, 注释)，将Properties集合中的键和值写到文件中\t注意：第二个参数是注释，必须得加； 代码 1234567891011121314public class PropertiesTest2 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建Properties对象出来，先用它存储一些键值对数据 Properties properties = new Properties(); properties.setProperty(&quot;张无忌&quot;, &quot;minmin&quot;); properties.setProperty(&quot;殷素素&quot;, &quot;cuishan&quot;); properties.setProperty(&quot;张翠山&quot;, &quot;susu&quot;); // 2、把properties对象中的键值对数据存入到属性文件中去 properties.store(new FileWriter(&quot;properties-xml-log-app/src/users2.properties&quot;) , &quot;i saved many users!&quot;); &#125;&#125; 特殊文件：XML文件概述是什么？ XML（ 全称EXtensible Markup Language， 可扩展标记语言 ）。 本质是一种数据的格式，可以用来存储复杂的数据结构，和数据关系。 特点 XML中的“&lt;标签名&gt;” 称为一个标签或一个元素，一般是成对出现的。 XML中的标签名可以自己定义（可扩展），但必须要正确的嵌套。 XML中只能有一个根标签。 XML中的标签可以有属性。 如果一个文件中放置的是XML格式的数据，这个文件就是XML文件，后缀一般要写成**.xml**。 XML的创建 就是创建一个XML类型的文件，要求文件的后缀必须使用xml，如hello_world.xml。 语法规则 (1)XML文件的后缀名为：xml，文档声明（抬头）必须是第一行。 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &gt; //自动 version：XML默认的版本号码、该属性是必须存在 encoding：本XML文件的编码 (2)XML中可以定义注释信息： (3)根标签有且只能有一个。下面可以写子标签，子标签里面可以存属性，例如id&#x3D;”1”。再往下可以继续写子标签。 (4)标签必须承成对出现，又开始有结束： 。 (5)必须能够正确的嵌套。 XML中书写“&lt;”、“&amp;”等，可能会出现冲突，导致报错，此时可以用如下特殊字符替代。注意，XML可以在浏览器中直接渲染，在IDEA里面右键-open in expolrer（将这些特殊字符转换完成）。 123456&amp;lt; &lt; 小于&amp;gt; &gt; 大于&amp;amp; &amp; 和号&amp;apos; &#x27; 单引号&amp;quot; &quot; 引号例如：&lt;data&gt; 3 &amp;lt; 2 &amp;amp;&amp;amp; 5 &amp;gt; 4 &lt;/data&gt; XML中可以写一个叫CDATA的特殊数据区: ，里面的内容可以随便写。 12345&lt;data1&gt; &lt;![CDATA[ 3 &lt; 2 &amp;&amp; 5 &gt; 4 ]]&gt;&lt;/data1&gt; 例子 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;&lt;!-- 根标签只能有一个 --&gt;&lt;users&gt; &lt;user id=&quot;1&quot; desc=&quot;第一个用户&quot;&gt; &lt;name&gt;张无忌&lt;/name&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;地址&gt;光明顶&lt;/地址&gt; &lt;password&gt;minmin&lt;/password&gt; &lt;/user&gt; &lt;people&gt;很多人&lt;/people&gt; &lt;user id=&quot;2&quot;&gt; &lt;name&gt;敏敏&lt;/name&gt; &lt;sex&gt;女&lt;/sex&gt; &lt;地址&gt;光明顶&lt;/地址&gt; &lt;password&gt;wuji&lt;/password&gt; &lt;/user&gt;&lt;/users&gt; 作用和应用场景 本质是一种数据格式，可以存储复杂的数据结构，和数据关系。 应用场景：经常用来做为系统的配置文件；或者作为一种特殊的数据结构，在网络中进行传输（现在用得不多但是也能作为一种方案）。 读取XML文件中的数据又叫，解析XML文件。使用程序读取XML文件中的数据。 注意：程序员并不需要自己写原始的IO流代码来解析XML，难度较大！也相当繁琐！ 其实，有很多开源的，好用的，解析XML的框架，最知名的是：Dom4j(第三方研发的)。 Dom4j下载 下载Dom4j框架，官网下载。 在项目中创建一个文件夹：lib。 将dom4j-2.1.3.jar文件复制到 lib 文件夹。 在jar文件上点右键，选择 Add as Library -&gt; 点击OK。 在类中导包使用。 DOM4J解析XML文件的思想：文档对象模型思想 首先用SAXReader解析器把文件内容一下子加载到内存中，变成一个Document（整个文档）对象。 通过Document对象就可以获取Element对象：元素（标签）。 Element又可以获取Attribute：属性、子元素、文本。 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;users&gt;\t&lt;user id=&quot;1&quot;&gt; &lt;name&gt;张无忌&lt;/name&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;地址&gt;光明顶&lt;/地址&gt; &lt;password&gt;minmin&lt;/password&gt; &lt;data&gt; 3 &amp;lt; 2 &amp;amp;&amp;amp; 5 &gt; 4 &lt;/data&gt; &lt;data1&gt; &lt;![CDATA[ 3 &lt; 2 &amp;&amp; 5 &gt; 4 ]]&gt; &lt;/data1&gt;&lt;/user&gt;\t&lt;user id=&quot;2&quot;&gt; &lt;name&gt;敏敏&lt;/name&gt; &lt;sex&gt;女&lt;/sex&gt; &lt;地址&gt;光明顶&lt;/地址&gt; &lt;password&gt;wuji&lt;/password&gt; &lt;data&gt; 3 &amp;lt; 2 &amp;amp;&amp;amp; 5 &gt; 4 &lt;/data&gt; &lt;data1&gt; &lt;![CDATA[ 3 &lt; 2 &amp;&amp; 5 &gt; 4 ]]&gt; &lt;/data1&gt; &lt;/user&gt;&lt;/users&gt; 构造器 public SAXReader()。构建Dom4J的解析器对象。Dom4j提供的解析器，可以认为是代表整个Dom4j框架。 public Document read(String url)。把XML文件读成Document对象。 public Document read(InputStream is)。通过字节输入流读取XML文件。 常用方法 Element getRootElement()。获得根元素对象。 1234567891011121314public class Dom4JTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个Dom4J框架提供的解析器对象 SAXReader saxReader = new SAXReader(); // 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。 Document document = saxReader.read(&quot;properties-xml-log-app\\\\src\\\\helloworld.xml&quot;); // 3、从文档对象中解析XML文件的全部数据了 Element root = document.getRootElement();\t//获取了根元素 System.out.println(root.getName()); &#125;&#125; Element提供的方法注意，只能从根元素一级一级向下解析。 public String getName()。得到元素名字。 public List elements()。得到当前元素下所有子元素。 public List elements(String name)。得到当前元素下指定名字的子元素返回集合。 public Element element(String name)。得到当前元素下指定名字的子元素，如果有很多名字相同的返回第一个。 public String attributeValue(String name)。通过属性名直接得到属性值。 public String elementText(子元素名)。得到指定名称的子元素的文本。 public String getText()。得到文本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Dom4JTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个Dom4J框架提供的解析器对象 SAXReader saxReader = new SAXReader(); // 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。 Document document = saxReader.read(&quot;properties-xml-log-app\\\\src\\\\helloworld.xml&quot;); // 3、从文档对象中解析XML文件的全部数据了 Element root = document.getRootElement(); System.out.println(root.getName()); // 4、获取根元素下的全部一级子元素。 // List&lt;Element&gt; elements = root.elements(); List&lt;Element&gt; elements = root.elements(&quot;user&quot;); for (Element element : elements) &#123; System.out.println(element.getName()); &#125; // 5、获取当前元素下的某个子元素。 Element people = root.element(&quot;people&quot;); System.out.println(people.getText()); // 如果下面有很多子元素user，默认获取第一个。 Element user = root.element(&quot;user&quot;); System.out.println(user.elementText(&quot;name&quot;)); // 6、获取元素的属性信息呢？ System.out.println(user.attributeValue(&quot;id&quot;)); Attribute id = user.attribute(&quot;id&quot;); System.out.println(id.getName()); System.out.println(id.getValue()); List&lt;Attribute&gt; attributes = user.attributes(); for (Attribute attribute : attributes) &#123; System.out.println(attribute.getName() + &quot;=&quot; + attribute.getValue()); &#125; // 7、如何获取全部的文本内容:获取当前元素下的子元素文本值 System.out.println(user.elementText(&quot;name&quot;)); System.out.println(user.elementText(&quot;地址&quot;)); System.out.println(user.elementTextTrim(&quot;地址&quot;)); // 取出文本去除前后空格 System.out.println(user.elementText(&quot;password&quot;)); Element data = user.element(&quot;data&quot;); System.out.println(data.getText()); System.out.println(data.getTextTrim()); // 取出文本去除前后空格 &#125;&#125; 如何往XML文件中写入数据？ DOM4J也提供了往XML文件中写标签的方法，但是用起来比较麻烦，不好维护。这里不建议使用。 我们自己使用StringBuilder按照标签的格式拼接，然后再使用BufferedWriter写到XML文件中去就可以了。更加灵活。 1234567891011121314151617181920public class Dom4JTest2 &#123; public static void main(String[] args) &#123; // 1、使用一个StringBuilder对象来拼接XML格式的数据。 StringBuilder sb = new StringBuilder(); sb.append(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot; ?&gt;\\r &quot;); sb.append(&quot;&lt;book&gt;\\r &quot;); sb.append(&quot;\\t&lt;name&gt;&quot;).append(&quot;从入门到跑路&quot;).append(&quot;&lt;/name&gt;\\r &quot;); sb.append(&quot;\\t&lt;author&gt;&quot;).append(&quot;dlei&quot;).append(&quot;&lt;/author&gt;\\r &quot;); sb.append(&quot;\\t&lt;price&gt;&quot;).append(999.99).append(&quot;&lt;/price&gt;\\r &quot;); sb.append(&quot;&lt;/book&gt;&quot;); try ( BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;properties-xml-log-app/src/book.xml&quot;)); )&#123; bw.write(sb.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 补充知识：约束XML文件的编写[了解]限制XML文件中的标签或者属性，只能按照规定的格式写。 专门用来限制xml书写格式的文档，比如：限制标签、属性应该怎么写。有两种约束技术： DTD约束文档。（不能够约束具体的数据类型。） Schame约束文档。（能够约束具体的数据类型。） 案例：利用DTD约束文档，约束一个XML文件的编写。（了解） 1231.编写DTD约束文档，后缀必须是.dtd2.在需要编写的XML文件中导入该DTD约束文档（&lt;!DOCTYPE 书架 SYSTEM &quot;data.dtd&quot;&gt;）3.然后XML文件，就必须按照DTD约束文档指定的格式进行编写，否则报错！ 代码（了解） 12345&lt;!ELEMENT 书架 (书+)&gt;&lt;!ELEMENT 书 (书名,作者,售价)&gt;&lt;!ELEMENT 书名 (#PCDATA)&gt;&lt;!ELEMENT 作者 (#PCDATA)&gt;&lt;!ELEMENT 售价 (#PCDATA)&gt; 案例：利用schema约束文档，约束一个XML文件的编写。（了解） 步骤（了解） 1231.编写schema约束文档，后缀必须是.xsd，具体的形式到代码中观看。2.在需要编写的XML文件中导入该schema约束文档3.按照约束内容编写XML文件的标签。 日志技术概述场景引入 希望系统能记住某些数据是被谁操作的，比如被谁删除了？ 想分析用户浏览系统的具体情况，以便挖掘用户的具体喜好？ 当系统在开发中或者上线后出现了bug，崩溃了，该通过什么去分析、定位bug？ 日志 好比生活中的日记，可以记录你生活中的点点滴滴。 程序中的日志，通常就是一个文件，里面记录的是程序运行过程中的各种信息。 输出语句的弊端 日志会展示在控制台。 不能更方便的将日志记录到其他的位置（文件，数据库）。 想取消日志，需要修改源代码才可以完成。 日志技术 可以将系统执行的信息，方便的记录到指定的位置（控制台、文件中、数据库中）。 可以随时以开关的形式控制日志的启停，无需侵入到源代码中去进行修改。 输出语句 日志技术 输出位置 输出到控制台 可以将日志信息写入到文件或者数据库中 取消日志 需要修改代码，灵活性比较差 不需要修改代码，灵活性比较好 多线程 性能较差 性能较好 体系结构日志框架 JUL（java.util.loggiing）。 Log4j。 Logback。 其他实现。 日志接口为了减轻负担，设置接口让大家都遵守。 Commons Logging (JCL)。 Simple Logging Facade for Java (SLF4J)。 日志框架：牛人或者第三方公司已经做好的实现代码，后来者直接可以拿去使用。 日志接口：设计日志框架的一套标准，日志框架需要实现这些接口。 注意1：因为对Commons Logging接口不满意，有人就搞了SLF4J；因为对Log4j的性能不满意，有人就搞了Logback。 注意2：Logback是基于slf4j的日志规范实现的框架。 Logback日志框架网站：https://logback.qos.ch/index.html Logback日志框架有以下几个模块： logback-core。基础模块，是其他两个模块依赖的基础（必须有）。 logback-classic。功能模块，完整实现了slf4j API的模块（必须有）。 logback-access。与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志的功能（可选，以后再接触）。 想使用Logback日志框架，至少需要在项目中整合如下三个模块： slf4j-api。日志接口。 logback-core。基础模块。 logback-classic。功能模块。 Logback入门需求：使用Logback日志框架，纪录系统的运行信息。 实现步骤123451.导入Logback框架到项目中去。2.将Logback框架的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）。3.创建Logback框架提供的Logger对象，然后用Logger对象调用其提供的方法就可以记录系统的日志信息。创建一个日志记录日对象：public static final Logger LOGGER = LoggerFactory.getLogger(“类名&quot;); 具体步骤12341.在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目库中去。2.必须将Logback的核心配置文件logback.xml直接拷贝到src目录下。3.在代码中获取日志的对象4.调用日志对象的方法记录日志信息 代码 1234567891011121314151617181920212223public class LogBackTest &#123; // 创建一个Logger日志对象 public static final Logger LOGGER = LoggerFactory.getLogger(&quot;LogBackTest&quot;); public static void main(String[] args) &#123; //while (true) &#123; try &#123; LOGGER.info(&quot;chu法方法开始执行~~~&quot;); chu(10, 0); LOGGER.info(&quot;chu法方法执行成功~~~&quot;); &#125; catch (Exception e) &#123; LOGGER.error(&quot;chu法方法执行失败了，出现了bug~~~&quot;); &#125; //&#125; &#125; public static void chu(int a, int b)&#123; LOGGER.debug(&quot;参数a:&quot; + a); LOGGER.debug(&quot;参数b:&quot; + b); int c = a / b; LOGGER.info(&quot;结果是：&quot; + c); &#125;&#125; Logback.xml日志配置文件核心配置文件logback.xml，对Logback日志框架进行控制的。在记录日志时会读取配置文件中的配置信息，从而记录日志的形式。 具体可以做哪些配置？ 1234567891. 可以配置日志输出的位置是文件、还是控制台。&lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;2. 可以配置日志输出的格式。3. 还可以配置日志关闭和开启、以及哪些日志输出哪些日志不输出。// 设置为 “ALL”或“OFF”。//设置只输出到配置文件或者控制台，可以删掉其中一行。&lt;root level=&quot;ALL&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt;&lt;/root&gt; 如下图所示，控制日志往文件中输出，还是往控制台输出** 如下图所示，控制打开和关闭日志 如下图所示，控制日志的输出的格式 日志格式是由一些特殊的符号组成，可以根据需要删减不想看到的部分。比如不想看到线程名那就不要[%thread]。但是不建议同学们更改这些格式，因为这些都是日志很基本的信息。 Logback设置日志级别【重要】认识日志级别日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（优先级依次升高）： 日志级别 说明 trace 追踪，指明程序运行轨迹 debug 调试，实际应用中一般将其作为最低级别，而 trace 则很少使用 info 输出重要的运行信息，数据连接、网络连接、IO操作等等，使用较多 warn 警告信息，可能会发生问题，使用较多 error 错误信息, 使用较多 日志级别的作用用于控制系统中哪些日志级别是可以输出的。 如何设置日志级别可以在配置文件中书写日志级别： 1234&lt;root level=“info&quot;&gt;\t&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt;&lt;/root&gt; 只有日志的级别是大于或等于核心配置文件配置的日志级别，才会被记录，否则不记录。"},{"title":"【Java基础】java.io包下的常用API-io流","path":"/2024/04/07/【Java基础】【java.io】io流/","content":"File类之前学习的变量、数组、对象和集合都是内存中的数据容器，它们记住的数据在断电或者程序终止时会丢失。 如果想长期保存数据，应该怎么做？ 文件是非常重要的存储方式，在计算机硬盘中。 即便断电，或者程序终止了，存储在硬盘文件中的数据也不会丢失。 (1)File类 File是java.io.包下的类， File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）。 常见功能 获取文件信息（大小，文件名，修改时间）。 创建文件&#x2F;文件夹。 删除文件&#x2F;文件夹。 判断文件的类型。 …… 注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据。 (2)IO流 用于读写数据的（可以读写文件，或网络中的数据…）。 创建对象 public File(String pathname)。根据文件路径创建文件对象。（最重要！） public File(String parent, String child)。根据父路径和子路径名字创建文件对象。 public File(File parent, String child)。根据父路径对应文件对象和子路径名字创建文件对象。 File对象既可以代表文件、也可以代表文件夹。 File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。 路径分隔符 &#x2F;（推荐） \\\\ File.separator 绝对路径 从盘符开始。 File file1 &#x3D; new File(“D:\\itheima\\a.txt”); 相对路径（开发规范） 不带盘符，默认直接到当前工程下的目录寻找文件。 File file3 &#x3D; new File(“模块名\\a.txt”); 常用方法1：判断文件类型、获取文件信息 public boolean exists()。判断当前文件对象，对应的文件路径是否存在，存在返回true。 public boolean isFile()。判断当前文件对象指代的是否是文件，是文件返回true，反之。 public boolean isDirectory()。判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。 public String getName()。获取文件的名称（包含后缀）。 public long length()。获取文件的大小，返回字节个数。（然后可以转换成SimpleDateFormat并用format格式化。） public long lastModified()。获取文件的最后修改时间。 public String getPath()。获取创建文件对象时，使用的路径。 public String getAbsolutePath()。获取绝对路径。 常用方法2：创建文件、删除文件创建文件 public boolean createNewFile()。创建一个新的空的文件。（程序有可能担心我们乱写盘符，因此报异常，直接alt+enter抛出去就行。） public boolean mkdir()。只能创建一级文件夹。 public boolean mkdirs()。可以创建多级文件夹。（强大！） 删除文件 public boolean delete()。删除文件、空文件夹。 注意：delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。 常用方法3：遍历文件夹 public String[] list()。获取当前目录下所有的”一级文件名称“到一个字符串数组中去返回。 public File[] listFiles()。获取当前目录下所有的”一级文件对象“到一个文件对象数组中去返回（重点）。 注意事项： 当主调是文件，或者路径不存在时，返回null。 当主调是空文件夹时，返回一个长度为0的数组。 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回。 当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件。 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null。 前置：方法递归为了实现文件的多级操作。 是什么？ 递归是一种算法，在程序设计语言中广泛应用。 从形式上说：方法调用自身的形式称为方法递归（ recursion）。 形式 直接递归：方法自己调用自己。（比较常见。） 间接递归：方法调用其他方法，其他方法又回调方法自己。 注意 递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出错误。 递归调用的特点是：一层一层调用，再一层一层往回返。 递归算法三要素以求阶乘为例。 递归的公式： f(n) &#x3D; f(n-1) * n; 递归的终结点：f(1) 。 递归的方向必须走向终结点。 递归文件搜索莫得公式，怎么办？ 案例：在D:\\\\判断下搜索QQ.exe这个文件，然后直接输出。 1234561.先调用文件夹的listFiles方法，获取文件夹的一级内容，得到一个数组2.然后再遍历数组，获取数组中的File对象3.因为File对象可能是文件也可能是文件夹，所以接下来就需要判断\t判断File对象如果是文件，就获取文件名，如果文件名是`QQ.exe`则打印，否则不打印\t判断File对象如果是文件夹，就递归执行1,2,3步骤所以：把1，2,3步骤写成方法，递归调用即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 目标：掌握文件搜索的实现。 */public class RecursionTest3 &#123; public static void main(String[] args) throws Exception &#123; searchFile(new File(&quot;D:/&quot;) , &quot;QQ.exe&quot;); &#125; /** * 去目录下搜索某个文件 * @param dir 目录 * @param fileName 要搜索的文件名称 */ public static void searchFile(File dir, String fileName) throws Exception &#123; // 1、把非法的情况都拦截住 if(dir == null || !dir.exists() || dir.isFile())&#123; return; // 代表无法搜索 &#125; // 2、dir不是null,存在，一定是目录对象。 // 获取当前目录下的全部一级文件对象。 File[] files = dir.listFiles(); // 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。 if(files != null &amp;&amp; files.length &gt; 0)&#123; // 4、遍历全部一级文件对象。 for (File f : files) &#123; // 5、判断文件是否是文件,还是文件夹 if(f.isFile())&#123; // 是文件，判断这个文件名是否是我们要找的 if(f.getName().contains(fileName))&#123; System.out.println(&quot;找到了：&quot; + f.getAbsolutePath()); Runtime runtime = Runtime.getRuntime(); runtime.exec(f.getAbsolutePath()); &#125; &#125;else &#123; // 是文件夹，继续重复这个过程（递归） searchFile(f, fileName); &#125; &#125; &#125; &#125;&#125; 案例：删除一个非空文件夹。 121、File默认不可以删除非空文件夹2、我们需要遍历文件夹，先删除里面的内容，再删除自己。 代码： 得空补上。 前置：字符集常见字符集标准ASCII字符集 ASCII(American Standard Code for Information Interchange)： 美国信息交换标准代码，包括了英文、数字、符号等。 标准ASCII使用1个字节存储一个字符，0~127作为码点，首位是0，总共可表示128个字符，对美国佬来说完全够用。 GBK（汉字内码扩展规范，国标） 汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储。 注意：GBK兼容了ASCII字符集。GBK规定，汉字的第一个字节的第一位必须是1。 Unicode字符集(统一码，也叫万国码) Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集。 提供多重编码方案。最早是UTF-32，4个字节表示一个字符，但是占内存太大，通信效率变低。 UTF-8 是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字节，2个字节，3个字节，4个字节。 英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节。 注意：技术人员在开发时都应该使用UTF-8编码！ UTF-8编码方式(二进制) 0xxxxxxx （ASCII码） 110xxxxx 10xxxxxx 1110xxxx 10xxxxxx 10xxxxxx 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 注意事项 注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码。 注意2：英文、数字一般不会乱码，因为很多字符集都兼容了ASCII编码。 字符集的编码、解码操作String类下的方法和构造器。 编码：把字符按照指定字符集编码成字节。 byte[] getBytes()。使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中。 byte[] getBytes(String charsetName)。使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 。 解码：把字节按照指定字符集解码成字符。 String(byte[] bytes)。通过使用平台的默认字符集解码指定的字节数组来构造新的String。 String(byte[] bytes, String charsetName)。通过指定的字符集解码指定的字节数组来构造新的String。 IO流（字节流）IO流概述：输入输出流，用来读写数据的。 I指Input，称为输入流：负责把数据读到内存中去。 O指Output，称为输出流：负责写数据出去。 怎么学？ 先搞清楚IO流的分类、体系。 再挨个学习每个IO流的作用、用法。 分类 按照流的方向，分为输入流、输出流。 按照数据的最小单位，分为字节流（适合操作所有类型的文件）、字符流（只适合操作纯文本文件）。 –&gt;所以一共是4大基础流： 字节输入流。以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流。 字节输出流。以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流。 字符输入流。以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流。 字符输出流。以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。 IO流的体系 java.io包下： 字节流–&gt;字节输入流（InputStream）、字节输出流（OutputStream）； 字符流–&gt;字符输入流（Reader）、字符输出流（Writer）。 上述都是抽象类。然后对应有实现类，是在前面加个File： 字节流–&gt;字节输入流（FileInputStream）、字节输出流（FileOutputStream）； 字符流–&gt;字符输入流（FileReader）、字符输出流（FileWriter）。 FileInputStream文件字节输入流以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去。 构造器 public FileInputStream(File file)。创建字节输入流管道与源文件接通。 public FileInputStream(String pathname)。创建字节输入流管道与源文件接通。（是1的简化写法，也是推荐写法，系统里帮忙创建了File类。） 常用方法 public int read()。每次读取一个字节返回，如果发现没有数据可读会返回-1。返回值表示当前这一次读取的字节个数。 public int read(byte[] buffer)。每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1。 FileInputStream读取一个字节使用FileInputStream读取文件中的字节数据，步骤如下： 1231.创建FileInputStream文件字节输入流管道，与源文件接通。2.调用read()方法开始读取文件的字节数据。3.调用close()方法释放资源 代码如下： 12345678910111213141516171819/** * 目标：掌握文件字节输入流，每次读取一个字节。 */public class FileInputStreamTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建文件字节输入流管道，与源文件接通。 InputStream is = new FileInputStream((&quot;file-io-app\\\\src\\\\itheima01.txt&quot;)); // 2、开始读取文件的字节数据。 // public int read():每次读取一个字节返回，如果没有数据了，返回-1. int b; // 用于记住读取的字节。 while ((b = is.read()) != -1)&#123; System.out.print((char) b); &#125; //3、流使用完毕之后，必须关闭！释放系统资源！ is.close(); &#125;&#125; 存在的问题： 这种方法读取数据的性能很差（从系统资源里面调）。（开发规范：尽量减少从硬件内存中读取数据的频次。） 读取汉字会乱码。一个中文在UTF-8编码方案中是占3个字节，采用一次读取一个字节的方式，读一个字节就相当于读了1&#x2F;3个汉字，此时将这个字节转换为字符，会有乱码。 FileInputStream读取多个字节为了提高效率，我们可以使用另一个read(byte[] bytes)的重载方法，可以一次读取多个字节，至于一次读多少个字节，就在于你传递的数组有多大。 使用FileInputStream一次读取多个字节的步骤如下： 1231.创建FileInputStream文件字节输入流管道，与源文件接通。2.调用read(byte[] bytes)方法开始读取文件的字节数据。3.调用close()方法释放资源 代码如下： 1234567891011121314151617181920212223242526/** * 目标：掌握使用FileInputStream每次读取多个字节。 */public class FileInputStreamTest2 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个字节输入流对象代表字节输入流管道与源文件接通。 InputStream is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima02.txt&quot;); // 2、开始读取文件中的字节数据：每次读取多个字节。 // public int read(byte b[]) throws IOException // 每次读取多个字节到字节数组中去，返回读取的字节数量，读取完毕会返回-1. // 3、使用循环改造。 byte[] buffer = new byte[3]; int len; // 记住每次读取了多少个字节。 abc 66 while ((len = is.read(buffer)) != -1)&#123; // 注意：读取多少，倒出多少。(否则填不满的位置还是存放之前的内容) String rs = new String(buffer, 0 , len); System.out.print(rs); &#125; // 性能得到了明显的提升！！ // 这种方案也不能避免读取汉字输出乱码的问题！！ is.close(); // 关闭流 &#125;&#125; 存在的问题： 使用FileInputStream每次读取多个字节，读取性能得到了提升。 但读取汉字输出还是会乱码。 使用字节流读取中文，如何保证输出不乱码，怎么解决？ 方式1：自己定义一个字节数组与被读取的文件大小一样大，然后使用该字节数组，一次读完文件的全部字节。 1234567891011121314// 1、一次性读取完文件的全部字节到一个字节数组中去。// 创建一个字节输入流管道与源文件接通InputStream is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;);// 2、准备一个字节数组，大小与文件的大小正好一样大。File f = new File(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;);long size = f.length();byte[] buffer = new byte[(int) size];int len = is.read(buffer);System.out.println(new String(buffer));//3、关闭流is.close(); 方式2：Java官方为InputStream提供了如下方法，可以直接把文件的全部字节读取到一个字节数组中返回。&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; public byte[] readAllBytes() throws IOException。直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回。 12345678910// 1、一次性读取完文件的全部字节到一个字节数组中去。// 创建一个字节输入流管道与源文件接通InputStream is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;);//2、调用方法读取所有字节，返回一个存储所有字节的字节数组。byte[] buffer = is.readAllBytes();System.out.println(new String(buffer));//3、关闭流is.close(); 注意：一次读取所有字节虽然可以解决乱码问题，但是文件不能过大，如果文件过大，可能导致内存溢出。 —&gt;读写文本内容更适合用字符流。字节流适合做数据的转移，例如，文件复制等。 FileOutputStream文件字节输出流作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去。 构造器 public FileOutputStream(File file)。创建字节输出流管道与源文件对象接通。 public FileOutputStream(String filepath)。创建字节输出流管道与源文件路径接通。 public FileOutputStream(File file，boolean append)。创建字节输出流管道与源文件对象接通，可追加数据。 public FileOutputStream(String filepath，boolean append)。创建字节输出流管道与源文件路径接通，可追加数据。 常用方法 public void write(int a)。写一个字节出去。 public void write(byte[] buffer)。写一个字节数组出去。 public void write(byte[] buffer , int pos , int len)。写一个字节数组的一部分出去。 public void close() throws IOException。关闭流。 FileOutputStream往文件中写数据的步骤如下： 1231.创建FileOutputStream文件字节输出流管道，与目标文件接通。2.调用wirte()方法往文件中写数据3.调用close()方法释放资源 代码如下： 123456789101112131415161718192021222324252627282930/** * 目标：掌握文件字节输出流FileOutputStream的使用。 */public class FileOutputStreamTest4 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个字节输出流管道与目标文件接通。 // 覆盖管道：覆盖之前的数据// OutputStream os =// new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;); // 追加数据的管道 OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;, true); // 2、开始写字节数据出去了 os.write(97); // 97就是一个字节，代表a os.write(&#x27;b&#x27;); // &#x27;b&#x27;也是一个字节 // os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节 byte[] bytes = &quot;我爱你中国abc&quot;.getBytes(); os.write(bytes); os.write(bytes, 0, 15); // 换行符 os.write(&quot;\\r &quot;.getBytes()); os.close(); // 关闭流 &#125;&#125; 案例：字节流复制文件需求：要复制一张图片，从磁盘D:/resource/meinv.png的一个位置，复制到C:/data/meinv.png位置。 思路：源路径–(创建字节输入流管道)-&gt;内存(字节数组)–(创建字节输出流管道)-&gt;新路径。 1231.需要创建一个FileInputStream流与源文件接通，创建FileOutputStream与目标文件接通2.然后创建一个数组，使用FileInputStream每次读取一个字节数组的数据，存如数组中3.然后再使用FileOutputStream把字节数组中的有效元素，写入到目标文件中 代码： 12345678910111213141516171819202122232425/** * 目标：使用字节流完成对文件的复制操作。 */public class CopyTest5 &#123; public static void main(String[] args) throws Exception &#123; // 需求：复制照片。 // 1、创建一个字节输入流管道与源文件接通 InputStream is = new FileInputStream(&quot;D:/resource/meinv.png&quot;); // 2、创建一个字节输出流管道与目标文件接通。 OutputStream os = new FileOutputStream(&quot;C:/data/meinv.png&quot;); System.out.println(10 / 0); // 3、创建一个字节数组，负责转移字节数据。 byte[] buffer = new byte[1024]; // 1KB. // 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。 int len; // 记住每次读取了多少个字节。 while ((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; os.close(); is.close(); System.out.println(&quot;复制完成！！&quot;); &#125;&#125; 总结：字节流非常适合做一切文件的复制操作。\t任何文件的底层都是字节，字节流做复制，是一字不漏的转移完全部字节，只要复制后的文件格式一致就没问题! IO流资源释放如果前面的操作出现问题，那就没有机会执行close()方法了。 try-catch-finally finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非JVM终止。（注意千万不要在finally里面返回数据，不然就是一场空。） 作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法）。 1234567891011121314151617181920212223242526272829303132333435363738public class Test2 &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; try &#123; System.out.println(10 / 0); // 1、创建一个字节输入流管道与源文件接通 is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;); // 2、创建一个字节输出流管道与目标文件接通。 os = new FileOutputStream(&quot;file-io-app\\\\src\\\\itheima03copy.txt&quot;); System.out.println(10 / 0); // 3、创建一个字节数组，负责转移字节数据。 byte[] buffer = new byte[1024]; // 1KB. // 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。 int len; // 记住每次读取了多少个字节。 while ((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; System.out.println(&quot;复制完成！！&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源的操作 try &#123; if(os != null) os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(is != null) is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; try-with-resourceJDK7以后的资源释放。 格式如下： 1234567try(资源对象1; 资源对象2;)&#123; 使用资源的代码&#125;catch(异常类 e)&#123; 处理异常的代码&#125;//注意：注意到没有，这里没有释放资源的代码。它会自动是否资源 代码如下： 1234567891011121314151617181920212223242526/** * 目标：掌握释放资源的方式：try-with-resource */public class Test3 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个字节输入流管道与源文件接通 InputStream is = new FileInputStream(&quot;D:/resource/meinv.png&quot;); // 2、创建一个字节输出流管道与目标文件接通。 OutputStream os = new FileOutputStream(&quot;C:/data/meinv.png&quot;); )&#123; // 3、创建一个字节数组，负责转移字节数据。 byte[] buffer = new byte[1024]; // 1KB. // 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。 int len; // 记住每次读取了多少个字节。 while ((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; System.out.println(conn); System.out.println(&quot;复制完成！！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意小括号里面只能放置资源变量（流对象）。 什么是资源？资源都是会实现AutoCloseable接口的，都会有一个close方法。 资源放到小括号里面后，用完会被自动调用其close方法完成资源的释放操作。 IO流（字符流） 字节流：适合复制文件等，不适合读写文本文件。 字符流：适合读写文本文件内容。 作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去。 FileReader文件字符输入流构造器 public FileReader(File file)。创建字符输入流管道与源文件接通。 public FileReader(String pathname)。创建字符输入流管道与源文件接通。 常用方法 public int read()。每次读取一个字符返回，如果发现没有数据可读会返回-1。 public int read(char[] buffer)。每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1。 FileReader读取文件的步骤如下： 1231.创建FileReader对象与要读取的源文件接通2.调用read()方法读取文件中的字符3.调用close()方法关闭流 代码： 12345678910111213141516171819202122232425262728/** * 目标：掌握文件字符输入流。 */public class FileReaderTest1 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个文件字符输入流管道与源文件接通 Reader fr = new FileReader(&quot;io-app2\\\\src\\\\itheima01.txt&quot;); )&#123; // 2、一个字符一个字符的读（性能较差）// int c; // 记住每次读取的字符编号。// while ((c = fr.read()) != -1)&#123;// System.out.print((char) c);// &#125; // 每次读取一个字符的形式，性能肯定是比较差的。 // 3、每次读取多个字符。（性能是比较不错的！） char[] buffer = new char[3]; int len; // 记住每次读取了多少个字符。 while ((len = fr.read(buffer)) != -1)&#123; // 读取多少倒出多少 System.out.print(new String(buffer, 0, len)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; FileWriter文件字符输出流作用：以内存为基准，把内存中的数据以字符的形式写出到文件中去。 构造器 public FileWriter(File file)。创建字节输出流管道与源文件对象接通。 public FileWriter(String filepath)。创建字节输出流管道与源文件路径接通。 public FileWriter(File file，boolean append)。创建字节输出流管道与源文件对象接通，可追加数据。 public FileWriter(String filepath，boolean append)。创建字节输出流管道与源文件路径接通，可追加数据。 常用方法 void write(int c)。写一个字符。 void write(String str)。写一个字符串。 void write(String str, int off, int len)。写一个字符串的一部分。 void write(char[] cbuf)。写入一个字符数组。 void write(char[] cbuf, int off, int len)。写入字符数组的一部分。 步骤如下： 1231.创建FileWirter对象与要读取的目标文件接通2.调用write(字符数据/字符数组/字符串)方法读取文件中的字符3.调用close()方法关闭流 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839/** * 目标：掌握文件字符输出流：写字符数据出去 */public class FileWriterTest2 &#123; public static void main(String[] args) &#123; try ( // 0、创建一个文件字符输出流管道与目标文件接通。 // 覆盖管道 // Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;); // 追加数据的管道 Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;, true); )&#123; // 1、public void write(int c):写一个字符出去 fw.write(&#x27;a&#x27;); fw.write(97); //fw.write(&#x27;磊&#x27;); // 写一个字符出去 fw.write(&quot;\\r &quot;); // 换行 // 2、public void write(String c)写一个字符串出去 fw.write(&quot;我爱你中国abc&quot;); fw.write(&quot;\\r &quot;); // 3、public void write(String c ,int pos ,int len):写字符串的一部分出去 fw.write(&quot;我爱你中国abc&quot;, 0, 5); fw.write(&quot;\\r &quot;); // 4、public void write(char[] buffer):写一个字符数组出去 char[] buffer = &#123;&#x27;黑&#x27;, &#x27;马&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; fw.write(buffer); fw.write(&quot;\\r &quot;); // 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去 fw.write(buffer, 0, 2); fw.write(&quot;\\r &quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意事项字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效。 public void flush() throws IOException。刷新流，就是将内存中缓存的数据立即写到文件中去生效！刷新流之后数据流可以继续使用。（数据在内存中装满了会自动刷新写进文件然后继续接。） public void close() throws IOException。关闭流的操作，包含了刷新！关闭之后就不可以继续用了。 总结 字节流适合做一切文件数据的拷贝（音视频，文本）；字节流不适合读取中文内容输出。 字符流适合做文本文件的操作（读，写）。 缓冲流更新（原因&#x2F;区别） 前面学的以File开头的实现类称为原始流&#x2F;低级流。 以Buffered开头称为包装流&#x2F;处理流。对原始流进行包装，以提高原始流读写数据的性能。 字节缓冲流原理 字节缓冲输入流自带了8KB缓冲池；字节缓冲输出流也自带了8KB缓冲池。 构造器 public BufferedInputStream(InputStream is)。把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能。 public BufferedOutputStream(OutputStream os)。把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能。 功能上并无很大变化，性能提升。 字符缓冲流原理： 自带8K（8192）的字符缓冲池，可以提高字符输入流、输出流读取字符数据的性能。 构造器： public BufferedReader(Reader r)。把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能。 public String readLine()。（新增，按照行读取。）读取一行数据返回，如果没有数据可读了，会返回null。 public BufferedWriter(Writer r)。把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能。 public void newLine()。（新增，换行。） 案例：拷贝出师表并恢复顺序。 原始流、缓冲流的性能分析[重点]测试用例： 分别使用原始的字节流，以及字节缓冲流复制一个很大视频。 测试步骤： 使用低级的字节流按照一个一个字节的形式复制文件。 使用低级的字节流按照字节数组的形式复制文件。 使用高级的缓冲字节流按照一个一个字节的形式复制文件。 使用高级的缓冲字节流按照字节数组的形式复制文件。 默认情况下，采用一次复制1024个字节，缓冲流完胜。 一次读取8192个字节时，低级流和缓冲流性能相当。相差的那几毫秒可以忽略不计。 数组越大性能越高，低级流和缓冲流性能相当。相差的那几秒可以忽略不计。 数组大到一定程度，性能已经提高了多少了，甚至缓冲流的性能还没有低级流高。 结论：推荐使用哪种方式提高字节流读写数据的性能？ 缓冲流的性能不一定比低级流高，其实低级流自己加一个数组，性能其实是不差。只不过缓冲流帮你加了一个相对而言大小比较合理的数组 。 建议使用字节缓冲输入流、字节缓冲输出流，结合字节数组的方式，目前来看是性能最优的组合。 IO流-转换流转换流：可以将字节流转换为字符流，并且可以指定编码方案。 解决不同编码时，字符流读取文本内容乱码的问题。 解决思路：先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了 原因： FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码，因为FileReader它遇到汉字默认是按照3个字节来读取的，而GBK格式的文件一个汉字是占2个字节，这样就会导致乱码。 如果代码编码和被读取的文本文件的编码是不一致的，使用字符流读取文本文件时就会出现乱码！ InputStreamReader类 InputStreamzhuan转换为Reader，是Reader的子类，也算是字符输入流。 不能单独使用，内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。 常用方法： public InputStreamReader(InputStream is)。把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样）。 public InputStreamReader(InputStream is ，String charset)。把原始的字节输入流，按照指定字符集编码转成字符输入流(重点)。 123456789101112131415161718192021public class InputStreamReaderTest2 &#123; public static void main(String[] args) &#123; try ( // 1、得到文件的原始字节流（GBK的字节流形式） InputStream is = new FileInputStream(&quot;io-app2/src/itheima06.txt&quot;); // 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流 Reader isr = new InputStreamReader(is, &quot;GBK&quot;); // 3、把字符输入流包装成缓冲字符输入流 BufferedReader br = new BufferedReader(isr); )&#123; String line; while ((line = br.readLine()) != null)&#123; System.out.println(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; OutputStreamWriter类如何控制写出去的字符使用的字符集编码？ 调用String提供的getBytes方法。 用字符输出转换流实现。 OutputStream转换为Writer，是Writer的子类，算是字符输出流。 不能单独使用，内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。 作用：可以控制写出去的字符使用什么字符集编码。 解决思路：获取字节输出流，再按照指定的字符集编码将其转换成字符输出流，以后写出去的字符就会用该字符集编码了。 常用方法： public OutputStreamWriter(OutputStream os)。可以把原始的字节输出流，按照代码默认编码转换成字符输出流。 public OutputStreamWriter(OutputStream os，String charset)。可以把原始的字节输出流，按照指定编码转换成字符输出流(重点)。 12345678910111213141516171819public class OutputStreamWriterTest3 &#123; public static void main(String[] args) &#123; // 指定写出去的字符编码。 try ( // 1、创建一个文件字节输出流 OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima07out.txt&quot;); // 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。 Writer osw = new OutputStreamWriter(os, &quot;GBK&quot;); // 3、把字符输出流包装成缓冲字符输出流 BufferedWriter bw = new BufferedWriter(osw); )&#123; bw.write(&quot;我是中国人abc&quot;); bw.write(&quot;我爱你中国123&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; IO流-打印流PrintStream&#x2F;PrintWriter（打印流） 作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去。 优势：能上都是使用方便，性能高效（核心优势）。 PrintStream构造器继承自字节输出流OutputStream，支持写字节。 public PrintStream(OutputStream&#x2F;File&#x2F;String)。打印流直接通向字节输出流&#x2F;文件&#x2F;文件路径。 public PrintStream(String fileName, Charset charset)。可以指定写出去的字符编码。 public PrintStream(OutputStream out, boolean autoFlush)。可以指定实现自动刷新。 public PrintStream(OutputStream out, boolean autoFlush, String encoding)。可以指定实现自动刷新，并可指定字符的编码。 PrintStream常用方法 public void println(Xxx xx)。打印任意类型的数据出去。 public void write(int&#x2F;byte[]&#x2F;byte[]一部分)。可以支持写字节数据出去。 PrintWriter构造器继承自字符输出流Writer，支持写字符。 public PrintWriter(OutputStream&#x2F;Writer&#x2F;File&#x2F;String)。打印流直接通向字节输出流&#x2F;文件&#x2F;文件路径。 public PrintWriter(String fileName, Charset charset)。可以指定写出去的字符编码。 public PrintWriter(OutputStream out&#x2F;Writer, boolean autoFlush)。可以指定实现自动刷新。 public PrintWriter(OutputStream out, boolean autoFlush, String encoding)。可以指定实现自动刷新，并可指定字符的编码。 PrintWriter常用方法 public void println(Xxx xx)。打印任意类型的数据出去。 public void write(int&#x2F;String&#x2F;char[]&#x2F;..)。可以支持写字符数据出去。 PrintStream和PrintWriter的区别 打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势）。 PrintStream继承自字节输出流OutputStream，因此支持写字节数据的方法。 PrintWriter继承自字符输出流Writer，因此支持写字符数据出去。 注意：高级流方法不能直接追加true来控制，需要先包装成低级流。 1new PrintWriterStream(new FileOutputStream(&quot;path&quot;,true)) 输出语句的重定向。 打印流的一种应用。 可以把输出语句的打印位置改到某个文件中去。 System.out.println(“老骥伏枥”)这个语句的out实际上是帮我们创建了一个打印对象，然后默认打印到控制台上。 12345678910111213141516public class PrintTest2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;老骥伏枥&quot;); System.out.println(&quot;志在千里&quot;); try ( PrintStream ps = new PrintStream(&quot;io-app2/src/itheima09.txt&quot;); )&#123; // 把系统默认的打印流对象改成自己设置的打印流 System.setOut(ps);//定向到这里了 System.out.println(&quot;烈士暮年&quot;); System.out.println(&quot;壮心不已&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; IO流-数据流需求：把数据和数据的类型一并写到文件中去，读取的时候也将数据和数据类型一并读出来。有两个：DataInputStream和DataOutputStream。 DataOutputStream类允许把数据和其类型一并写出去。 构造器 public DataOutputStream(OutputStream out)。创建新数据输出流包装基础的字节输出流。 常用方法 public final void writeByte(int v) throws IOException。将byte类型的数据写入基础的字节输出流。 public final void writeInt(int v) throws IOException。将int类型的数据写入基础的字节输出流。 public final void writeDouble(Double v) throws IOException。将double类型的数据写入基础的字节输出流。 public final void writeUTF(String str) throws IOException。将字符串数据以UTF-8编码成字节写入基础的字节输出流。 public void write(int&#x2F;byte[]&#x2F;byte[]一部分)。支持写字节数据出去。 DataInputStream类用于读取数据输出流写出去的数据。 构造器 public DataInputStream(InputStream is)。创建新数据输入流包装基础的字节输入流。 常用方法 Public final byte readByte() throws IOException。读取字节数据返回。 public final int readInt() throws IOException。读取int类型的数据返回。 public final double readDouble() throws IOException。读取double类型的数据返回。 public final String readUTF() throws IOException。读取字符串数（UTF-8）据返回。 public int readInt()&#x2F;read(byte[])。支持读字节数据进来。 注意：二者需要搭配使用，存进去的是什么类型，读取就要怎么读，而且存进去的数据并不是为了读者直接来看的。（在通信中非常方便。） IO流-序列化流序列化 对象序列化：把Java对象写入到文件中去。 对象反序列化：把文件里的Java对象读出来。 ObjectOutputStream类可以把Java对象进行序列化：把Java对象存入到文件中去。 构造器 public ObjectOutputStream(OutputStream out)。创建对象字节输出流，包装基础的字节输出流。 常用方法 public final void writeObject(Object o) throws IOException。把对象写出去。 注意：对象如果要参与序列化，必须实现序列化接口（java.io.Serializable）！相当于一个标记，虽然接口里面什么都没有，但是虚拟机需要。 ObjectInputStream类可以把Java对象进行反序列化：把存储在文件中的Java对象读入到内存中来。 构造器 public ObjectInputStream(InputStream is)。创建对象字节输入流，包装基础的字节输入流。 常用方法 public final Object readObject()。把存储在文件中的Java对象读出来。 注意：如果成员变量中加transient修饰符，这个成员变量将不参与序列化。 如果要一次系列化多个对象，怎么做？ 用一个ArrayList集合存储多个对象，然后直接对集合进行序列化即可。 注意：ArrayList集合已经实现了序列化接口！ 补充知识： IO框架什么是框架 解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多框架都是第三方研发的。 好处：在框架的基础上开发，可以得到优秀的软件架构，并能提高开发效率 框架的形式：一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去。 什么是IO框架 封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式来对文件进行操作，对数据进行读写等。 Commons-io框架Commons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。 FileUtils类提供的部分方法展示 public static void copyFile(File srcFile, File destFile)。复制文件。 public static void copyDirectory(File srcDir, File destDir)。复制文件夹。 public static void deleteDirectory(File directory)。删除文件夹。 public static String readFileToString(File file, String encoding)。读数据。 public static void writeStringToFile(File file, String data, String charname, boolean append)。写数据。 IOUtils类提供的部分方法展示 public static int copy(InputStream inputStream, OutputStream outputStream)。复制文件。 public static int copy(Reader reader, Writer writer)。复制文件。 public static void write(String data, OutputStream output, String charsetName)。写数据。 使用指北 下载：Commons IO – Download Apache Commons IO Binary的zip包。 复制“commons-io-2.11.0.jar”包。 项目文件夹邮件，新建Directory，取名“lib”。粘贴。 右键lib文件夹，选择“Add as library”。 可以使用了。 最后，其实Java原生自己从1.7也提供了File类的copy、readString等方法来做，但是功能上还没有第三方框架强大。"},{"title":"【Java基础】集合（Map、Stream流）","path":"/2024/04/06/【Java基础】【java.util】集合（Map、Stream流）/","content":"Map集合需要存储一一对应的数据时，就可以考虑使用Map集合来做。 Map集合称为双列集合，格式：{key1&#x3D;value1 , key2&#x3D;value2 , key3&#x3D;value3 , …}， 一次需要存一对数据做为一个元素。 Map集合的每个元素“key&#x3D;value”称为一个键值对&#x2F;键值对对象&#x2F;Entry对象，Map集合也被叫做“键值对集合”。 Map集合的所有键是不允许重复的，但值可以重复，键和值是一一对应的，每一个键只能找到自己对应的值。 Map集合体系Map&lt;K,V&gt;是接口，下面有很多实现类： HashMap&lt;K , V&gt;。 LinkedHashMap&lt;K , V&gt;。（是1的子类。） TreeMap&lt;K , V&gt;。 特点： Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的。 HashMap（由键决定特点）: 无序、不重复、无索引； （用的最多）。 LinkedHashMap （由键决定特点）:由键决定的特点：有序、不重复、无索引。 TreeMap （由键决定特点）:按照（键的）大小默认升序排序、不重复、无索引。 12//经典代码Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\t//同样需要指定具体类。 Map常用方法 public V put(K key,V value)。添加元素。 public int size()。获取集合的大小。 public void clear()。清空集合。 public boolean isEmpty()。判断集合是否为空，为空返回true , 反之。 public V get(Object key)。根据键获取对应值。 public V remove(Object key)。根据键删除整个元素。 public boolean containsKey(Object key)。判断是否包含某个键。（是精确匹配。） public boolean containsValue(Object value)。判断是否包含某个值。（值的类型一定要注意。） public Set keySet()。获取全部键的集合。（会放到一个Set里面再返回。） public Collection values()。获取Map集合的全部值。（会放到一个Collection里面再返回，因为Set里面不允许有重复的值。） putAll()。把其他Map集合的数据倒入到自己集合中来。 Map遍历方式 键找值。先获取Map集合全部的键，再通过遍历键来找值。 键值对。把“键值对“看成一个整体进行遍历（难度较大）。 Labmda。JDK 1.8开始之后的新技术（非常的简单）。 键找值 public Set keySet()。获取所有键的集合。 public V get(Object key)。根据键获取其对应的值。 12345678910// 1、获取Map集合的全部键Set&lt;String&gt; keys = map.keySet();// System.out.println(keys);// [蜘蛛精, 牛魔王, 至尊宝, 紫霞]// key// 2、遍历全部的键，根据键获取其对应的值for (String key : keys) &#123; // 根据键获取对应的值 double value = map.get(key); System.out.println(key + &quot;=====&gt;&quot; + value); 键值对使用增强for遍历时，元素类型无法确定。所以Java提供另一个方法： Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()。获取所有“键值对”的集合。作为一个Set集合返回了，然后每个元素就是键值对类型，自然也就可以遍历了。 Map.Entry提供的方法： K getKey()。获取键。 V getValue()。获取值。 123456// 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();\t//ctrl+alt+vfor (Map.Entry&lt;String, Double&gt; entry : entries) &#123; String key = entry.getKey(); double value = entry.getValue(); System.out.println(key + &quot;----&gt;&quot; + value); Labmda（简单，推荐）JDK 1.8开始。需要用到下面的方法： default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)。结合lambda遍历Map集合。 1234567891011121314//遍历map集合，传递Lambda表达式map.forEach(( k, v) -&gt; &#123; System.out.println(k + &quot;----&gt;&quot; + v);&#125;);//来看看原来的形式//遍历map集合，传递匿名内部类（BiConsumer是一个接口）map.forEach(new BiConsumer&lt;String, Double&gt;() &#123; @Override public void accept(String k, Double v) &#123; System.out.println(k + &quot;----&gt;&quot; + v); &#125;&#125;);//forEach内部其实是利用了第2种遍历方法（键值对） (1)HashMapHashMap（由键决定特点）: 无序、不重复、无索引； （用的最多）。 底层原理 和HashSet的底层原理一样，基于哈希表实现。实际上：原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。 JDK8之前，哈希表 &#x3D; 数组+链表；JDK8开始，哈希表 &#x3D; 数组+链表+红黑树；哈希表是一种增删改查数据，性能都较好的数据结构。但是它是无序，不能重复，没有索引支持的（由键决定特点）。 HashMap的键依赖hashCode方法和equals方法保证键的唯一。 如果键存储的是自定义类型的对象，可以通过重写hashCode和equals方法，这样可以保证多个对象内容一样时，HashMap集合就能认为是重复的。 (2)LinkedHashMapLinkedHashMap （由键决定特点）:由键决定的特点：有序、不重复、无索引。 底层原理 底层数据结构依然是基于哈希表实现的，只是每个键值对元素又额外的多了一个双链表的机制记录元素顺序(保证有序)。实际上：原来学习的LinkedHashSet集合的底层原理就是LinkedHashMap。 (3)TreeMapTreeMap （由键决定特点）:按照（键的）大小默认升序排序、不重复、无索引。 底层原理 特点：不重复、无索引、可排序(按照键的大小默认升序排序，只能对键排序)。 原理：TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。 TreeMap集合同样也支持两种方式来指定排序规则。 让类实现Comparable接口，重写conpareTo()比较规则。 TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。 补充知识：集合的嵌套集合中的元素又是一个集合。 Stream流JDK8开始最大的改变之一。（一共是两个：1.Lambda表达式，2.Stream流。） 什么是Stream？ 也叫Stream流，是Jdk8开始新增的一套API (java.util.stream.*)，可以用于操作集合或者数组的数据。 优势： Stream流大量的结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好。 案例有一个List集合，元素有&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;，找出姓张，且是3个字的名字，存入到一个新集合中去。 123List&lt;String&gt; names = new ArrayList&lt;&gt;();Collections.addAll(names, &quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;);System.out.println(names); 传统方式： 12345678// 找出姓张，且是3个字的名字，存入到一个新集合中去。List&lt;String&gt; list = new ArrayList&lt;&gt;();for (String name : names) &#123; if(name.startsWith(&quot;张&quot;) &amp;&amp; name.length() == 3)&#123; list.add(name); &#125;&#125;System.out.println(list); Stream流：（支持链式编程。） 12List&lt;String&gt; list2 = names.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(a -&gt; a.length()==3).collect(Collectors.toList());System.out.println(list2); 两次filter筛选，然后collect收集。 使用步骤 数据源。–&gt;获取其Stream流（理解为流水线，能与数据源建立联系）。 中间方法。调用流水线的各种方法对数据进行处理和计算。例如，过滤、排序、去重等。 获取结果。便利、统计、收集到一个新的集合中并返回。 12345主要掌握下面四点：\t1、如何获取List集合的Stream流？\t2、如何获取Set集合的Stream流？\t3、如何获取Map集合的Stream流？\t4、如何获取数组的Stream流？ 常用方法获取Stream流如何获取集合的Stream流？ Collection类。default Stream stream()。获取当前集合对象的Stream流。 如何获取数组的Stream流？ Arrays类。public static Stream stream(T[] array)。获取当前数组的Stream流。 Stream类。public static Stream of(T… values)。获取当前接收数据的Stream流。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 目标：掌握Stream流的创建。 */public class StreamTest2 &#123; public static void main(String[] args) &#123; // 1、如何获取List集合的Stream流？ List&lt;String&gt; names = new ArrayList&lt;&gt;(); Collections.addAll(names, &quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;); Stream&lt;String&gt; stream = names.stream(); // 2、如何获取Set集合的Stream流？ Set&lt;String&gt; set = new HashSet&lt;&gt;(); Collections.addAll(set, &quot;刘德华&quot;,&quot;张曼玉&quot;,&quot;蜘蛛精&quot;,&quot;马德&quot;,&quot;德玛西亚&quot;); Stream&lt;String&gt; stream1 = set.stream(); stream1.filter(s -&gt; s.contains(&quot;德&quot;)).forEach(s -&gt; System.out.println(s)); // 3、如何获取Map集合的Stream流？ Map&lt;String, Double&gt; map = new HashMap&lt;&gt;(); map.put(&quot;古力娜扎&quot;, 172.3); map.put(&quot;迪丽热巴&quot;, 168.3); map.put(&quot;马尔扎哈&quot;, 166.3); map.put(&quot;卡尔扎巴&quot;, 168.3); Set&lt;String&gt; keys = map.keySet(); Stream&lt;String&gt; ks = keys.stream(); Collection&lt;Double&gt; values = map.values(); Stream&lt;Double&gt; vs = values.stream(); Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet(); Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream(); kvs.filter(e -&gt; e.getKey().contains(&quot;巴&quot;)) .forEach(e -&gt; System.out.println(e.getKey()+ &quot;--&gt;&quot; + e.getValue())); // 4、如何获取数组的Stream流？ String[] names2 = &#123;&quot;张翠山&quot;, &quot;东方不败&quot;, &quot;唐大山&quot;, &quot;独孤求败&quot;&#125;; Stream&lt;String&gt; s1 = Arrays.stream(names2); Stream&lt;String&gt; s2 = Stream.of(names2); &#125;&#125; 中间方法中间方法指的是调用完成后会返回新的Stream流，可以继续使用(支持链式编程)。（因此支持链式编程。） 常用方法 Stream filter(Predicate&lt;? super T&gt; predicate)。用于对流中的数据进行过滤。 Stream sorted()。对元素进行升序排序。 Stream sorted(Comparator&lt;? super T&gt; comparator)。对元素进行升序排序。 Stream limit(long maxSize)。获取前几个元素。 Stream skip(long n)。跳过前几个元素。 Stream distinct()。去除流中重复的元素。 Stream map(Function&lt;? super T,? extends R&gt; mapper)。对元素进行加工，并返回对应的新流。 static Stream concat(Stream a, Stream b)。合并a和b两个流为一个流。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 目标：掌握Stream流提供的常见中间方法。 */public class StreamTest3 &#123; public static void main(String[] args) &#123; List&lt;Double&gt; scores = new ArrayList&lt;&gt;(); Collections.addAll(scores, 88.5, 100.0, 60.0, 99.0, 9.5, 99.6, 25.0); // 需求1：找出成绩大于等于60分的数据，并升序后，再输出。 scores.stream().filter(s -&gt; s &gt;= 60).sorted().forEach(s -&gt; System.out.println(s)); List&lt;Student&gt; students = new ArrayList&lt;&gt;(); Student s1 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s2 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s3 = new Student(&quot;紫霞&quot;, 23, 167.6); Student s4 = new Student(&quot;白晶晶&quot;, 25, 169.0); Student s5 = new Student(&quot;牛魔王&quot;, 35, 183.3); Student s6 = new Student(&quot;牛夫人&quot;, 34, 168.5); Collections.addAll(students, s1, s2, s3, s4, s5, s6); // 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出. students.stream().filter(s -&gt; s.getAge() &gt;= 23 &amp;&amp; s.getAge() &lt;= 30) .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge()) .forEach(s -&gt; System.out.println(s)); // 需求3：取出身高最高的前3名学生，并输出。 students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight())) .limit(3).forEach(System.out::println); System.out.println(&quot;-----------------------------------------------&quot;); // 需求4：取出身高倒数的2名学生，并输出。 s1 s2 s3 s4 s5 s6 students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight())) .skip(students.size() - 2).forEach(System.out::println); // 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。 students.stream().filter(s -&gt; s.getHeight() &gt; 168).map(Student::getName) .distinct().forEach(System.out::println); // distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals） students.stream().filter(s -&gt; s.getHeight() &gt; 168) .distinct().forEach(System.out::println); Stream&lt;String&gt; st1 = Stream.of(&quot;张三&quot;, &quot;李四&quot;); Stream&lt;String&gt; st2 = Stream.of(&quot;张三2&quot;, &quot;李四2&quot;, &quot;王五&quot;); Stream&lt;String&gt; allSt = Stream.concat(st1, st2); //如果合并的两个类型不一样，需要用Object来接。 allSt.forEach(System.out::println); &#125;&#125; 终结方法终结方法指的是调用完成后，不会返回新Stream了，没法继续使用流了。 常用方法 void forEach(Consumer action)。对此流运算后的元素执行遍历。 long count()。统计此流运算后的元素个数。 Optional max(Comparator&lt;? super T&gt; comparator)。获取此流运算后的最大值元素。 Optional min(Comparator&lt;? super T&gt; comparator)。获取此流运算后的最小值元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 目标：Stream流的终结方法 */public class StreamTest4 &#123; public static void main(String[] args) &#123; List&lt;Student&gt; students = new ArrayList&lt;&gt;(); Student s1 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s2 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s3 = new Student(&quot;紫霞&quot;, 23, 167.6); Student s4 = new Student(&quot;白晶晶&quot;, 25, 169.0); Student s5 = new Student(&quot;牛魔王&quot;, 35, 183.3); Student s6 = new Student(&quot;牛夫人&quot;, 34, 168.5); Collections.addAll(students, s1, s2, s3, s4, s5, s6); // 需求1：请计算出身高超过168的学生有几人。 long size = students.stream().filter(s -&gt; s.getHeight() &gt; 168).count(); System.out.println(size); // 需求2：请找出身高最高的学生对象，并输出。 Student s = students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); System.out.println(s); // 需求3：请找出身高最矮的学生对象，并输出。 Student ss = students.stream().min((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); System.out.println(ss); // 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。 // 流只能收集一次。 List&lt;Student&gt; students1 = students.stream().filter(a -&gt; a.getHeight() &gt; 170).collect(Collectors.toList()); System.out.println(students1); Set&lt;Student&gt; students2 = students.stream().filter(a -&gt; a.getHeight() &gt; 170).collect(Collectors.toSet()); System.out.println(students2); // 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。 Map&lt;String, Double&gt; map = students.stream().filter(a -&gt; a.getHeight() &gt; 170) .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight())); System.out.println(map); // Object[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray(); Student[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray(len -&gt; new Student[len]); System.out.println(Arrays.toString(arr)); &#125;&#125; 其他方法 收集Stream流。就是把Stream流操作后的结果转回到集合或者数组中去返回。 Stream流：方便操作集合&#x2F;数组的手段； 集合&#x2F;数组：才是开发中的目的。 R collect(Collector collector)。把流处理后的结果收集到一个指定的集合中去。 Object[] toArray()。把流处理后的结果收集到一个数组中去。 collect具体的收集方式 public static Collector toList()。把元素收集到List集合中。 public static Collector toSet()。把元素收集到Set集合中。注意Set会去重。 public static Collector toMap(Function keyMapper , Function valueMapper)。把元素收集到Map集合中。注意需要在收集的时候指定键和值。而且它不能帮我们去重，因此可能报错，要自己在中间加一个distict()方法。 注意，流只能收集一次！不可以先用一个Steam对象接住Steam流，然后做两次收集操作。"},{"title":"【资源帖】学习Java和算法","path":"/2024/04/06/【资源帖】学习Java和算法/","content":"Java教程学习路线【黑马程序员】 Java简版基础教程：https://www.bilibili.com/video/BV1Cv411372m/ 书：《Java核心技术 1》 书：《Head First Java》 Java Web框架：https://www.bilibili.com/video/BV1m84y1w7Tb/ 单体项目开发： 苍穹外卖：https://www.bilibili.com/video/BV1TP411v7v6/ 微服务： 全套微服务技术栈：https://www.bilibili.com/video/BV1S142197x7/ 企业级项目实战（选择学习）： 学成在线【在线教育】：https://www.bilibili.com/video/BV1j8411N7Bm/ 黑马头条【企业级微服务项目】 ：https://www.bilibili.com/video/BV1Qs4y1v7x4/ 面试专题： 2023版：https://www.bilibili.com/video/BV1yT411H7YK/ 复制标题和时长：https://www.bilibili.com/read/cv22846057/ 精进指南 （JavaWeb后，选学）MySQL：https://www.bilibili.com/video/BV1Kr4y1i7ru/ （微服务后，选学）Redis微服务：https://www.bilibili.com/video/BV1cr4y1671t/ （微服务后，选学）MybatisPlus：https://www.bilibili.com/video/BV1Xu411A7tL/ （JVM前，必学）计算机网络：https://www.bilibili.com/video/BV1c4411d7jb/ （Java基础，选学）JVM虚拟机：https://www.bilibili.com/video/BV1r94y1b7eS/ （JVM后，选学）并发编程：https://www.bilibili.com/video/BV16J411h7Rd/ （git版本控制，选学）https://www.bilibili.com/video/BV1MU4y1Y7h5/ 资源帖 JavaGuide：JavaGuide（Java学习&amp;面试指南） | JavaGuide JavaBooks：https://gitee.com/itwanger/JavaBooks 拿个offer：拿个offer - 开源&amp;项目实战 (nageoffer.com) LeeCode刷题指南官网力扣 (LeetCode) 全球极客挚爱的技术成长平台 刷题指北peach买个共享会员账号看考察频次。 资源帖 labuladong：本站简介 | labuladong 的算法笔记（提升算法能力。） 代码随想录：代码随想录 (programmercarl.com)（全面，但是精简，适合面试突击。） 小林coding：小林coding (xiaolincoding.com)（图解好理解，但只有Redis、MySQL、计网。） 左程云：左程云的个人空间-左程云个人主页-哔哩哔哩视频 (bilibili.com)（算法讲解。） NeeCode：NeetCode（英文站点。） 推荐书单 《剑指offer》。"},{"title":"【求职】如何写一份受欢迎的校招简历","path":"/2024/04/05/【求职】如何写一份受欢迎的校招简历/","content":"常见问题 过度包装设计。减弱主要信息能量，华而不实。 篇幅过长。 求职定位不明。 实践经历描述不当。 一份简历闯天下。 JD：工作职责、工作胜任力。 使用表格式简历。 啰啰嗦嗦重点不突出。 不该讲的乱讲。例如，创业、离职原因、到岗时间、离婚、错误检讨、薪资条件。 优秀简历的特征版面设计简洁大方、布局清晰、模板分界。 简历结构结构完整、详略得当、易于阅读。 内容呈现逻辑清晰、优势突出、数据支撑。 人岗匹配有的放矢、贴近岗位JD、天生我才。 效果 脱颖而出、入得法眼。 顺畅读完，越读越喜欢。 打动人心，不如见一面。 为面试好印象做好铺垫。（面试官其实是根据初印象，步步求证是否确实是需要的人。） 简历的完整结构“2+2”通用的（非本专业&#x2F;技术岗）： 基本信息：略写。7%。 自我评价：较详。20%。 工作经历：详写。（大力气。）70%。 学历、证书、技能：略写。3%。 基本信息 姓名+求职意向+性别+年龄。（政治面貌：国企央企等写，外企不写，民企无所谓。） 联系方式：城市、电话、微信、邮箱。（不用写太多。城市可以写XX(意向城市)。联系方式三个必有一，推荐电话。） 个人照片：彩色、正面头像、有精气神。（匹配行业。） 自我评价&#x2F;教育背景社招： 工作背景。例如，年份+领域&#x2F;行业+擅长&#x2F;熟悉&#x2F;掌握。 优势能力。四条分号隔开。专业软件可以写。 职业素养。 校招： 起止时段：学校、专业、学历、学位。 主修课程。 奖学金可以写。 工作经历&#x2F;实习经历&#x2F;项目经历社招： 工作时段。（可以有总分，总的在某个公司，分的是不同岗位。最好是倒叙。） 工作职责。（前3-5个。） 工作业绩。（为了醒目，可以换个标志，比如五角星。一定要有数据，没数据也不要乱讲。） 工作获奖。（要有含金量的，行业、省市级以上，发明专利等。） 校招： 起止时段、公司、岗位。 工作职责、价值、奖项。 其他佐证 学历背景：学校、专业。 语言能力：语种、级别。（只是针对某些需要语言能力的岗位。其他：听说读写能力流利，可作为工作语言。） 专业技能：证书、级别。（例如岗位资格证。） 校招和社招的区别 教育背景前置&#x2F;后置。 自我评价的有无。（复盘能力。） 优秀简历写作心法人岗匹配！！！ 职场的本质是价值交换。（以终为始。） 见字如面，格式细节很重要，大小标题和逻辑关系。 凤头猪肚豹尾。自我评价漂亮客观，工作经历饱满有结果，其他佐证简短有力。 工作经历倒叙。写清楚总分，闭环表达，数据支撑。 工作年限5年以下，请用一张A4纸完成。 如果经历比较少，根据一段经历可以多挖掘，例如，“1+3+6+x”主轴。 如何准备 确定自己身份：校招&#x2F;社招，确定目标岗位，了解岗位JD。 准备模板，通读三遍。准备素材，多多益善。（所有经历都可以准备。） 现有骨架，再填充。时间倒叙，先粗后细。 先写草稿，反复打磨。"},{"title":"【Java基础】集合（Collection、List、Set）","path":"/2024/04/05/【Java基础】【java.util】集合（Collection、List、Set）/","content":"集合分类 单列集合（Collection）。元素是一个一个的。 双列集合（Map）。元素是一对一的。 单列集合（Collection）Collection集合体系 子接口List。 实现类ArrayList。 实现类LinkedList。 子接口Set。 实现类HashSet。 LinkedHashSet。 实现类TreeSet。 学习时要掌握的： 有什么特点？ 是否有特有功能？ 适合什么业务场景？ Collection集合特点List系列添加的元素有序、可重复、有索引。 ArrayList、LinkedList有序、可重复、有索引。 Set系列添加的元素无序、不重复、无索引。 HashSet。无序、不重复、无索引。 LinkedHashSet。有序、不重复、无索引。 TreeSet。按照大小默认升序排序、不重复、无索引。 Collection常用方法为什么要学？ 因为Collection是单列集合的祖宗，它规定的方法（功能）是全部单列集合都会继承的。 常用方法： public boolean add(E e)。把给定的对象添加到当前集合中 。由于允许数据重复，所以一定返回true。 public void clear() 。清空集合中所有的元素。 public boolean remove(E e)。把给定的对象在当前集合中删除。如果有多个重复元素只能删除第一个。 public boolean contains(Object obj)。判断当前集合中是否包含给定的对象。是精确匹配。 public boolean isEmpty()。判断当前集合是否为空。 public int size()。返回集合中元素的个数。 public Object[] toArray()。把集合中的元素，存储到数组中。Object类型是为了兼容各种类型的数据。 addAll(Collection&lt;? extends String&gt; c)。把另一个集合中的全部数据倒入，数据类型要一样。 Collection遍历方式1. 迭代器迭代器是用来遍历集合的专用方式(数组没有迭代器)，在Java中迭代器的代表是Iterator。 Collection集合获取迭代器的方法： **Iterator iterator()**。返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素。 从集合对象中获取迭代器对象。 判断当前位置是否有元素可以获取。不判断的话可能出现NoSuchElementException异常。 获取当前位置的元素，然后自动指向下一个元素。 1234567891011Collection&lt;String&gt; c = new ArrayList&lt;&gt;();c.add(&quot;赵敏&quot;);c.add(&quot;小昭&quot;);c.add(&quot;素素&quot;);c.add(&quot;灭绝&quot;);System.out.println(c); //[赵敏, 小昭, 素素, 灭绝]Iterator&lt;String&gt; it = c.iterator();while(it.hasNext())&#123; String e = it.next(); System.out.println(s);&#125; //判断一次，取一次 Iterator迭代器中的常用方法： boolean hasNext()。询问当前位置是否有元素存在，存在返回true ,不存在返回false。 E next()。获取当前位置的元素，并同时将迭代器对象指向下一个元素处。 2. 增强for为什么用增强的？因为Collection中没有规定集合的索引，只有List集合才支持索引。 格式：for (元素的数据类型 变量名 : 数组或者集合) { }。变量名相当于游标。（类似于Python中的for img in imgs这种写法。） 可以遍历集合或者数组。 遍历集合本质是迭代器遍历集合的简化写法。 简化写法：数组或集合**.for再回车**。 3. lambda表达式得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的方式来遍历集合。 方法：default void forEach(Consumer&lt;? super T&gt; action) 。结合lambda遍历集合。 举例： 123456789101112131415161718192021222324252627Collection&lt;String&gt; c = new ArrayList&lt;&gt;();c.add(&quot;赵敏&quot;);c.add(&quot;小昭&quot;);c.add(&quot;素素&quot;);c.add(&quot;灭绝&quot;);//调用forEach方法//由于参数是一个Consumer接口，所以可以传递匿名内部类c.forEach(new Consumer&lt;String&gt;&#123; @Override public void accept(String s)&#123; System.out.println(s); &#125;&#125;);//也可以使用lambda表达式对匿名内部类进行简化c.forEach((String s) -&gt; System.out.println(s);&#125;);c.forEach(s -&gt; System.out.println(s););c.forEach(s -&gt; System.out.println(s));c.forEach(System.out::println); //[赵敏, 小昭, 素素, 灭绝] lambda表达式遍历Collection集合不算简洁，之后遍历Map才是简洁。 (一)List集合ArrayList、LinkedList有序、可重复、有索引。但是底层数据结构不同（数据结构：存储、组织数据的方式），应用场景也不同。继承了Collection的功能。 创建（List是接口，所以需要指定具体的类）： 1List&lt;String&gt; list = new ArrayList&lt;&gt;();//经典代码，多态 常用方法List集合因为支持索引，所以多了很多索引相关的方法： void add(int index,E element)。在此集合中的指定位置插入指定的元素。不写索引的话，默认是插入到最后。 E remove(int index)。删除指定索引处的元素，返回被删除的元素。 E set(int index,E element)。修改指定索引处的元素，返回被修改的元素。 E get(int index)。返回指定索引处的元素。 List集合支持的遍历方式 普通for循环（只因为List有索引）。集合名.fori自动完成。 增强for&#x2F;foreach遍历。集合名.for自动完成。 迭代器。先创建迭代器，再判断并遍历。 Lambda表达式。forEach方法。 1234567891011121314151617181920212223242526List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;蜘蛛精&quot;);list.add(&quot;至尊宝&quot;);list.add(&quot;糖宝宝&quot;);//1.普通for循环for(int i = 0; i&lt; list.size(); i++)&#123; //i = 0, 1, 2 String e = list.get(i); System.out.println(e);&#125;//2.增强for遍历for(String s : list)&#123; System.out.println(s);&#125;//3.迭代器遍历Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String s = it.next(); System.out.println(s);&#125;//4.lambda表达式遍历list.forEach(s-&gt;System.out.println(s)); (1)ArrayList集合的底层原理基于数组实现的。 特点（查询快、增删慢）： 查询速度快（根据索引查询数据快）。查询数据通过地址值和索引定位，查询任意数据耗时相同。 删除效率低。可能需要把后面很多的数据进行前移。 添加效率极低。可能需要把后面很多的数据后移，再添加元素；或者也可能需要进行数组的扩容。 底层原理： 利用无参构造器创建的集合，会在底层创建一个默认查高难度为0的数组。 添加第一个元素时，底层会创建一个新的长度为10的数组。 存满时（添加第11个元素时），扩容1.5倍。 如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准。 应用场景： 适合：根据索引查询数据，比如根据随机索引取数据（高效），或者数据量不是很大时。 不适合：数据量大的同时，又要频繁地进行增删操作。 (2)LinkedList集合的底层原理基于双链表实现的（Java中大多数情况都使用双向链表）。 什么是链表？ 链表结构是由一个一个的节点组成，一个节点由数据值、下一个元素的地址组成。 链表中的结点是独立的对象，在内存中是不连续的，每个节点包含数据值和下一个节点的地址。 特点1：查询慢，无论查询哪个数据都要从头开始。 特点2：增删相对较快。但是对于首尾元素进行增删改查的速度是极快的。 LinkedList新增了一些可以针对头尾进行操作的方法： public void addFirst(E e)。在该列表开头插入指定的元素。 public void addLast(E e)。将指定的元素追加到此列表的末尾。 public E getFirst()。返回此列表中的第一个元素。 public E getLast()。返回此列表中的最后一个元素。 public E removeFirst()。从此列表中删除并返回第一个元素。 public E removeLast()。从此列表中删除并返回最后一个元素。 应用场景： 设计队列（特点：先进先出，后进后出）。队列只是在首尾增删元素。 入队。addLast方法。 出队。removeFirst方法。 设计栈（特点：先进后出，后进先出）。 进栈（压栈）。push方法（其实就是调用的addFirst方法）。 出站（弹栈）。pop方法（其实就是调用的removeFirst方法）。 (二)Set集合添加的元素无序、不重复、无索引。 HashSet。无序、不重复、无索引。 LinkedHashSet。有序、不重复、无索引。（是HashSet的子孙类。） TreeSet。按照大小默认升序排序、不重复、无索引。 创建（Set是接口，所以需要指定具体的类）： 1234//一行经典代码Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\t//无序、无索引、不重复（无序是指和添加元素的顺序无关）Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); //有序、无索引、不重复（有序是指和添加元素的顺序有关）Set&lt;Integer&gt; set = new TreeSet&lt;&gt;(); //可排序(升序)、无索引、不重复 常用方法要用的常用方法，基本上都是其父类Collection提供的。 (1)HashSet集合需要掌握的： 为什么添加的元素无序、不重复、无索引？ 增删改查数据有什么特点，适合什么场景？ 哈希值： 一个int类型的数值，Java中每个对象都有一个哈希值。 Java中的所有对象，都可以调用Object类提供的hashCode方法，返回该对象自己的哈希值。 对象哈希值的特点： 同一个对象多次调用hashCode()方法返回的哈希值是相同的。 不同的对象，哈希值一般不同，但也有可能相同（哈希碰撞）。 HashSet集合的底层原理 基于哈希表实现。 是一种增删改查性能都较好的数据结构。 JDK8以前：哈希表 &#x3D; 数组+链表 JDK8以后：哈希表 &#x3D; 数组+链表+红黑树 JDK8以前HashSet集合的底层原理： 创建一个默认长度为16的数组，默认加载因子为0.75，数组名table； 使用元素的哈希值对数组的长度求余计算出应存入的位置； 判断当前位置是否为null，如果是null直接存入； 如果不为null，表示有元素，则调用equals方法比较相等，则不存；不相等，则存入数据。 JDK8以前，新元素存入数组，占用老元素的位置，老元素挂下面； JDK8以后，新元素挂在老元素下面。 往HashSet集合中存储元素时，底层调用了元素的两个方法：一个是hashCode方法获取元素的hashCode值（哈希值）；另一个是调用了元素的equals方法，用来比较新添加的元素和集合中已有的元素是否相同。 只有新添加元素的hashCode值和集合中以后元素的hashCode值相同、新添加的元素调用equals方法和集合中已有元素比较结果为true, 才认为元素重复。 如果hashCode值相同，equals比较不同，则以链表的形式连接在数组的同一个索引为位置。–&gt;导致的问题：如果数组快占满了，链表过长，导致查询性能降低。–&gt;哈希表的扩容机制（占满加载因子0.75*长度就会扩容，扩容成原来数组的两倍）。 在JDK8以后的优化： 当链表的长度超过8，且数组长度超过64时，就会自动把链表转换为红黑树。 深入理解HashSet集合去重的机制注意：HashSet集合默认不能对内容一样的两个不同对象去重复！（因为不同对象哈希值不一样，因此存储位置不同，就会被认为不是重复的。） 如何让HashSet集合能够实现对内容一样的两个不同对象也能去重复？？？ 如果希望Set集合认为2个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法。 在类中**右键-generate-euqals() and hashCode()**，一路next。这里euqals方法只要两个对象内容一样就返回true，hashCode方法只要两个对象内容一样，返回的哈希值就是一样的。 (2)LinkedHashSet集合 有序、不重复、无索引。 基于哈希表（数组+链表+红黑树）实现的。 每个元素都额外的多了一个双链表的机制记录它前后元素的位置。增删改查比较快，但是也更占内存。 (3)TreeSet集合 排序、不重复、无索引。 基于红黑树实现的排序。增删改查性能较好。 对于数值类型：Integer , Double，默认按照数值本身的大小进行升序排序。 对于字符串类型：默认按照首字符的编号升序排序。 对于自定义类型如Student对象，TreeSet默认是无法直接排序的。 自定义排序规则 TreeSet集合存储自定义类型的对象时，必须指定排序规则，支持如下两种方式来指定比较规则。 排序方式1：让自定义的类（如学生类）实现Comparable接口，重写里面的compareTo方法来指定比较规则。但是要注意，如果值相等，就认为是重复的，只会保存一个对象！ 123456789101112131415161718192021222324252627282930//第一步：先让Student类，实现Comparable接口//注意：Student类的对象是作为TreeSet集合的元素的public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; private double height;\t//无参数构造方法 public Student()&#123;&#125; //全参数构造方法 public Student(String name, int age, double height)&#123; this.name=name; this.age=age; this.height=height; &#125; //...get、set、toString()方法自己补上.. //第二步：重写compareTo方法 //按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。 /* 原理： 在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的 结果是正数、负数、还是零，决定元素放在后面、前面还是不存。 */ @Override public int compareTo(Student o) &#123; //this：表示将要添加进去的Student对象 //o: 表示集合中已有的Student对象 return this.age-o.age; &#125;&#125; 排序方式2：通过调用TreeSet集合有参数构造器，可以设置Comparator对象（比较器对象，用于指定比较规则）。TreeSet自动选择自己自带的比较器对象进行排序。 12345678910111213141516171819202122232425262728//创建TreeSet集合时，传递比较器对象排序/*原理：当调用add方法时，底层会先用比较器，根据Comparator的compare方是正数、负数、还是零，决定谁在后，谁在前，谁不存。*///下面代码中是按照学生的年龄升序排序Set&lt;Student&gt; students = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;&#123; @Override public int compare(Student o1, Student o2)&#123; //需求：按照学生的身高排序 return Double.compare(o1,o2); &#125;&#125;);//可以用lambda表达式简化//Set&lt;Student&gt; students = new TreeSet&lt;&gt;(o1,o2)-&gt;Double.compare(o1.getHeight(), o2.getHeight()));//创建4个Student对象Student s1 = new Student(&quot;至尊宝&quot;,20, 169.6);Student s2 = new Student(&quot;紫霞&quot;,23, 169.8);Student s3 = new Student(&quot;蜘蛛精&quot;,23, 169.6);Student s4 = new Student(&quot;牛魔王&quot;,48, 169.6);//添加Studnet对象到集合students.add(s1);students.add(s2);students.add(s3);students.add(s4);System.out.println(students); 总结 如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据？ 用ArrayList集合（有序、可重复、有索引），底层基于数组的。（常用） 如果希望记住元素的添加顺序，且增删首尾数据的情况较多？ 用LinkedList集合（有序、可重复、有索引），底层基于双链表实现的。 如果不在意元素顺序，也没有重复元素需要存储，只希望增删改查都快？ 用HashSet集合（无序，不重复，无索引），底层基于哈希表实现的。 （常用） 如果希望记住元素的添加顺序，也没有重复元素需要存储，且希望增删改查都快？ 用LinkedHashSet集合（有序，不重复，无索引）， 底层基于哈希表和双链表。 如果要对元素进行排序，也没有重复元素需要存储？且希望增删改查都快？ 用TreeSet集合，基于红黑树实现。 注意事项：集合的并发修改异常问题集合的并发修改异常并发：多件事正在进行。 使用迭代器遍历集合时，又同时在删除集合中的数据，程序就会出现并发修改异常的错误。 原因：其实和之前用for循环的时候差不多，索引没有减1的话会导致有些元素没被删掉，但是迭代器知道程序员有可能出现这个错误，所以报了一个善意的提醒。 解决方法：不能用集合对象自己去删除数据。使用迭代器的remove方法。（现在一共学了3种方法：1. 每次减1，2. 倒着遍历，3. 用迭代器去删。） 由于增强for循环遍历集合就是迭代器遍历集合的简化写法，因此，使用增强for循环遍历集合，又在同时删除集合中的数据时，程序也会出现并发修改异常的错误。 原因：增强for循环相当于迭代器简化写法，但是又拿不到迭代器。类似地，使用lambda表达式也会出现这个问题，因为其内部使用的是增强for循环。 怎么保证遍历集合同时删除数据时不出bug？ 使用迭代器遍历集合，但用迭代器自己的删除方法删除数据即可。 如果能用for循环遍历时：可以倒着遍历并删除；或者从前往后遍历，但删除元素后做i–操作。 Collection集合其他知识可变参数就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型…参数名称。 可变参数的特点和好处 特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。 好处：常常用来灵活的接收数据。 可变参数的注意事项 可变参数在方法内部就是一个数组。 一个形参列表中可变参数只能有一个。 可变参数必须放在形参列表的最后面。 Collections一个用来操作集合的工具类。 提供的静态方法 public static boolean addAll(Collection&lt;? super T&gt; c, T… elements)。给集合批量添加元素。 public static void shuffle(List&lt;?&gt; list) 。打乱List集合中的元素顺序。 public static void sort(List list)。对List集合中的元素进行升序排序。 public static void sort(List list，Comparator&lt;? super T&gt; c)。对List集合中元素，按照比较器对象指定的规则进行排序。 后两个是排序方法，3可以直接对自定义类型的List集合排序，但自定义类型必须实现了Comlarable接口，指定了比较规则才可以。 综合案例斗地主。"},{"title":"【Java基础】面向对象进阶：static、继承、单例","path":"/2024/04/04/【Java基础】面向对象进阶：static、继承、单例/","content":"静态（static）修饰成员变量或成员方法。 static修饰成员变量按照有无static修饰，成员变量分为： 有–&gt;类变量（静态变量）。属于类，在计算机中只有一份，被类的全部对象共享。通过类名调用：类名.静态变量。 无–&gt;实例变量。属于每个对象。 static修饰成员方法"},{"title":"【Java基础】lambda表达式、方法引用、算法、正则表达式","path":"/2024/04/04/【Java基础】【java.lang】lambda表达式、方法引用、算法、正则表达式/","content":"Arrays类（了解）操作数组的一个工具类。 常见方法： public static String toString(类型[] arr)。可以接收任意类型的数据，返回数组的内容。 public static 类型[] copyOfRange(类型[] arr, 起始索引, 结束索引)。拷贝数组（指定范围，包前不包后）。 public static copyOf(类型[] arr, int newLength)。拷贝数组。通常用作数组扩容。 public static setAll(double[] array, IntToDoubleFunction generator)。把数组中的原数据改为新数据。注意 IntToDoubleFunction generator程序可以自动帮忙重写，重写时的参数value就是数组的索引。 public static void sort(类型[] arr)。对数组进行排序(默认是升序排序)。 如果数组是对象数组。直接调用sort会报错。需要指定排序规则。 方式1：让该对象的类实现Comparable(比较规则)接口，然后重写compareTo方法，自己来制定比较规则。官方约定：①左边对象大于右边对象，返回正整数，②小于，负整数，③等于，返回0。可以用if+else语句，或者直接返回this.x-0.x（前提是int类型）。 方式2：使用下面这个sort方法，创建Comparator比较器接口的匿名内部类对象，然后自己制定比较规则。public static void sort(T[] arr, Comparator&lt;? super T&gt; c) ：对数组进行排序(支持自定义排序规则）。 接收参数1：需要排序的数组； 接受参数2：Comparator比较器对象（用来指定对象的比较规则）。程序可以自动帮忙写。对象为o1、o2。约定和实现方法方式1中一样。补充一点，如果是Double类型的比较，可以返回Double.compare(o1.getxx(), o2.getxx())。 JDK8新特性：Lambda表达式Lambda表达式是JDK 8开始新增的一种语法形式。 作用：用于简化匿名内部类的代码写法。 格式：（被重写方法的形参列表）-&gt;{被重写方法的方法体代码}。 注意：Lambda表达式并不能简化全部匿名内部类的写法，只能简化函数式接口的匿名内部类。 什么是函数式接口？ 有且只有一个抽象方法的接口。 注意：将来我们见到的大部分函数式接口，上面都可能会有一个@FunctionalInterface的注解，有该注解的接口就必定是函数式接口。 Lambda表达式的省略规则： 参数类型可以省略不写。 如果只有一个参数，参数类型可以省略，同时()也可以省略。 如果Lambda表达式中的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号！此时，如果这行代码是return语句，也必须去掉return不写。 JDK8新特性：方法引用"},{"title":"【Java基础】API高级","path":"/2024/04/03/【java基础】【java.lang】【java.util】Object类、数学、时间等/","content":"Object类类层次结构的根。所有类都默认继承Object类。 public String toString()返回对象的字符串表达形式。 直接打印对我们意义不大，一般是重写toString()以便返回对象的内容。 重写方法：①右键-generate-toString()，②写toS自动生成。 public boolean equals(Object o)指示某个其他对象是否“等于”此对象。 默认是判断两个对象的地址是否相等。但在开发中，这个功能用“&#x3D;&#x3D;”也能实现。 在开发中也是为了让子类重写，比较两个对象的内容一样。 重写方法：写eq自动生成，反复回车即可。 原理：比较者是this，被比较者是o。①首先判断两个对象是否地址一样，一样直接返回true，②判断o是null直接返回false，或者比较者和被比较者的类型不同，返回false，③o不是null，且o一定是相同类型的对象，就开始比较内容。将o强制转换为比较者类型，然后比较。 public String clone()创建并返回对象的副本。 由protected修饰，也就是只能在当前包（java.lang）、Object子类中才能访问。 要使用clone()方法，必须要在子类中重写该方法。再通过它中转调用父类的克隆方法。 重写方法：在子类中输入“clon”自动创建。这里是super去调用父类Object。克隆出来返回Object对象。 注意：不是所有类都能克隆。克隆的话还要让子类实现一个接口（implements Clonable）。这个接口里面啥都没，称为标记接口（规则）。实例调用clone()的时候会报错，暂时可以“Alt+Enter”选择第一个，此时自动在main方法后面加上了“throws CloneNotSupportedException”。 Java中有两种克隆：浅克隆（上述）、深克隆。 浅克隆：拷贝出的新对象和原对象中的数据一模一样（引用类型拷贝的只是地址，所以指向的是一样的内容）。 深克隆： 对象中的基本类型的数据直接拷贝。 对象中的字符串数据拷贝地址。 对象中包含的其他对象，不拷贝地址，创建新对象。 Objects类一个工具类，提供了很多操作对象的静态方法。 equals(Object a, Object b)先做非空判断，再比较两个对象。 为什么官方选择Objects.euqals(s1,s2)而不是s1.equals(s2)呢？避免s1为null时的报错。 isNull(Object obj)判断对象是否为null，为null返回true，反之。 其实和“对象&#x3D;&#x3D;null”效果一样，看起来高级。 nonNull(Object obj)判断对象是否不为null，不为null返回true，反之。 其实和“对象!&#x3D;null”效果一样，看起来高级。 包装类为什么要有？ 因为基本类型数据不是对象。为了实现“万物皆对象”，所以使用包装类用来把基本类型的数据包装成对象。 基本数据类型 对应的包装类（引用数据类型） byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 如何包装的？ valueOf(int i)：例如，Integer a1 &#x3D; Integer.valueOf(12); Java中为了方便把基本类型的数据转换成对象，提供了两种方案： 自动装箱机制（自动把基本类型数据转换为对象）。例如，Integer a2 &#x3D; 12; 自动拆箱（自动把包装类型对象转换为基本数据类型）。例如，int a3 &#x3D; a2; 为什么重要？ 泛型和集合不支持基本数据类型，只支持引用数据类型。例如，Arraylist对而Arraylist错误。 包装类有什么特殊的方法？ 把基本类型的数据转换为字符串类型。例如，Integer a &#x3D; 23; String rs1 &#x3D; Integer.toString(a);和String rs2 &#x3D; a.toString();的效果一样。（也可以用String rs3 &#x3D; a + “”，所以这个方法应用不多。） 把字符串类型的数值转换成数值本身对应的数据类型。例如，String ageStr &#x3D; “29”; int ageI &#x3D; Integer.parseInt(ageStr);&#x2F;&#x2F;String scoreStr &#x3D; “99.5”; double score &#x3D; Double.parseDouble(scoreStr );。这样其实是麻烦的，直接使用valueOf，例如，int ageI &#x3D; Integer.valueOf(ageStr);只需要记住一个函数即可。 注意：转换前的数值一定要是对应类型，否则报错。 StringBuilder类可变字符串对象。相当于一个容器，里面装的字符串是可以变的。用来操作字符串。 为什么要有（好处）？ 比String更适合做字符串修改的操作，效率更高，代码更简洁。 构造器 无参构造器。public StringBuilder()。创建一个空白的可变字符串对象，不包含任何内容。 有参构造器。public StringBuilder(String str)。创建一个指定字符串内容的可变字符串对象。 常用方法 public StringBuilder append(任意类型)。添加数据并返回StringBuilder 对象本身。 拼接内容。支持链式编程，例如，s.append(666).append(“hello”);。 public StringBuilder reverse()。将对象的内容反转。 反转操作。 public int length()。返回对象内容长度。 public String toString()。把StringBuilder对象又转换成String类型。 为什么操作字符串建议使用StringBuilder，而不用原来学过的String? 效率高。 对于字符串相关操作，如果频繁拼接、修改等，建议用StringBuilder，效率高。如果字符串较少，或者不需要操作，以及定义字符串变量，建议用String。 案例设计一个方法，用于返回任意整型数组的内容，要求返回的数组内容格式如下：[11, 22, 33]。（需要用if判断是否到最后一个元素以确定数字后面的符号。） StringBuffer类与StringBuilder用法一样。但是StringBuilder是线程不安全的，StringBuffer是线程安全的。（就是很多人进入系统来用StringBuffer编程时不会出bug。） StringJoiner类解决的问题：StringBuiler虽然速度上去了，但是代码层面很麻烦（如前例，还要if来判断）。怎么高效、方便地拼接？ JDK8开始才有，和StringBuiler类似。 好处：提高字符串的操作效率，在某些场景下代码更加简洁。 构造器 public StringJoiner(间隔符号)。创建StringJoiner对象，指定拼接时的间隔符号。 public StringJoiner(间隔符号，开始符号，结束符号)。创建StringJoiner对象，指定拼接时的间隔符号、开始符号、结束符号。 常用方法 public StringJoiner add(添加的内容)。添加数据，返回对象本身。 public int length()。返回长度（字符串出现的个数）。 public String toString()。返回一个字符串（该字符串就是拼接之后的结果）。 因此，可以将输出数组格式的代码简化。 Math类数学，是一个工具类。提供对数据进行操作的静态方法。 常见方法 public static int abs(int a)、public static double abs(double a)。获取参数绝对值。 public static double ceil(double a)。向上取整。 public static double floor(double a)。向下取整。 public static int round(float a)。四舍五入。 public static int max(int a, int b)。获取两个int值中的较大值。 public static double pow(double a, double b)。返回a的b次幂的值。 public static double random()。返回值为double的随机值，范围[0.0, 1.0)。 System类（了解）程序所在的系统。工具类。 常见方法 public static void exit(int status)。终止当前运行的Java虚拟机。 该参数用作状态代码；按照惯例，非零状态代码表示异常终止。 System.exit(0); &#x2F;&#x2F;人为地终止虚拟机（不要使用）。 public static long currentTimeMills()。返回当前系统的时间毫秒值形式。从1970-1-1 0:0:0开始（小知识：为啥是这个时间开始？C语言的生日。）到此刻的毫秒值。 通常用作代码的性能分析。 想转换成秒数:time&#x2F;1000.0。 Runtime类（了解）程序所在的运行环境。是单例类。通过调用getRuntime()方法来得到对象。 常见方法 public static Runtime getRuntime()。返回与当前Java应用程序关联的运行时对象。 public void exit(int status)。终止当前运行的虚拟机。该参数用作状态代码。按照管理，非零状态码表示异常终止。（其实System类里面的exit方法就是调用的这里。） public int availableProcessors()。返回Java虚拟机可用的处理器数。 public long totalMemory()。返回Java虚拟机中的内存总量。返回的是字节数，想看多少K，除以1024.0，多少M，再除以1024.0。 public long freeMemory()。返回Java虚拟机中的可用内存。返回的是字节数。 public Process exec(String command)。启动某个程序，并返回代表该程序的对象。 用法：拷贝exe程序的路径（右键-属性-安全-对象名称），作为参数传给exec。此时报异常，用“Alt+Enter”选第一个，自动抛出异常（在类定义处增加throw IOException）。程序就会帮我们打开指定的exe程序。 多说一点，可以直接传程序名，前提是系统环境变量里面配置程序的路径。 用Process类定义一个变量来接返回的程序对象，接到之后用destroy()方法关闭程序。 BigDecimal类解决浮点型运算时，出现结果失真的问题（如，0.1+0.2的结果不是0.3）。 构造器public BigDecimal(String val)。把String转成BigDecimal。是按照对应位置运算的。 常用方法 public static BigDecimal valueOf(double val)。转换一个double成BigDecimal。 public BigDecimal add(BigDecimal b)。加法。 public BigDecimal substract(BigDecimal b)。减法。 public BigDecimal multiply(BigDecimal b)。乘法。 public BigDecimal devide(BigDecimal b)。除法。 public BigDecimal devide(另一个BigDecimal对象，精确几位，舍入模式)。除法，可以控制精确到小数几位。 public BigDecimal doubleValue()。将BigDecimal转换为double。 推荐方式：使用时先toString()变成字符串对象，封装成BogDecimal对象，再运算。&#x2F;&#x2F;或者调用valueOf进行简化。即BigDecimal a1 &#x3D; new BigDecimal (Double.toString(a))简化为BigDecimal a1 &#x3D; BigDecimal.valueOf(a)。 做除法运算时，如果不能正好表达，就会报无法精确表达结果的错，所以就要用第二种除法方法。这只是解决精度问题的手段，最后还要转换为double类型的数据。 注意：一般不用构造方法BigDecimal(double)的方式把double值转化为BigDecimal对象，因为存在精度损失风险，可能导致业务逻辑异常。有限推荐入参为String的构造方法，或者使用BigDecimal的valueOf方法，此方法内部执行了Double的toString，而Double的toString按double的实际能表达的精度对尾数进行了截断。 日期和时间（JDK8之前）Date类系统的日期和时间。（可以直接打印出来。） 构造器 public Date()。 创建一个Date对象，代表的是系统当前此刻日期时间。 public Date(long time)。 把时间毫秒值转换成Date日期对象。 常用方法 public long getTime()。返回从1970年1月1日 00:00:00走到此刻的总的毫秒数。 public void setTime(long time)。设置日期对象的时间为当前时间毫秒值对应的时间。 SimpleDateFormat类简单日期格式化，可以用来把日期对象、时间毫秒值格式化成我们想要的形式。 允许格式化（日期-文本）、解析（文本-日期）和规范化。 时间格式： xxxx-xx-xx xx:xx:xx。 可以将Date或者时间毫秒值转化为上述格式。 构造器public SimpleDateFormat(String pattern)。创建简单日期格式化对象，并封装时间的格式。可以自己看文档组装成想要的格式，例如，“yyyy-MM-dd HH:mm:ss EEE a”。 常用方法 public final String format(Date date)。将日期格式化成日期&#x2F;时间字符串。 public final String format(Object time)。将时间毫秒值式化成日期&#x2F;时间字符串。 即，这个函数既可以扔进来一个SimpleDateFormat类，也可以直接扔进来系统时间毫秒值。 public Date parse(String source)。把字符串时间解析成日期对象。 使用：①创建SimpleDateFormat对象，指定的时间格式必须与被解析的时间格式一模一样；②把字符串扔到SimpleDateFormat对象中用parse()方法解析。此时还是要用“Alt+Enter”把异常抛出去。 常见符号y年，M月，d日，H时，m分，s秒，EEE星期几，a上午&#x2F;下午。 Calendar类系统此刻时间对应的日历。 通过它可以单独获取、修改时间中的年、月、日、时、分、秒等。（注意月是从0开始的。） 是一个抽象类。要用的话需要找它的子类（实现类）。 calendar是可变对象，一旦修改后其对象本身表示的时间将产生变化。 为什么要学习？ 从一个案例说起，需求是将2023年09月10日增加一个月。常用做法是：1、记住字符串，2、解析成Date日期对象，3、通过日期对象获取毫秒值，4、增加一个月的毫秒值，5、格式化得到结果。 常用方法 public static Calendar getInstance()。获取当前日历对象。 public int get(int field)。获取日历中的某个信息。例如，.get(Calendar .YEAR); public final Date getTime()。获取日期对象。 public long getTimeInMillis()。获取时间毫秒值。 public void set(int field,int value)。修改日历的某个信息。 public void add(int field,int amount)。为某个信息增加&#x2F;减少指定的值。 JDK8开始新增的日期、时间为什么要学？（Java开发者的bug。） JDK8之前传统的时间API：1、设计不合理，使用不方便，很多都被淘汰了。2、都是可变对象，修改后会丢失最开始的时间信息。3、线程不安全。4、只能精确到毫秒。 JDK8开始之后新增的时间API：1、设计更合理，功能丰富，使用更方便。2、都是不可变对象，修改后会返回新的时间对象，不会丢失最开始的时间。3、线程安全。4、能精确到毫秒、纳秒。 代替Calendar类 LocalDate：本地日期（年、月、日、星期）。这是一个不可变对象。 public static Xxxx now()。获取系统当前时间对应的该对象。 public static Xxxx of(…)。获取指定时间的对象。例如，getYear()、getMonthValue()、getDayOfMonth()、getDayOfYear()、getDayOfWeek()等。 withYear、withMonth、withDayOfMonth、withDayOfYear。直接修改某个信息，返回新日期对象。 plusYears、plusMonths、plusDays、plusWeeks。把某个信息加多少，返回新日期对象。 minusYears、minusMonths、minusDays，minusWeeks。把某个信息减多少，返回新日期对象。 equals、isBefore、isAfter：判断两个日期对象，是否相等，在前还是在后 。LocalDate.of：获取指定日期的LocalDate对象。public static LocalDate of(int year, int month, int dayOfMonth)。 LocalTime：本地时间（时、分、秒、纳秒）。这是一个不可变对象。 public int getHour()、public int getMinute()、public int getSecond()、public int getNano()。获取小时、秒、纳秒。 withHour、withMinute、withSecond、withNano。修改时间，返回新时间对象。 plusHours、plusMinutes、plusSeconds、plusNanos。把某个信息加多少，返回新时间对象。 minusHours、minusMinutes、minusSeconds、minusNanos。把某个信息减多少，返回新时间对象。 equals、isBefore、isAfter：判断2个时间对象，是否相等，在前还是在后。 LocalDateTime：本地日期、时间（年、月、日、星期、时、分、秒、纳秒）。这是一个不可变对象。 方法综合前两个。 特殊的：可以把LocalDateTime转换成LocalDate和LocalTime，使用toLocalDate()和toLocalTime()方法。而用LocalDateTime.of(LocalDate ld, LocalTime lt)可以再把它们合起来。 ZoneId：时区Id。 常识：世界标准时间(UTC)是0时区，中国标准时间是世界标准时间(UTC) + 8小时。 表达方式：洲名&#x2F;城市名，国家名&#x2F;城市名。 常见方法： public static Set getAvailableZoneIds()。获取Java中支持的所有时区。（如果不记得时区Id怎么写可以调用这个看一下。） public static ZoneId systemDefault()。获取系统默认时区。然后可以用getId()方法&#x2F;直接打印获取当前系统的默认时区。 public static ZoneId of(String zoneId)。将指定时区Id封装成ZoneId对象。结合下面的ZonedDateTime使用。 ZonedDateTime：带时区的时间。 常见方法： public static ZonedDateTime now() 。获取当前时区的ZonedDateTime对象。 public static ZonedDateTime now(ZoneId zone) 。获取指定时区的ZonedDateTime对象。例如传入Clock.systemUTC()参数获取世界标准时间。 getYear、getMonthValue、getDayOfMonth、getDayOfYeargetDayOfWeek、getHour、getMinute、getSecond、getNano。获取年月日、时分秒、纳秒等。 public ZonedDateTime withXxx(时间) 。修改时间系列的方法。 public ZonedDateTime minusXxx(时间) 。减少时间系列的方法。 public ZonedDateTime plusXxx(时间)。增加时间系列的方法。 代替Date类 Instant：时间戳&#x2F;时间线。是一个不可变对象。 通过获取Instant的对象可以拿到此刻的时间，该时间由两部分组成：从1970-01-01 00:00:00 开始走到此刻的总秒数 + 不够1秒的纳秒数。 可以用来记录代码的执行时间，或用于记录用户操作某个事件的时间点。传统的Date类，只能精确到毫秒，并且是可变对象；新增的Instant类，可以精确到纳秒，并且是不可变对象，推荐用Instant代替Date。 常用方法： public static Instant now()。获取当前时间的Instant对象（标准时间）。 public long getEpochSecond()。获取从1970-01-01T00：00：00开始记录的秒数。 public int getNano()。从时间线开始，获取从第二个开始的纳秒数 。 plusMillis plusSeconds plusNanos。增加时间系列的方法。 minusMillis minusSeconds minusNanos。减少时间系列的方法。 equals、isBefore、isAfter。判断时间系列的方法。 代替SimpleDateFormat类 DateTimeFormatter：用于时间的格式化和解析。（线程安全。） 常用方法： public static DateTimeFormatter ofPattern(时间格式)。获取格式化器对象。 public String format(时间对象)。格式化时间。 public String format(DateTimeFormatter formatter)。格式化时间。 public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)。解析时间。 正向格式化：formatter.format(now)，反向格式化：now.format(formatter)。得到的结果是一样的。 LocalDateTime提供的格式化、解析时间的方法： public String format(DateTimeFormatter formatter)。格式化时间。 public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)。解析时间。 其他补充 Period:时间间隔（年，月，日）。用于计算两个 LocalDate对象相差的年数、月数、天。注意先写较前的时间，再写较后的时间。 public static Period between(LocalDate start, LocalDate end)。传入2个日期对象，得到Period对象。 public int getYears()。计算隔几年，并返回。 public int getMonths()。计算隔几个月，年返回。 public int getDays()。计算隔多少天，并返回。 Duration:时间间隔（时、分、秒，纳秒）。计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant等时间。 public static Duration between(开始时间对象1,截止时间对象2)。传入2个时间对象，得到Duration对象。 public long toDays()。计算隔多少天，并返回。 public long toHours()。计算隔多少小时，并返回。 public long toMinutes()。计算隔多少分，并返回。 public long toSeconds()。计算隔多少秒，并返回。 public long toMillis()。计算隔多少毫秒，并返回。 public long toNanos()。计算隔多少纳秒，并返回。"}]