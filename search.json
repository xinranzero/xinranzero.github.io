[{"title":"【Go基础】分布式事务","path":"/2025/03/23/【Go基础】分布式事务/","content":"从几个缩写讲起首先，提到事务，一般指的是数据库的事务，指逻辑上的一组操作，要么都执行，要么都不执行。 ACID，指的是数据库在写入或者更新资料时，为了保证交易正确可靠，要具备的4个特性： 缩写 英文单词 中文解释 说明 A atomicity 原子性 最小执行单位，all or nothing C consistency 一致性 执行前后一致 I isolation 隔离性 并发时，事务间不干扰 D durability 持久性 持久改变 这里要特别注意，C一致性是最终的目的，其余三个是实现C的手段。 接下来是分布式事务，与微服务密切相关，因为不同的微服务一般会使用自己的数据库，这个时候要满足ACID就比较困难了，如何保证系统中多个相关联的数据库中的数据一致？ 此时，需要选择折中的方案，为此，引进了CAP理论： 缩写 英文单词 中文解释 说明 C consistency 一致性 所有节点访问同份最新数据副本 A availability 可用性 非故障节点在合理时间返回合理响应 P partition tolerance 分区容忍性 出现网络分区时仍对外提供服务 一个分布式系统在读写操作时，假设出现了网络分区，只能满足两个，即CP或者AP。这里要特别注意，如果没有出现网络分区，A和C是可以同时满足的。常用的注册中心中，Zookeeper保证了CP，Eureka保证了AP，Nacos二者都支持。 在C和A的权衡实践中，诞生了BASE理论： 缩写 英文单词 中文解释 说明 B basically available 基本可用性 允许损失部分可用性（响应时间延长，损失部分非核心功能等） A availability 可用性 S soft-state 软状态 允许数据不一致，不影响整体可用性 E eventually consistent 最终一致性 一致的三个级别 这里需要理清一致性的3个级别： 强一致性：在银行等场景需要保证； 弱一致性：什么时候达到一致的状态完全没有保证； 最终一致性：系统保证在一定时间内达到一致，业界比较推崇，那么如何保证最终一致性： 读时修复 写时修复（性能好） 定期修复（常用） 分布式事务的解决方案&#x2F;&#x2F; 待补充学习 —-某天职场老兵William突然抽查我的八股基础，回来赶紧灰溜溜补上……"},{"title":"【技术思考】工程上的最佳实践","path":"/2025/03/23/【技术思考】工程上的最佳实践/","content":"正式进入工作岗位之前对精进技术的思考——工程上的最佳实践 Why？首先要理解为什么要从工程实践的角度思考，常规的培训教程虽然是以项目的形式，但目的是帮助我们学会使用基本的开发工具如何使用，而实际开发过程中如何将各种技术组件有效地组合和应用、如何解决实际的业务问题，则是进一步需要关注的问题。 How？以原有的点评项目为例进行思考，可以考虑各部分设计的原因，能否优化： 消息中间件：思考使用场景，如订单状态更新、用户评价通知等，分析为什么要使用消息中间件，以及如何设计消息的生产、消费和存储。 缓存：考虑缓存的使用场景，如热门商品信息缓存、用户会话缓存等，分析如何识别并处理热key，以及缓存的更新和失效策略。 数据库设计与优化：审视数据库表的设计是否合理，是否符合业务需求，以及如何通过索引优化、查询优化等手段提升数据库性能。 微服务架构：分析拆分是否合理，服务之间的依赖关系是否清晰，服务降级、熔断和负载均衡策略是否有效。 服务上线：如何上线，例如灰度发布中的流量染色，如何保证服务的高可用性。 以微服务为例进行思考，考虑从调用和原理到设计决策的转变： 之前学习时，重点可能放在了如何调用中间件以及它们的底层原理上。 现在需要将重心转移到：在给定业务场景下，为什么要这样设计这些组件。 例如，微服务的负载均衡、服务发现、降级熔断等模块，不仅要清楚它们的作用，更要结合业务场景思考如何拆分微服务，以及制定相应的服务降级、熔断和负载均衡策略。以分布式事务为例，虽然有TCC、二阶段提交等理论方案，但在实际开发中，这些方案的严格实现需要很多条件支持，如数据库的兼容性、业务操作的反向接口等。在实际生产中，接口可能无法完美支持这些理论方案，这时需要考虑其他方法，如对账机制，来保证最终一致性，尤其是在对强一致性要求不高的业务场景中。以对账机制的工程实践为例，可能在实现最终一致性的时间间隔上较长，但其泛用性广且易于实现，设计对账机制需要考虑如何在业务执行频率较低时进行对照，以及如何处理幂等性等问题。 在上述思考过程中，可以借鉴大众点评、美团外卖、饿了么、滴滴等成熟项目的技术文章，了解它们在工程实践中的经验和教训。思路放宽，例如，各大应用基本都有点赞模块，了解它们是如何实现的，筛选出和自己的项目比较贴合的部分深入研究。 例如，大众点评在订单系统分库分表实践中的垂直切分和水平切分策略，以及如何通过Hash切分实现数据的均匀分布和易于扩展的架构。 DDD在大众点评交易系统演进中的应用 2-大众点评内容平台架构实践-三木 大众点评订单系统分库分表实践 了解了实践中的技术原理之后，再进一步关注通用方法论的提炼： 第一个是基础架构平台层面。例如，分布式ID发号器（如Leaf）、热Key检测与治理、大文件分布式对象存储（如JFS）等，理解这些通用实践，为自己的项目提供参考和借鉴，提升解决实际问题的能力。 第二个是思想层面。例如，在无法控制仓库报送数据的情况下，通过数据分析确定需要特殊处理的仓库，采用简单粗暴但有效的硬编码方式解决问题。此处提炼的方法论是：当技术手段难以直接解决问题时，可以通过分析实际数据和业务场景，找到变通的非技术性方法来绕过技术难题。 以上为主线任务，接下来是支线任务，即提前了解部门技术栈和业务后，例如云原生相关可以了解： Kubernetes稳定性保障实践 AutoMQ官方账号 —-与职场老兵William的对话整理"},{"title":"【通用工具】Git分布式版本控制工具","path":"/2025/03/21/【通用工具】Git分布式版本控制工具/","content":"Git有两个基本作用: 版本控制 团队开发 一、Git工作流程 二、Git基本配置设置用户信息设置：（+如果要查看，只输入双引号前面的就好了） 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 有3种范围：--local只对某个仓库有效，--global对当前用户的所有仓库有效，--system对系统所有登录的用户有效。 要显示config的配置，加--list。 三、Git基本使用获取本地仓库git init，执行之后工作目录下就会产生.git隐藏目录。 核心操作 clone（克隆）: 从远程仓库中克隆代码到本地仓库 checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订 add（添加）: 在提交前先将代码提交到暂存区 可以接单个文件名，也可以接通配符 commit（提交）: 暂存区 –&gt; 本地仓库。本地仓库中保存修改的各个历史版本 可以接-m后跟注释 fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少 pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库 辅助查看与操作 git status：查看修改的状态 git log [option]：查看提交日志，git-log以精简形式查看 git log：以默认形式查看提交日志 git log --all：显示所有分支的提交日志 git log --pretty=oneline：将提交信息显示为一行 git log --abbrev-commit：使得输出的 commitId 更简短 git log --graph：以图的形式显示提交历史，便于查看分支合并情况 git reflog commitID：记录所有操作，可以回滚到任意地方 git reset --hard commitID：版本回退 添加文件到忽略列表：创建 .gitignore 文件，列出要忽略的文件模式 回滚如果在开发过程中，某个需求不需要了，此时分为3种情况讨论： 文件在工作区：执行git checkout file 文件在暂存区：执行git reset HEAD file，让这个文件回到工作区，然后执行1 文件在本地仓库：执行git reset -方式（有3种） hard：工作区、暂存区、本地仓库3个地方保持一致 mixed：让文件保存在工作区 soft：让文件保存在暂存区 四、Git分支核心操作 查看本地分支：git branch 创建本地分支：git branch 分支名 切换分支：git checkout 分支名 可以直接切换到一个不存在的分支（创建并切换）：git checkout -b 分支名 合并分支：git merge 分支名称，一个分支上的提交可以合并到另一个分支 删除分支：不能删除当前分支，只能删除其他分支 git branch -d b1 删除分支时，需要做各种检查 git branch -D b1 不做任何检查，强制删除 解决冲突步骤： 处理文件中冲突的地方 将解决完冲突的文件加入暂存区(add) 提交到仓库(commit) GitFlow master （生产） 分支：线上分支，主分支，中小规模项目作为线上运行的应用对应的分支； develop（开发）分支：是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线； feature/xxxx分支：从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支； hotfix/xxxx分支：从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、develop分支； 还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。 五、Git远程仓库基本命令 对接远程仓库： git remote add &lt;远端名称&gt; &lt;仓库路径&gt; 查看远程仓库： git remote 推送到远程仓库：git push [-f] [--set-upstream] [远端名称 [本地分支名]:[远端分支名]] 如果远程分支名和本地分支名称相同，则可以只写本地分支git push origin master -f 表示强制覆盖 --set-upstream 推送到远端的同时并且建立起和远端分支的关联关系 如果当前分支已经和远端分支关联，则可以省略分支名和远端名 查看本地分支与远程分支的关联关系：git branch -vv 从远程仓库克隆：git clone &lt;仓库路径&gt; [本地目录] 从远程仓库抓取&#x2F;拉取：（如果不指定远端名称和分支名，就抓取所有分支） git fetch [remote name] [branch name]：将仓库里的更新都抓取到本地，不进行合并。 git pull [remote name] [branch name]：将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 解决冲突远程分支也是分支，解决冲突的方式和本地相同（看上文）。 需要先拉取远程仓库的提交，经过合并后才能推送到远端分支： 六、进阶命令交互式变基在本地使用，重新排序、合并、拆分、编辑或删除提交，从而整理提交历史，使其更加清晰。 rebase和merge的区别：都是实现合并分支，但是细节不同，rebase会把复杂的提交历史修订为干净整洁的线性结构，并且产生新的commitID。 使用步骤： 执行git rebase -i HEAD~5，此时打开一个编辑器，显示最近的5个提交，每个提交前有一个命令（默认是pick） 编辑提交列表，修改每一行前面的命令，例如pick改成reword Git会按照指令提交 常用命令： 命令 缩写 作用 pick p 保留该提交（不做修改） reword r 修改提交信息 edit e 暂停 rebase，允许修改提交内容（如增删文件）或提交信息 squash s 合并到前一个提交，并保留提交信息 fixup f 合并到前一个提交，但丢弃当前提交的提交信息 drop d 删除该提交 exec x 执行一个 shell 命令（如运行测试） 注意事项： 不要修改已经推送到远程仓库的提交历史（除非确定没有其他人基于此工作） 如果遇到冲突： 解决冲突后，用 git add 标记为已解决 继续 rebase：git rebase --continue 或终止 rebase：git rebase --abort 解决后强制推送到远程：git push --force 储藏 临时保存未提交的更改，将当前工作目录和暂存区的修改保存到一个“储藏区”（stash stack），可以快速切换分支或处理其他任务，后续再恢复这些更改。 基本命令： 基本命令 具体操作 说明 存（入栈） stash (push) 默认存入当前工作区的修改到栈中 stash save &quot;注释&quot; 可以连续存多次变动代码，添加注释方便区分 取（出栈） stash pop 取出栈顶的修改并应用到当前工作区，同时从栈中移除该修改 注意：确保此时 pop 的变动代码是你需要的，否则 pop 后可能需要重新压栈 stash apply 取出栈顶的修改并应用到当前工作区，但不从栈中移除该修改（类似 peek） 清除 stash drop 丢弃栈顶的修改 stash clear 清空整个 stash 栈 查看 stash list 查看 stash 栈中的所有修改记录 stash show + 栈索引 查看指定索引位置的修改详情 使用场景： 切换分支时，当前分支有未完成的代码。 需要紧急修复其他分支的 Bug，但不想提交当前代码。 临时保存实验性代码，避免污染提交历史。 合并冲突前，先保存当前改动。 使用示例： 12345678910111213141516# 1. 当前有未提交的修改，但需要切换到其他分支git stash# 2. 切换到其他分支并完成任务git checkout other-branch# ... 处理其他任务 ...# 3. 返回原分支并恢复储藏git checkout original-branchgit stash pop # 恢复并删除最近的储藏# 4. 查看储藏列表（可选）git stash list# 5. 清空储藏（可选）git stash clear 挑选工作在多分支结构的提交维度上，与merge的区别： merge：需要另一个分支上的所有变动 cherry-pick：需要另一个分支上的部分变动 提交情形： 当产生冲突时，会停下来让用户决定，此时有3种情况： --continue：解决冲突后，git add，再执行此命令继续合并 --abort：放弃合并，回到之前的状态 --quit：放弃合并，且不回到之前 比较不同diff命令，主要讲解两点提交和三点提交的区别： 七、铁令 切换分支前先提交本地的修改 代码及时提交，提交过了就不会丢 遇到任何问题都不要删除文件目录"},{"title":"【Go基础】常用环境变量设置","path":"/2025/03/19/【Go基础】常用环境变量设置/","content":"常用环境变量GOROOT： go的安装目录（go安装：https://golang.google.cn/dl/） GOPATH：一般给文件夹起名叫GoWorkstation、Go_WorkSpace等。 src：存放源代码 pkg：存放依赖包 bin：存放可执行文件 其他常用环境变量：GOOS，GOARCH，GOPROXY国内用户建议设置 goproxy：export GOPROXY&#x3D;https://goproxy.cn"},{"title":"【Go基础】错误处理","path":"/2025/03/19/【Go基础】错误处理/","content":"基本认识 在Go中，将错误当成值来进行处理，强调判断错误和处理错误，不支持try/catch捕获异常。 Go选择使用Error而非Exception来进行错误处理。 一般把错误作为函数或方法的最后一个返回值。 Error接口使用error接口表示错误类型。该接口只有一个Error()方法，返回描述错误信息的字符串。 123type error interface &#123; Error() string&#125; 接口类型的默认零值为nil，所以通常把调用函数时返回的错误和nil比较： 12345_, err := someFunc(some parameters)if err != nil&#123; fmt.Println(&quot;出现错误：&quot;, err) // 使用标准库fmt打印错误自动调用error类型的Error方法，打印错误描述信息 return&#125; Go这种机制的好处是，遇到error需要立即处理，而Java中是try/catch中包裹了一大堆代码，良性和致命的问题都会抛出错误，不容易排查问题。 创建错误由于error是接口，可以自定义错误类型（开发中间件使用较多）。 最简单的创建错误的方法是用errors包提供的New函数创建一个错误： 123func New(text string) error&#123; return &amp;errorString&#123;text&#125;\t// 返回一个指针，使得每次返回都是一个新的对象，否则在做等值判断时可能会出问题。&#125; 错误的两种类型error：可以被处理的错误；panic：非常严重不可恢复的错误。 errors包当需要传入格式化的错误描述信息，用fmt.Errorf更好，但是它提供很多描述错误的文本信息，会丢失原本的错误类型，导致错误在做等值判断时失效。为了解决这个缺陷，fmt.Errorf在1.13版本提供了特殊的格式化动词w%，可以基于已有错误再包装得到新的错误： 1fmt.Errorf(&quot;查询数据库失败，err:%w&quot;, err) 对于这种二次包装的错误，errors包提供了4个常用的方法： New：创建一个新的 error func Is(err, target error) bool ：判断err是否包含target，是不是特定的某个error func As(err error, target interface&#123;&#125;) bool：判断error是否为target类型，类型转换为特定的error（用得不多） func Unwrap(err error) error：获得error包含下一层错误，解除包装并返回被包装的 error 使用举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport (\t&quot;errors&quot;\t&quot;fmt&quot;)func main() &#123;\tvar err error = &amp;MyError&#123;&#125;\tprintln(err.Error())\tErrorsPkg()&#125;type MyError struct &#123;&#125;func (m *MyError) Error() string &#123;\treturn &quot;Hello, it&#x27;s my error&quot;&#125;func ErrorsPkg() &#123;\terr := &amp;MyError&#123;&#125;\t// 使用 %w 占位符，返回的是一个新错误\t// wrappedErr 是一个新类型，fmt.wrapError\twrappedErr := fmt.Errorf(&quot;this is an wrapped error %w&quot;, err)\t// 再解出来\tif err == errors.Unwrap(wrappedErr) &#123; fmt.Println(&quot;unwrapped&quot;)\t&#125; if errors.Is(wrappedErr, err) &#123; // 虽然被包了一下，但是 Is 会逐层解除包装，判断是不是该错误 fmt.Println(&quot;wrapped is err&quot;)\t&#125;\tcopyErr := &amp;MyError&#123;&#125;\t// 这里尝试将 wrappedErr转换为 MyError\t// 注意我们使用了两次的取地址符号\tif errors.As(wrappedErr, &amp;copyErr) &#123; fmt.Println(&quot;convert error&quot;)\t&#125;&#125; panic意味着fatal error，调用者不能解决，彻底结束。可能遇到的场景： 调用别人的代码，别人没有合理使用panic（自己写代码还是用error）。 数组越界、不可恢复的环境、栈溢出等错误。 从panic中恢复： ​\trecover可以进行兜底，把这一次的request放弃，go的runtime会退出，可以去执行其他的request，但是风险比较大，revover一般就是记录个日志之类的，，示例： 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123;\tdefer func() &#123; if data := recover(); data != nil &#123; fmt.Printf(&quot;hello, panic: %v &quot;, data) &#125; fmt.Println(&quot;恢复之后从这里继续执行&quot;)\t&#125;()\tpanic(&quot;Boom&quot;)\tfmt.Println(&quot;这里将不会执行下来&quot;)&#125; 使用原则 遇事不决选 error 当怀疑可以用 error 的时候，就说明不需要 panic 一般情况下，只有快速失败的过程，才会考虑panic defer用于在方法返回之前执行某些动作（类似于Java中的finally），一般用来释放资源（如锁等）。执行顺序：像栈一样，先进后出。 处理错误正常流程的代码推荐的写法，err处理缩进，正常的代码是一条直线。 12345678910111213/////////推荐写法////////f, err := os.Open(path)if err != nil &#123; // handle error&#125;// do stuff//////////不推荐///////f, err := os.Open(path)if err == nil &#123; // do stuff&#125;// handle error 少写if err !&#x3D; nil的技巧 返回err或者nil，可以直接return： 12345678910111213//////原来的写法func AuthenticateRequest(r *Request) error &#123; err := authenticate(r.User) if err != nil &#123; return err &#125; return nil&#125;//////推荐的写法 //毕竟函数的返回值就要error类型，而且调用函数之后就返回一个error类型，那直接return就好了func AuthenticateRequest(r *Request) error &#123; return authenticate(r.User)&#125; 用io.Reader统计读取内容的行数 1234567891011121314151617181920212223242526272829//////原来的写法func CountLines(r io.Reader) (int, error) &#123; var ( br = bufio.NewReader(r) lines int err error ) for &#123; _, err = br.ReadString(&#x27; &#x27;) lines++ if err != nil &#123; break &#125; &#125; if err != io.EOF &#123; return 0, err &#125; return lines, nil&#125;//////推荐的写法 //func CountLines(r io.Reader) (int, error) &#123; sc := bufio.NewScanner(r) lines := 0 for sc.Scan() &#123; lines++ &#125; return lines, sc.Err()&#125; 利用bufio.Scanner方法，这个里面封装了按行读取的逻辑，并且其Scan方法读取时遇到错误会记录下来，最终通过 sc.Err()统一返回。 包装错误类型，缓存错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758////////////原来的写法type Header struct &#123; Key, Value string&#125;type Status struct &#123; Code int Reason string&#125;func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123; _, err := fmt.Fprintf(w, &quot;HTTP/1.1 %d %s\\r &quot;, st.Code, st.Reason) if err != nil &#123; return err &#125; for _, h := range headers &#123; _, err := fmt.Fprintf(w, &quot;%s: %s\\r &quot;, h.Key, h.Value) if err != nil &#123; return err &#125; &#125; if _, err := fmt.Fprintf(w, &quot;\\r &quot;); err != nil &#123; return err &#125; _, err = io.Copy(w, body) return err&#125;//////////////推荐的写法 //type errWriter struct &#123; io.Writer err error\t// 用来暂存&#125;func (e *errWriter) Write(buf []byte) (int, error) &#123; if e.err != nil &#123; return 0, e.err &#125; var n int n, e.err = e.Writer.Write(buf) return n, e.err&#125;func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123; ew := &amp;errWriter&#123;Writer: w&#125; fmt.Fprintf(ew, &quot;HTTP/1.1 %d %s\\r &quot;, st.Code, st.Reason) for _, h := range headers &#123; fmt.Fprintf(ew, &quot;%s: %s\\r &quot;, h.Key, h.Value) &#125; fmt.Fprintf(ew, &quot;\\r &quot;) io.Copy(ew, body) return ew.err&#125; 下面这种写法，不用做任何err的判定，相当于在包装类里面复用了，更优雅。 使用errors包装错误-从根本上解决上一小节只是减少了if err !&#x3D; nil的数量，但是并没有从根本上解决不能提供详细上下文的问题。一方面，破坏原始错误，担心上层调用的人用做等值判定，只能一层层向上透传，最终输出没有堆栈没有上下文的信息，令人崩溃；另一方面，又想包装更多详细错误信息。 error.Wrap()：保留原始错误信息，捎带一些附加信息。 errors.Cause()：用来获取原始错误（根因，root error）。 errors.WithMessage()：不保存堆栈信息。 实际应用时： 自己的应用代码中，使用errors.New()或者errors.Errorf()返回错误； 如果调用其他包内的函数，直接返回，往上抛，不要在错误的地方到处打日志。（满足原则：只处理一次。） 如果使用三方库&#x2F;标准库，使用errors.Wrap()或errors.Wrapf()保存堆栈信息。 程序的顶部或者工作的goroutine顶部，用%+v详细记录堆栈。 处理错误的原则处理的原则是：如果遇到错误，只处理一次。 一些经常出现的错误代码，在错误处理中，既记录了日志，又返回了错误： 12345678func WriteAll(w io.Writer, buf []byte) error &#123; _, err := w.Write(buf) if err != nil &#123; log.Println(&quot;unable to write:&quot;, err) return err &#125; return nil&#125; 这个时候又尬住了，一方面，不记录日志，找不到是谁报错；另一方面，记录日志接下来调用者层层打印，在控制台的输出可能就层层割裂，没有完整的堆栈信息。 继续讲处理的原则：错误处理契约规定，出现错误时，不能对其他返回值的内容做任何假设。如果程序员忘记return，函数返回的结果可能是正确的，但是其他返回值的内容是错误的。 那么应该如何记录日志？原则： 错误要被日志记录 *应用程序处理错误，保证**100%*完整性 之后不再报告当前错误 结合上一小节，包装错误的原则： 如果你提供的库很多人使用，不应该使用任何wrap包装错误 如果你的函数无法处理错误，携带足够多的上下文，用wrap.Errors往上抛（足够的上下文：能帮助解决问题，一般是什么人调用了什么接口，返回成功还是失败） 如果这个错误被处理过，就不要再抛了。 【参考资料】 https://www.liwenzhou.com/posts/Go/error/"},{"title":"【Go基础】并发编程基本概念","path":"/2025/03/19/【Go基础】并发编程基本概念/","content":"并发编程基本概念串行、并发与并行 串行：我们都是先读小学，小学毕业后再读初中，读完初中再读高中。 并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。 并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。 进程、线程和协程 进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。 协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。 并发模型4种常见的实现方式： 线程&amp;锁模型 Actor模型 CSP模型（communicating sequential processes，Go中主要是基于CSP的goroutine和channel实现） Fork&amp;Join模型"},{"title":"【Go基础】垃圾回收演进 三色标记法","path":"/2025/03/19/【Go基础】垃圾回收演进三色标记法/","content":"GO1.3标记清除，整体需要STW：1.暂停，找到可达和不可达对象，2. 标记可达对象，3. 清除未标记对象，4. 结束暂停 GO1.5三色标记法，堆启动写屏障，栈不启动，全部扫描一次后，需要重新扫描栈（STW），效率低 如果没有STW，对象丢失的2个条件： 黑色对象指向白色对象（白色挂在黑色下面） 灰色对象与其可达白色对象之间遭到破坏（灰色也丢失了该白色） 屏障机制，保障对象不丢失的2种方式： 强三色不变式：不允许黑色对象指向白色对象 弱三色不变式：允许黑色对象指向白色对象，但是该白色对象要被灰色对象可达 为此，go初步得到两种屏障方式： 插入写屏障：只使用在堆中，将黑色指向的白色对象标记为灰色；栈要启动STW重新三色标记扫描（仍然需要STW重新扫描栈） 删除写屏障：被删除的白色节点标记为灰色（保护灰色对象到白色对象的路径不会断），所以最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉（回收精度低，开始时STW记录初始快照） 为什么在栈中不使用： GO1.8三色标记法，混合写屏障，栈不启动，堆启动，几乎不需要STW，效率高 结合得到混合写屏障（满足弱三色不变）： 开始时将所有栈上的可达节点标记为黑色，在GC期间栈上新增的也标记为黑色（无需STW） 删除和新增的全部标记为灰色 参考资料： https://www.bilibili.com/video/BV1wz4y1y7Kd/"},{"title":"【Go基础】Go入门与实践资源帖","path":"/2025/03/19/【Go基础】Go入门与实践资源帖/","content":"看到好的持续更新…… Go系统教程 从语法讲起：李文周博客 七天快速上手项目 Go测试驱动开发博客 孔令飞项目开发实战课程，孔令飞图文教程 《Go 语言高级编程》书籍 Go算法刷题模板 Go实战项目 KV系统 crawlab分布式爬虫平台 seaweedfs分布式文件系统 Cloudreve云盘系统 gfast后台管理系统（基于Go Frame） alist多存储文件列表（基于Gin、React） Yearning开源SQL审核平台 Go要点 GMP机制 并发编程机制 编辑解释运行机制 GC机制 看过的帖子 腾讯技术工程：协程调度的本质 通用技术面试相关 极客时间面试指导视频课"},{"title":"【Go基础】微服务概念与演进","path":"/2025/03/19/【Go基础】微服务概念与演进/","content":"微服务概念与演进巨石架构到微服务的演进传统网页应用虽然进行了模块化设计，但是最终仍然是打包成一个war包进行部署，启动慢，无法拓展，可靠性很低。 什么是微服务是面向服务的架构模式（SOA）的最佳实践。定义：围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。 如何实现微服务组件服务化，例如在Go中实现需要：• kit：一个微服务的基础库（框架）• service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务• RPC + message queue：轻量级通讯按业务组织服务，常见的模式：大前端（移动&#x2F;Web） &gt; 网关接入 &gt; 业务服务 &gt; 平台服务 &gt; 基础设施（PaaS&#x2F;Saas） 微服务的优点和缺点优点：原子服务、独立进程、隔离部署、去中心化服务治理。 缺点：基础设施的建设、复杂度高。固有的复杂性：① 必须使用RPC或者消息传递实现进程间的通信，处理通信慢与局部失效的问题；② 不同服务可能使用不同数据库。 要搞定这些缺点，需要做怎样的基础设施建设做什么事情–可用性设计、API设计等引申话题 微服务组件微服务设计中常见的角色三大组件：API Gateway、BFF层、底层服务Microservices。API网关分层： 流量入口：协议转换&#x2F;路由分发 安全边界：统一认证&#x2F;权限控制 流量治理：限流熔断&#x2F;日志监控 BFF适配层：为不同终端提供定制化APICQRS模式：读写分离（通过binlog实现数据同步） 演进过程Microservices拆分: 按垂直功能性能角度，含久必分分久必合 可以考虑中间加一层(例如统一接入账号) 按照业务领域抽象（DDD） 按照功能拆分：CQRS，应用程序分为命令端和查询端。 安全问题外部的安全保障：API Gateway统一认证拦截 -&gt; BFF校验Token -&gt; Service 服务内部的安全保障：① 认证：知道是谁调用的；② 授权：RBAC，控制能访问哪些接口。 信任等级：Full&#x2F;Half&#x2F;Zero Trust。 gRPC概念A high-performance, open-source universal RPC framework. 高性能开源框架。特性： 支持多语言； 序列化支持Protocol Buffer和Json； HTTP&#x2F;2多路复用。 其中最重要的是标准健康监测协议，应用如下：应用1：服务稳定与不稳定时摘除与恢复；应用2：外挂容器健康检测；应用3：生产者与消费者之间的检测；应用4：平滑发布。 服务发现的模型① 客户端发现（微服务的核心是去中心化，用这种更好）；② 服务端发现（如果服务很大，可能用service mesh）。 多集群与多租户多集群why?——单集群坏处：一般布N+2来冗余节点。出现故障时后果严重。how?——物理上两套资源，逻辑上维护cluster概念。好处？——不同集群使用多套独占的缓存，性能好。坏处？——缓存命中率下降，不同业务形态数据正交。拓展：从全集群中选取一批节点（子集），利用划分子集限制连接池大小。——子集算法。 多租户why？保障代码隔离性，基于流量租户做路由决策。问题：[并行测试]时混用环境不可靠，而多布环境成本高，也难以做压测。解决方法：染色发布，基于流量类型做路由。本质是从源头传递一个标签，挂在go的上下文中，基于RPC负载均衡的流量做路由,路由到指定的节点。 参考资料：https://microservices.io/index.htmlhttps://blog.csdn.net/mindfloating/article/details/51221780https://www.cnblogs.com/dadadechengzi/p/9373069.htmlhttps://www.cnblogs.com/viaiu/archive/2018/11/24/10011376.htmlhttps://www.cnblogs.com/lfs2640666960/p/9543096.htmlhttps://mp.weixin.qq.com/s/L6OKJK1ev1FyVDu03CQ0OAhttps://www.bookstack.cn/read/API-design-guide/API-design-guide-02-面向资源的设计.mdhttps://www.programmableweb.com/news/how-to-design-great-apis-api-first-design-and-raml/how-to/2015/07/10http://www.dockone.io/article/394https://www.jianshu.com/p/3c7a0e81451ahttps://www.jianshu.com/p/6e539caf662dhttps://my.oschina.net/CraneHe/blog/70317https://my.oschina.net/CraneHe/blog/703169https://my.oschina.net/CraneHe/blog/703160 学习笔记，侵删。"},{"title":"【LeeCode】刷题记录.md","path":"/2024/04/08/【LeeCode】刷题记录/","content":"作者：力扣官方题解 来源：力扣（LeetCode） LeeCode热题10049、字母异位词分组（中）https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/ 题面给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 为什么是哈希表相关的题？ 思路： 当把单词中所有字母按照字母顺序表排列时，字母异位词的排序后的单词是相同的。 可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词。 哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。 具体做法：遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。 方法1：字母排序 构造单词的字符排序，作为键。 将单词加入散列表。 返回答案。 1234567891011121314class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; char[] array = str.toCharArray(); Arrays.sort(array); String key = new String(array); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 复习 char[] toCharArray() 。将此字符串转换为新的字符数组。 getOrDefault。HashMap的一个方法，返回指定键映射到的值，如果此映射不包含键的映射，则返回 defaultValue 。 向list中新增元素用add方法。 向哈希表中新增元素用put方法，同时传入键和值。 复杂度分析 方法2：计数 互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。 字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。 首先统计字符的出现顺序，然后构造键，把具有相通特征的字符串的单词们放在一组，最后返回结果。 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strs) &#123; int[] counts = new int[26]; int length = str.length(); for (int i = 0; i &lt; length; i++) &#123; counts[str.charAt(i) - &#x27;a&#x27;]++; &#125; // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); //可变字符串对象 for (int i = 0; i &lt; 26; i++) &#123; if (counts[i] != 0) &#123; sb.append((char) (&#x27;a&#x27; + i)); sb.append(counts[i]); &#125; &#125; String key = sb.toString(); List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;()); list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 复杂度分析 面试要点 通过分析，能否意识到单词和键的映射关系。 利用散列表高效储存结果。 数据结构和常见的库函数。"},{"title":"【资源帖】学习Java和算法","path":"/2024/04/06/【资源帖】学习Java和算法/","content":"Java教程学习路线【黑马程序员】 Java简版基础教程：https://www.bilibili.com/video/BV1Cv411372m/ 书：《Java核心技术 1》 书：《Head First Java》 Java Web框架：https://www.bilibili.com/video/BV1m84y1w7Tb/ 单体项目开发： 苍穹外卖：https://www.bilibili.com/video/BV1TP411v7v6/ 微服务： 全套微服务技术栈：https://www.bilibili.com/video/BV1S142197x7/ 企业级项目实战（选择学习）： 学成在线【在线教育】：https://www.bilibili.com/video/BV1j8411N7Bm/ 黑马头条【企业级微服务项目】 ：https://www.bilibili.com/video/BV1Qs4y1v7x4/ 面试专题： 2023版：https://www.bilibili.com/video/BV1yT411H7YK/ 复制标题和时长：https://www.bilibili.com/read/cv22846057/ 精进指南 （JavaWeb后，选学）MySQL：https://www.bilibili.com/video/BV1Kr4y1i7ru/ （微服务后，选学）Redis微服务：https://www.bilibili.com/video/BV1cr4y1671t/ （微服务后，选学）MybatisPlus：https://www.bilibili.com/video/BV1Xu411A7tL/ （JVM前，必学）计算机网络：https://www.bilibili.com/video/BV1c4411d7jb/ （Java基础，选学）JVM虚拟机：https://www.bilibili.com/video/BV1r94y1b7eS/ （JVM后，选学）并发编程：https://www.bilibili.com/video/BV16J411h7Rd/ （git版本控制，选学）https://www.bilibili.com/video/BV1MU4y1Y7h5/ 资源帖 JavaGuide：JavaGuide（Java学习&amp;面试指南） | JavaGuide JavaBooks：https://gitee.com/itwanger/JavaBooks 拿个offer：拿个offer - 开源&amp;项目实战 (nageoffer.com) LeeCode刷题指南官网力扣 (LeetCode) 全球极客挚爱的技术成长平台 刷题指北peach买个共享会员账号看考察频次。 资源帖 labuladong：本站简介 | labuladong 的算法笔记（提升算法能力。） 代码随想录：代码随想录 (programmercarl.com)（全面，但是精简，适合面试突击。） 小林coding：小林coding (xiaolincoding.com)（图解好理解，但只有Redis、MySQL、计网。） 左程云：左程云的个人空间-左程云个人主页-哔哩哔哩视频 (bilibili.com)（算法讲解。） NeeCode：NeetCode（英文站点。） 推荐书单 《剑指offer》。"},{"title":"【求职】如何写一份受欢迎的校招简历","path":"/2024/04/05/【求职】如何写一份受欢迎的校招简历/","content":"常见问题 过度包装设计。减弱主要信息能量，华而不实。 篇幅过长。 求职定位不明。 实践经历描述不当。 一份简历闯天下。 JD：工作职责、工作胜任力。 使用表格式简历。 啰啰嗦嗦重点不突出。 不该讲的乱讲。例如，创业、离职原因、到岗时间、离婚、错误检讨、薪资条件。 优秀简历的特征版面设计简洁大方、布局清晰、模板分界。 简历结构结构完整、详略得当、易于阅读。 内容呈现逻辑清晰、优势突出、数据支撑。 人岗匹配有的放矢、贴近岗位JD、天生我才。 效果 脱颖而出、入得法眼。 顺畅读完，越读越喜欢。 打动人心，不如见一面。 为面试好印象做好铺垫。（面试官其实是根据初印象，步步求证是否确实是需要的人。） 简历的完整结构“2+2”通用的（非本专业&#x2F;技术岗）： 基本信息：略写。7%。 自我评价：较详。20%。 工作经历：详写。（大力气。）70%。 学历、证书、技能：略写。3%。 基本信息 姓名+求职意向+性别+年龄。（政治面貌：国企央企等写，外企不写，民企无所谓。） 联系方式：城市、电话、微信、邮箱。（不用写太多。城市可以写XX(意向城市)。联系方式三个必有一，推荐电话。） 个人照片：彩色、正面头像、有精气神。（匹配行业。） 自我评价&#x2F;教育背景社招： 工作背景。例如，年份+领域&#x2F;行业+擅长&#x2F;熟悉&#x2F;掌握。 优势能力。四条分号隔开。专业软件可以写。 职业素养。 校招： 起止时段：学校、专业、学历、学位。 主修课程。 奖学金可以写。 工作经历&#x2F;实习经历&#x2F;项目经历社招： 工作时段。（可以有总分，总的在某个公司，分的是不同岗位。最好是倒叙。） 工作职责。（前3-5个。） 工作业绩。（为了醒目，可以换个标志，比如五角星。一定要有数据，没数据也不要乱讲。） 工作获奖。（要有含金量的，行业、省市级以上，发明专利等。） 校招： 起止时段、公司、岗位。 工作职责、价值、奖项。 其他佐证 学历背景：学校、专业。 语言能力：语种、级别。（只是针对某些需要语言能力的岗位。其他：听说读写能力流利，可作为工作语言。） 专业技能：证书、级别。（例如岗位资格证。） 校招和社招的区别 教育背景前置&#x2F;后置。 自我评价的有无。（复盘能力。） 优秀简历写作心法人岗匹配！！！ 职场的本质是价值交换。（以终为始。） 见字如面，格式细节很重要，大小标题和逻辑关系。 凤头猪肚豹尾。自我评价漂亮客观，工作经历饱满有结果，其他佐证简短有力。 工作经历倒叙。写清楚总分，闭环表达，数据支撑。 工作年限5年以下，请用一张A4纸完成。 如果经历比较少，根据一段经历可以多挖掘，例如，“1+3+6+x”主轴。 如何准备 确定自己身份：校招&#x2F;社招，确定目标岗位，了解岗位JD。 准备模板，通读三遍。准备素材，多多益善。（所有经历都可以准备。） 现有骨架，再填充。时间倒叙，先粗后细。 先写草稿，反复打磨。"}]