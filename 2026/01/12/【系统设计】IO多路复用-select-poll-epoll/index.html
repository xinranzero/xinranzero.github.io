
<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>【系统设计】IO多路复用 select poll epoll - xinranzero</title>

  
    <meta name="description" content="基本概念与发展过程我们要解决的核心任务是：一台服务器（电脑），如何同时接待成千上万个客户端（用户连接）。(即，高并发问题) 按照您的要求，我先列出3个必须知道的基础概念，然后再按时间线讲故事。 第一部分：基础概念小词典（先看懂这3个词） 用户空间 vs 内核空间： 内核（Kernel）：操作系统的核心老大，拥有最高权限，只有它能直接控制网卡、硬盘等硬件。 用户进程（User Process）：你写">
<meta property="og:type" content="article">
<meta property="og:title" content="【系统设计】IO多路复用 select poll epoll">
<meta property="og:url" content="http://xinranzero.com/2026/01/12/%E3%80%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select-poll-epoll/index.html">
<meta property="og:site_name" content="xinranzero">
<meta property="og:description" content="基本概念与发展过程我们要解决的核心任务是：一台服务器（电脑），如何同时接待成千上万个客户端（用户连接）。(即，高并发问题) 按照您的要求，我先列出3个必须知道的基础概念，然后再按时间线讲故事。 第一部分：基础概念小词典（先看懂这3个词） 用户空间 vs 内核空间： 内核（Kernel）：操作系统的核心老大，拥有最高权限，只有它能直接控制网卡、硬盘等硬件。 用户进程（User Process）：你写">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2026-01-11T16:23:05.000Z">
<meta property="article:modified_time" content="2026-01-18T10:10:29.000Z">
<meta property="article:author" content="Rong Zhao">
<meta name="twitter:card" content="summary">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">

  

  

  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet">
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">xinranzero</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">Recent Update</span></div><div class="widget-body fs14"><a class="item title" href="/2026/01/18/%E3%80%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E7%A3%81%E7%9B%98/"><span class="title">【系统设计】数据结构选型：内存与磁盘</span></a><a class="item title" href="/2026/01/12/%E3%80%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select-poll-epoll/"><span class="title">【系统设计】IO多路复用 select poll epoll</span></a><a class="item title" href="/2026/01/11/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91Pulsar%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><span class="title">【消息队列】Pulsar基本使用</span></a><a class="item title" href="/2026/01/11/%E3%80%90MongoDB%E3%80%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"><span class="title">【MongoDB】常用命令速查</span></a><a class="item title" href="/2026/01/06/%E3%80%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E5%B4%A9%E6%BA%83%E4%B8%80%E8%87%B4%E6%80%A7/"><span class="title">【系统设计】崩溃一致性</span></a><a class="item title" href="/2025/03/21/%E3%80%90%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%91Git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"><span class="title">【通用工具】Git分布式版本控制工具</span></a><a class="item title" href="/2025/12/27/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5/"><span class="title">【消息队列】基本概念与设计理念</span></a><a class="item title" href="/2025/12/20/%E3%80%90%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%91Makefile%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E%E4%B9%A6/"><span class="title">【通用工具】Makefile：自动化编译说明书</span></a><a class="item title" href="/2025/12/21/%E3%80%90MongoDB%E3%80%91%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"><span class="title">【MongoDB】索引优化</span></a><a class="item title" href="/2025/12/21/%E3%80%90Kubernetes%E3%80%91%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><span class="title">【Kubernetes】资源配置相关知识</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2026-01-11T16:23:05.000Z">2026-01-12</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2026-01-18T10:10:29.000Z">2026-01-18</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>【系统设计】IO多路复用 select poll epoll</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="基本概念与发展过程"><a href="#基本概念与发展过程" class="headerlink" title="基本概念与发展过程"></a>基本概念与发展过程</h1><p>我们要解决的核心任务是：<strong>一台服务器（电脑），如何同时接待成千上万个客户端（用户连接）。</strong>(即，高并发问题)</p>
<p>按照您的要求，我先列出<strong>3个必须知道的基础概念</strong>，然后再按时间线讲故事。</p>
<h2 id="第一部分：基础概念小词典（先看懂这3个词）"><a href="#第一部分：基础概念小词典（先看懂这3个词）" class="headerlink" title="第一部分：基础概念小词典（先看懂这3个词）"></a>第一部分：基础概念小词典（先看懂这3个词）</h2><ol>
<li><strong>用户空间 vs 内核空间</strong>：<ul>
<li><strong>内核（Kernel）</strong>：操作系统的核心老大，拥有最高权限，只有它能直接控制网卡、硬盘等硬件。</li>
<li><strong>用户进程（User Process）</strong>：你写的程序（比如 Python&#x2F;Go 代码）。它没有权限直接操作硬件，想要读取网卡数据，必须请求“内核”帮忙，把数据从网卡搬到自己的内存里。</li>
<li><em>关系</em>：你的程序是“老板”，内核是“办事员”。</li>
</ul>
</li>
<li>**文件描述符 (File Descriptor, 简称 FD)**：<ul>
<li>在 Linux 里，一切皆文件。一个网络连接（Socket）也是一个文件。</li>
<li>当一个用户连上来，内核就给这个连接发个号码牌，比如 <code>fd = 3</code>，<code>fd = 4</code>。</li>
<li><em>通俗理解</em>：这就是<strong>连接的身份证号</strong>。</li>
</ul>
</li>
<li>**上下文切换 (Context Switch)**：<ul>
<li>CPU 只有一个大脑。如果要从“运行 A 程序”切换到“运行 B 程序”，它必须先把 A 的现场保存下来，再载入 B 的现场。</li>
<li><em>通俗理解</em>：这个过程非常<strong>费脑子（耗 CPU）</strong>，切换太频繁，CPU 就累垮了。</li>
</ul>
</li>
</ol>
<h2 id="第二部分：发展过程（问题-方案-新问题）"><a href="#第二部分：发展过程（问题-方案-新问题）" class="headerlink" title="第二部分：发展过程（问题 -&gt; 方案 -&gt; 新问题）"></a>第二部分：发展过程（问题 -&gt; 方案 -&gt; 新问题）</h2><p>我们来看看为了让服务器能同时处理更多连接，技术是怎么一步步进化的。</p>
<h3 id="第一阶段：远古时期-——-同步阻塞-IO-BIO"><a href="#第一阶段：远古时期-——-同步阻塞-IO-BIO" class="headerlink" title="第一阶段：远古时期 —— 同步阻塞 IO (BIO)"></a>第一阶段：远古时期 —— 同步阻塞 IO (BIO)</h3><p>方案：一连接一线程。</p>
<p>你来了 1000 个用户，我就开 1000 个线程。每个线程专门负责死死盯着一个用户【线程调用recv()函数读取数据】。如果用户不发数据，这个线程就挂起（阻塞），什么都不干，干等着。</p>
<ul>
<li><strong>出现了什么问题？</strong><ol>
<li><strong>内存爆炸</strong>：每个线程都要占用几 MB 内存。1万个连接就是几十 GB 内存，服务器直接炸了。</li>
<li><strong>调度崩溃</strong>：1万个线程在 CPU 之间切来切去（上下文切换），CPU 90% 的时间都在忙着切换线程【Context Switch】，没时间真正处理业务。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>线程资源与上下文切换的冲突</strong></p>
</blockquote>
<h3 id="第二阶段：忙轮询时期-——-同步非阻塞-IO-NIO"><a href="#第二阶段：忙轮询时期-——-同步非阻塞-IO-NIO" class="headerlink" title="第二阶段：忙轮询时期 —— 同步非阻塞 IO (NIO)"></a>第二阶段：忙轮询时期 —— 同步非阻塞 IO (NIO)</h3><p>方案：单线程轮询。</p>
<p>为了省内存，我不开那么多线程了，我只用 1 个线程。</p>
<p>把连接都设为“非阻塞”，这个线程写一个死循环（while true），不停地挨个问这 1000 个连接：“有数据吗？”“有数据吗？”……</p>
<ul>
<li><strong>出现了什么问题？</strong><ol>
<li><strong>CPU 空转</strong>：这就好比你每秒钟看 100 次手机有没有新消息。99% 的时候是没数据的，但你的 CPU 却一直满负荷运转（100%占用）【recv()函数返回无数据】，纯属浪费电。</li>
<li><strong>效率低</strong>：每次问“有数据吗”【忙轮询Busy Loop】，都是一次从“用户程序”到“内核”的系统调用，开销很大。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>无效系统调用与 CPU 空转</strong></p>
</blockquote>
<h3 id="第三阶段：代理人时期-——-IO-多路复用-Select"><a href="#第三阶段：代理人时期-——-IO-多路复用-Select" class="headerlink" title="第三阶段：代理人时期 —— IO 多路复用 (Select)"></a>第三阶段：代理人时期 —— IO 多路复用 (Select)</h3><p>方案：把“轮询”的工作甩锅给内核。</p>
<p>既然“挨个问”太累，你的程序决定不自己问了。</p>
<p>你把这 1000 个连接的 ID（FD）打包成一个列表，一次性扔给内核（调用 select 函数）。</p>
<p>你告诉内核：“帮我盯着这 1000 个连接，只要里面有任何一个或者多个有数据了，你就叫醒我。”</p>
<p>这就叫<strong>IO 多路复用</strong>（一个线程，复用处理多个连接）。</p>
<ul>
<li><p>Select 解决了什么？</p>
<p>解决了“线程爆炸”和“CPU 空转”的问题。现在一个线程就能守住 1000 个连接，而且没数据的时候线程是休息的（阻塞），不耗 CPU。</p>
</li>
<li><p>Select 又出现了什么新问题？（这就是您刚才问的核心）</p>
<p>随着互联网发展，连接数从 1000 变成了 10万，Select 的设计缺陷暴露了：</p>
<ol>
<li><strong>数量限制</strong>：Select 设计得太早，代码里写死了最多只能监视 <strong>1024</strong> 个连接【<code>fd_set</code>类型作为参数，在内核源码中是一个固定长度的位图数组，<code>__FD_SETSIZE</code> 默认硬编码为 1024】。这在现代简直不够塞牙缝。</li>
<li><strong>重复拷贝（笨）</strong>：【无状态】你每次调用 <code>select</code>，都要把这 1000 个 ID 的列表从用户内存<strong>拷贝</strong>到内核内存。内核处理完，又拷贝回来。每次调用都拷，数据量一大，内存带宽就被吃光了。在高频调用下就是巨大的CPU开销。</li>
<li><strong>线性遍历（慢）</strong>：<ul>
<li><strong>内核端</strong>：内核收到列表，需要<strong>从头到尾扫一遍</strong>这 1000 个连接，看谁有数据【内核需要遍历整个 <code>fd_set</code> 数组，检查每个对应的 Socket 接收缓冲区是否非空。】。</li>
<li><strong>用户端</strong>：内核告诉你“有连接来数据了”，但<strong>不告诉你是谁</strong>。你的程序醒来后，必须自己写个循环，<strong>再从头到尾扫一遍</strong>这 1000 个连接，看看到底是谁变了【 <code>select</code> 返回 n（就绪个数）时，它只返回了修改后的位图，没有返回具体 ID。用户代码必须使用 <code>FD_ISSET</code> 宏，在一个循环中遍历所有监控的 FD（从 0 到 1023），逐位检查是否为 1。】。</li>
<li><strong>总结</strong>：只要连接数一多，Select 就慢得像蜗牛。</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>O(N)</strong></p>
</blockquote>
<h3 id="第四阶段：现代高并发时期-——-Epoll"><a href="#第四阶段：现代高并发时期-——-Epoll" class="headerlink" title="第四阶段：现代高并发时期 —— Epoll"></a>第四阶段：现代高并发时期 —— Epoll</h3><p>方案：精准通知，不再遍历。</p>
<p>Linux 工程师在 2.6 版本内核推出了 Epoll，彻底修好了 Select 的所有毛病。</p>
<ol>
<li><p>解决拷贝问题（红黑树）：</p>
<p>Epoll 告诉你：“别每次都把 1万个 ID 列表传给我。你在内核里建个账本（红黑树），有新连接就记上去，断连了就划掉。不用每次都重新传。”</p>
</li>
<li><p>解决遍历问题（回调 + 就绪链表）：</p>
<p>Epoll 不再傻傻地扫描所有连接。</p>
<p>它在每个连接上装了个“开关”（回调函数）。一旦网卡收到了数据，这个连接的开关触发，自动把自己弹到一个<strong>“就绪列表”</strong>里。</p>
</li>
<li><p>用户只取有效数据：</p>
<p>当你的程序被唤醒时，Epoll 直接把这个<strong>“就绪列表”</strong>给你。你拿到的一定是有数据的连接，不需要自己再去大海捞针。</p>
</li>
</ol>
<blockquote>
<p><strong>O(1)</strong></p>
</blockquote>
<h3 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h3><p>这个演进过程其实就是为了回答一个问题：<strong>当连接数（N）无限增长时，怎样让性能不下降？</strong></p>
<ol>
<li><strong>BIO</strong>：N 大了，线程炸了。</li>
<li><strong>NIO</strong>：N 大了，CPU 轮询轮疯了。</li>
<li><strong>Select</strong>：N 大了，每次复制列表、挨个扫描列表，慢死了。</li>
<li><strong>Epoll</strong>：不管 N 有多大，我只处理<strong>活跃</strong>的那几个连接。性能不受连接总数影响。</li>
</ol>
<h1 id="核心-Q-A"><a href="#核心-Q-A" class="headerlink" title="核心 Q&amp;A"></a>核心 Q&amp;A</h1><h2 id="问题-1：关于“低效”与“高效”的本质区别（Select-vs-Epoll）"><a href="#问题-1：关于“低效”与“高效”的本质区别（Select-vs-Epoll）" class="headerlink" title="问题 1：关于“低效”与“高效”的本质区别（Select vs Epoll）"></a>问题 1：关于“低效”与“高效”的本质区别（Select vs Epoll）</h2><p>文章中提到 select 有三个主要的性能缺陷（拷贝开销大、遍历开销大、FD 数量限制）。</p>
<p>请结合 epoll 的两个核心函数 epoll_ctl 和 epoll_wait，以及它内部的数据结构（红黑树、就绪链表），解释一下 epoll 具体是如何从设计层面解决 select 的这三个缺陷的？</p>
<p>没问题。既然你不了解具体的数据结构（红黑树、链表），那我们就<strong>只看它们的功能</strong>，把它们当成两个<strong>“黑盒子”</strong>或者<strong>“特殊的容器”</strong>来理解。</p>
<p>我们可以把 <code>Select</code> 和 <code>Epoll</code> 想象成两种不同的<strong>快递点</strong>管理模式。</p>
<h3 id="1-解决“拷贝开销大”和“FD-数量限制”"><a href="#1-解决“拷贝开销大”和“FD-数量限制”" class="headerlink" title="1. 解决“拷贝开销大”和“FD 数量限制”"></a>1. 解决“拷贝开销大”和“FD 数量限制”</h3><p><strong>—— 依靠 <code>epoll_ctl</code> 和“红黑树”</strong></p>
<ul>
<li><p>Select 的笨办法（无记忆）：</p>
<p>Select 没有任何存储能力。你每次（每一轮循环）都要把你要监控的 1000 个连接号码（FD）写在一张纸上交给它。</p>
<ul>
<li>这导致了：每次都要<strong>抄写</strong>（拷贝开销大），而且纸张大小固定只能写 1024 个（数量限制）。</li>
</ul>
</li>
<li><p>Epoll 的聪明办法（有记忆）：</p>
<p>Epoll 在内核里专门建了一个<strong>“档案室”（这就是红黑树</strong>的功能）。</p>
<p>这个档案室非常巨大，你想存多少个号码都行（解决了数量限制）。</p>
<ul>
<li><p>epoll_ctl 的作用：这就是<strong>“办理入驻”</strong>的手续。</p>
<p>你只需要在最开始连接建立时，调用一次 epoll_ctl，告诉内核：“帮我把这个新连接（FD）存进档案室”。</p>
</li>
<li><p><strong>效果</strong>：内核就永远记住了。以后你再调用等待函数时，<strong>不需要</strong>再把这 1000 个号码传一遍。</p>
</li>
<li><p><strong>总结</strong>：把“注册”和“等待”分开了。Select 是混在一起的，Epoll 是<strong>注册一次（epoll_ctl），终身有效</strong>。这就消除了反复拷贝。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-解决“遍历开销大”"><a href="#2-解决“遍历开销大”" class="headerlink" title="2. 解决“遍历开销大”"></a>2. 解决“遍历开销大”</h3><p><strong>—— 依靠 <code>epoll_wait</code> 和“就绪链表”</strong></p>
<ul>
<li><p>Select 的笨办法（大海捞针）：</p>
<p>当有一个快递到了，Select 不知道是谁的。它只能把你那张纸上的 1000 个号码挨个查一遍：“是你的吗？是你的吗？”（遍历开销大）。</p>
</li>
<li><p>Epoll 的聪明办法（精准送达）：</p>
<p>Epoll 除了档案室，还准备了一个<strong>“取件箱”（这就是就绪链表</strong>的功能）。</p>
<ul>
<li><p><strong>工作机制</strong>：当网卡收到数据（快递到了），因为内核早就记住了这是谁的连接，它会利用<strong>回调机制</strong>（后面会细讲），直接把这个有数据的连接号码，丢进<strong>“取件箱”</strong>里。</p>
</li>
<li><p>epoll_wait 的作用：这就是<strong>“看箱子”</strong>的动作。</p>
<p>你的程序调用 epoll_wait，实际上就是问内核：“取件箱里有东西吗？”</p>
<ul>
<li>如果箱子是空的，你就睡觉。</li>
<li>如果箱子里有 5 个号码，内核直接把这 5 个号码给你。</li>
</ul>
</li>
<li><p><strong>效果</strong>：你拿到的全是“有数据的”，根本不需要你去遍历那 1万个没数据的连接。</p>
</li>
<li><p><strong>总结</strong>：从“主动去问 1万个人”变成了“只处理箱子里这 5 个人”。效率不再受总连接数影响。</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结对照表"><a href="#总结对照表" class="headerlink" title="总结对照表"></a>总结对照表</h3><table>
<thead>
<tr>
<th><strong>Select 的缺陷</strong></th>
<th><strong>Epoll 怎么解决的？</strong></th>
<th><strong>涉及的关键部分</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>每次都要拷贝整个列表</strong></td>
<td><strong>只存一次</strong>：利用内核的“档案室”长久保存，不需要重复传。</td>
<td>函数：<code>epoll_ctl</code> 结构：红黑树（档案室）</td>
</tr>
<tr>
<td><strong>数量被限制在 1024</strong></td>
<td><strong>动态存储</strong>：“档案室”空间是动态申请的，内存够大就能一直存。</td>
<td>结构：红黑树（档案室）</td>
</tr>
<tr>
<td><strong>不知道谁有数据，必须遍历</strong></td>
<td><strong>精准通知</strong>：数据来了直接丢进“取件箱”，用户只拿箱子里的东西。</td>
<td>函数：<code>epoll_wait</code> 结构：就绪链表（取件箱）</td>
</tr>
</tbody></table>
<h2 id="问题-2：关于“回调机制”的深度理解（Epoll-的核心）"><a href="#问题-2：关于“回调机制”的深度理解（Epoll-的核心）" class="headerlink" title="问题 2：关于“回调机制”的深度理解（Epoll 的核心）"></a>问题 2：关于“回调机制”的深度理解（Epoll 的核心）</h2><p>这是这篇文章最精彩的部分。在传统的阻塞 IO 中，网卡收到数据后，内核通过回调唤醒的是“用户进程”。</p>
<p>但在 epoll 模式下，当网卡接收到数据并写入 Socket 接收队列后，并没有直接唤醒用户进程。</p>
<p>请描述一下：在 epoll 模式下，数据到达网卡后，是通过怎样的一条“回调链路”（涉及哪些对象和队列的操作），最终才让用户进程知道“有数据可读”的？</p>
<p>这是一个非常深入且关键的问题！理解了这个过程，你就彻底懂了 Epoll 为什么高效。</p>
<p>在传统的模式（阻塞 IO）里，逻辑很简单：<strong>网卡 -&gt; Socket -&gt; 直接摇醒进程</strong>。</p>
<p>但在 Epoll 模式下，为了让进程能安心睡觉，不被频繁打扰，中间加了一个<strong>“中转站”</strong>（Eventpoll 对象）。</p>
<p>我们可以把这个过程看作一个<strong>“多米诺骨牌”</strong>的连锁反应。</p>
<p>请看这个关键的<strong>“四步回调链路”</strong>：</p>
<h3 id="第一步：数据进站（网卡-Socket）"><a href="#第一步：数据进站（网卡-Socket）" class="headerlink" title="第一步：数据进站（网卡 -&gt; Socket）"></a>第一步：数据进站（网卡 -&gt; Socket）</h3><p>当数据到达网卡，经过内核处理后，会被放到<strong>该连接对应的 Socket 数据接收队列</strong>中。</p>
<ul>
<li><em>通俗解释</em>：快递员把包裹送到了具体的“5号桌”上。</li>
</ul>
<h3 id="第二步：触发“机关”（Socket-回调函数）"><a href="#第二步：触发“机关”（Socket-回调函数）" class="headerlink" title="第二步：触发“机关”（Socket -&gt; 回调函数）"></a>第二步：触发“机关”（Socket -&gt; 回调函数）</h3><p>这是最关键的一步！</p>
<p>在调用 epoll_ctl 注册连接时，内核已经在 Socket 上安装了一个特殊的“机关”（回调函数 ep_poll_callback）。</p>
<p>数据一放到 Socket 队列里，这个机关瞬间就被触发了。</p>
<ul>
<li><em>通俗解释</em>：快递刚放到桌子上，桌子底下的<strong>传感器</strong>就亮了。注意：<strong>这时候根本没有叫醒用户进程！</strong></li>
</ul>
<h3 id="第三步：搬运名单（回调函数-就绪链表）"><a href="#第三步：搬运名单（回调函数-就绪链表）" class="headerlink" title="第三步：搬运名单（回调函数 -&gt; 就绪链表）"></a>第三步：搬运名单（回调函数 -&gt; 就绪链表）</h3><p>这个“机关”（回调函数）被触发后，它做了一件非常聪明的事：</p>
<p>它把这个 Socket 的引用（身份证），复制到了 Epoll 对象的<strong>“就绪链表”</strong>（rdllist）中。</p>
<ul>
<li><em>通俗解释</em>：传感器自动把“5号桌有快递”这条信息，发送到了大堂经理的<strong>“待办事项清单”</strong>上。</li>
</ul>
<h3 id="第四步：最终唤醒（就绪链表-用户进程）"><a href="#第四步：最终唤醒（就绪链表-用户进程）" class="headerlink" title="第四步：最终唤醒（就绪链表 -&gt; 用户进程）"></a>第四步：最终唤醒（就绪链表 -&gt; 用户进程）</h3><p>这时候，用户的进程正在 epoll_wait 那里睡觉，等着“待办事项清单”里有东西。</p>
<p>一旦第三步完成，清单里有了东西，内核才会真正唤醒用户进程。</p>
<ul>
<li><em>通俗解释</em>：大堂经理看到清单上有字了，这才去拍醒在旁边睡觉的服务员：“醒醒，清单上有活儿了，按着清单去干活吧。”</li>
</ul>
<h3 id="总结这张图谱"><a href="#总结这张图谱" class="headerlink" title="总结这张图谱"></a>总结这张图谱</h3><table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>动作发生地</strong></th>
<th><strong>发生了什么？</strong></th>
<th><strong>关键对象&#x2F;队列</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>Socket</strong></td>
<td>数据到达</td>
<td>Socket 的接收队列</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>Socket</strong></td>
<td>触发机关</td>
<td><strong><code>ep_poll_callback</code> (回调函数)</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>Eventpoll</strong></td>
<td>记录谁有数据</td>
<td><strong><code>rdllist</code> (就绪链表)</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>Process</strong></td>
<td>叫醒进程</td>
<td>进程的等待队列</td>
</tr>
</tbody></table>
<p>核心区别：</p>
<p>传统 IO 是数据到了 -&gt; 叫醒人（人醒了还得自己找哪桌有数据）。</p>
<p>Epoll 是数据到了 -&gt; 记在清单上 -&gt; 叫醒人（人醒了直接拿清单，非常快）。</p>
<p>这样解释，您能理解这条“曲线救国”的回调链路了吗？</p>
<h2 id="问题-3：关于-Poll-的定位"><a href="#问题-3：关于-Poll-的定位" class="headerlink" title="问题 3：关于 Poll 的定位"></a>问题 3：关于 Poll 的定位</h2><p>poll 技术在 select 和 epoll 之间起到了承上启下的作用。</p>
<p>请问 poll 主要是为了解决 select 的什么限制而诞生的？它是如何解决的？但为什么它最终没有成为高并发的终极解决方案（即它保留了 select 的哪些致命缺点）？</p>
<p>这是一个承上启下的关键问题。<code>poll</code> 的定位确实非常尴尬，把它看作是 <strong>Select v2.0（修复版）</strong> 最合适。</p>
<p>我们通过三个维度来回答你的问题：它修好了什么？怎么修的？为什么还是不够好？</p>
<h3 id="1-解决了-Select-的什么限制？"><a href="#1-解决了-Select-的什么限制？" class="headerlink" title="1. 解决了 Select 的什么限制？"></a>1. 解决了 Select 的什么限制？</h3><p><strong>—— 解决了“最大连接数 1024”的物理限制。</strong></p>
<ul>
<li><p>Select 的痛点：</p>
<p>Select 就像一张只有 1024 个格子的表格（fd_set）。这是在操作系统内核编译时就写死的。</p>
<p>如果你想让它监控第 1025 个连接，或者你有 2 万个用户同时在线，Select 直接两手一摊：“表格满了，记不下了。”</p>
</li>
<li><p>Poll 的使命：</p>
<p>就是为了打破这个“数量枷锁”，让一个线程能够监控任意数量（只要内存够）的连接。</p>
</li>
</ul>
<h3 id="2-它是如何解决的？"><a href="#2-它是如何解决的？" class="headerlink" title="2. 它是如何解决的？"></a>2. 它是如何解决的？</h3><p><strong>—— 换了“记账工具”：从“固定位图”变成了“动态数组&#x2F;链表”。</strong></p>
<ul>
<li><p>Select 的工具：</p>
<p>Bitmap（位图）。就像一张A4纸，大小固定，格子画好了，不能改。</p>
</li>
<li><p>Poll 的工具：</p>
<p>Pollfd 数组（在内核内部是基于链表扩展）。就像一个卷轴。</p>
<ul>
<li>你想监控 1000 个？那就拉出 1 米长的卷轴。</li>
<li>你想监控 10 万个？那就拉出 100 米长的卷轴。</li>
<li>用户在调用 <code>poll</code> 时，直接传递一个数组进去，想传多大传多大。</li>
</ul>
</li>
</ul>
<p><strong>结果</strong>：从此以后，Linux 服务器终于可以支持 1 万、10 万甚至更多的并发连接了。</p>
<h3 id="3-为什么它没有成为终极方案？（保留了-select-的哪些缺点）"><a href="#3-为什么它没有成为终极方案？（保留了-select-的哪些缺点）" class="headerlink" title="3. 为什么它没有成为终极方案？（保留了 select 的哪些缺点）"></a>3. 为什么它没有成为终极方案？（保留了 select 的哪些缺点）</h3><p><strong>—— 解决了“能不能存”的问题，但没解决“找得慢”的问题。</strong></p>
<p>Poll 虽然把名单拉长了，但它检查名单的方式竟然<strong>完全没变</strong>！这导致了它依然有两个致命缺陷，这正是 <strong>Epoll</strong> 后来必须出现的原因：</p>
<p>缺陷一：还是要“全量遍历”（线性扫描 O(N)）</p>
<p>这是最要命的。</p>
<ul>
<li><strong>场景</strong>：你有 10 万个连接（Poll 能存下了）。</li>
<li><strong>Poll 的做法</strong>：内核拿着这 10 万个人的名单，<strong>从头到尾挨个问一遍</strong>：“你有数据吗？你有数据吗？……”</li>
<li><strong>后果</strong>：虽然名单能存下，但是问一圈需要好几秒。如果有数据的人在名单最后，那你就得等很久。连接数越多，Poll 就越慢。</li>
</ul>
<p><strong>缺陷二：还是要“全量拷贝”</strong></p>
<ul>
<li><strong>场景</strong>：每次调用 <code>poll</code> 函数。</li>
<li><strong>Poll 的做法</strong>：你依然需要把这 10 万个人的名单，从用户内存<strong>完整地拷贝</strong>到内核内存。</li>
<li><strong>后果</strong>：仅仅是为了检查一次状态，就要搬运几 MB 的数据，非常浪费 CPU 和内存带宽。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Select</strong>：只能带 1024 个兵，而且检阅时要挨个看。</li>
<li><strong>Poll</strong>：能带 10 万个兵（解决了数量问题），<strong>但是检阅时依然要挨个看</strong>（没解决效率问题）。</li>
<li><strong>Epoll</strong>：能带 10 万个兵，而且<strong>谁举手只看谁</strong>（彻底解决了效率问题）。</li>
</ul>
<p>所以，Poll 只是解决了“温饱问题”（数量够用），而 Epoll 才是真正解决了“现代化问题”（高效率）。</p>
<h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5xj42JPKG8o5T7hjXIKywg">深入学习IO多路复用 select&#x2F;poll&#x2F;epoll 实现原理</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&scene=21&poc_token=HIRrbGmjpBOeEyL5fFGzq3Gi6KyCsTNI_92GnSxu">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2026/01/18/%E3%80%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E7%A3%81%E7%9B%98/">【系统设计】数据结构选型：内存与磁盘</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2026/01/11/%E3%80%90%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%91Pulsar%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">【消息队列】Pulsar基本使用</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Rong Zhao</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.29.1">Stellar 1.29.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-text">基本概念与发展过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%B0%8F%E8%AF%8D%E5%85%B8%EF%BC%88%E5%85%88%E7%9C%8B%E6%87%82%E8%BF%993%E4%B8%AA%E8%AF%8D%EF%BC%89"><span class="toc-text">第一部分：基础概念小词典（先看懂这3个词）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%88%E9%97%AE%E9%A2%98-%E6%96%B9%E6%A1%88-%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">第二部分：发展过程（问题 -&gt; 方案 -&gt; 新问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%BF%9C%E5%8F%A4%E6%97%B6%E6%9C%9F-%E2%80%94%E2%80%94-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E-IO-BIO"><span class="toc-text">第一阶段：远古时期 —— 同步阻塞 IO (BIO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BF%99%E8%BD%AE%E8%AF%A2%E6%97%B6%E6%9C%9F-%E2%80%94%E2%80%94-%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E-IO-NIO"><span class="toc-text">第二阶段：忙轮询时期 —— 同步非阻塞 IO (NIO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%BB%A3%E7%90%86%E4%BA%BA%E6%97%B6%E6%9C%9F-%E2%80%94%E2%80%94-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-Select"><span class="toc-text">第三阶段：代理人时期 —— IO 多路复用 (Select)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%8E%B0%E4%BB%A3%E9%AB%98%E5%B9%B6%E5%8F%91%E6%97%B6%E6%9C%9F-%E2%80%94%E2%80%94-Epoll"><span class="toc-text">第四阶段：现代高并发时期 —— Epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%80%BB%E7%BB%93"><span class="toc-text">全文总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-Q-A"><span class="toc-text">核心 Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1%EF%BC%9A%E5%85%B3%E4%BA%8E%E2%80%9C%E4%BD%8E%E6%95%88%E2%80%9D%E4%B8%8E%E2%80%9C%E9%AB%98%E6%95%88%E2%80%9D%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%EF%BC%88Select-vs-Epoll%EF%BC%89"><span class="toc-text">问题 1：关于“低效”与“高效”的本质区别（Select vs Epoll）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A7%A3%E5%86%B3%E2%80%9C%E6%8B%B7%E8%B4%9D%E5%BC%80%E9%94%80%E5%A4%A7%E2%80%9D%E5%92%8C%E2%80%9CFD-%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6%E2%80%9D"><span class="toc-text">1. 解决“拷贝开销大”和“FD 数量限制”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E2%80%9C%E9%81%8D%E5%8E%86%E5%BC%80%E9%94%80%E5%A4%A7%E2%80%9D"><span class="toc-text">2. 解决“遍历开销大”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-text">总结对照表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2%EF%BC%9A%E5%85%B3%E4%BA%8E%E2%80%9C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E2%80%9D%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%EF%BC%88Epoll-%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-text">问题 2：关于“回调机制”的深度理解（Epoll 的核心）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%BF%9B%E7%AB%99%EF%BC%88%E7%BD%91%E5%8D%A1-Socket%EF%BC%89"><span class="toc-text">第一步：数据进站（网卡 -&gt; Socket）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%A7%A6%E5%8F%91%E2%80%9C%E6%9C%BA%E5%85%B3%E2%80%9D%EF%BC%88Socket-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">第二步：触发“机关”（Socket -&gt; 回调函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E6%90%AC%E8%BF%90%E5%90%8D%E5%8D%95%EF%BC%88%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-%E5%B0%B1%E7%BB%AA%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-text">第三步：搬运名单（回调函数 -&gt; 就绪链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E6%9C%80%E7%BB%88%E5%94%A4%E9%86%92%EF%BC%88%E5%B0%B1%E7%BB%AA%E9%93%BE%E8%A1%A8-%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-text">第四步：最终唤醒（就绪链表 -&gt; 用户进程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E8%BF%99%E5%BC%A0%E5%9B%BE%E8%B0%B1"><span class="toc-text">总结这张图谱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-3%EF%BC%9A%E5%85%B3%E4%BA%8E-Poll-%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-text">问题 3：关于 Poll 的定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A7%A3%E5%86%B3%E4%BA%86-Select-%E7%9A%84%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-text">1. 解决了 Select 的什么限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-text">2. 它是如何解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%B2%A1%E6%9C%89%E6%88%90%E4%B8%BA%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88%EF%BC%9F%EF%BC%88%E4%BF%9D%E7%95%99%E4%BA%86-select-%E7%9A%84%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9%EF%BC%89"><span class="toc-text">3. 为什么它没有成为终极方案？（保留了 select 的哪些缺点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">拓展阅读</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>Scroll to Top</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)

    const messages = {
      light: `Switched to Light Mode`,
      dark: `Switched to Dark Mode`,
      auto: `Switched to Auto Mode`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    }
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
