<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>xinranzero</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="xinranzero">
<meta property="og:url" content="http://xinranzero.com/index.html">
<meta property="og:site_name" content="xinranzero">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Rong Zhao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xinranzero" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xinranzero</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xinranzero.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-【Java基础】【java.lang.reflect】Junit单元测试、反射" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/" class="article-date">
  <time class="dt-published" datetime="2024-04-10T01:28:55.000Z" itemprop="datePublished">2024-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/">【Java基础】【java.lang.reflect】Junit单元测试、反射</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>单元测试</p>
<ul>
<li>单元测试就是<strong>针对最小的功能单元</strong>(方法)，编写测试代码对该功能<strong>进行正确性测试</strong>。</li>
</ul>
<p>目前测试方法是怎么进行的？ 存在什么问题 ？</p>
<ul>
<li>只能编写main方法，并在main方法中再去调用其他方法进行测试。</li>
<li>使用起来很不灵活，无法实现自动化测试。</li>
<li>无法得到测试的报告，需要程序员自己去观察测试是否成功。</li>
</ul>
<p>Junit单元测试框架</p>
<ul>
<li>JUnit是使用Java语言实现的单元测试框架，它是第三方公司开源出来的，很多<strong>开发工具已经集成了Junit框架</strong>，比如IDEA。</li>
</ul>
<p>优点</p>
<ul>
<li>编写的测试代码很灵活，<strong>可以指某个测试方法执行测试，也支持一键完成自动化测试</strong>。</li>
<li>不需要程序员去分析测试的结果，会<strong>自动生成测试报告</strong>出来。</li>
<li>提供了更强大的测试能力。</li>
</ul>
<p>需求</p>
<ul>
<li>某个系统，有多个业务方法，请使用Junit框架完成对这些方法的单元测试。</li>
</ul>
<p>具体步骤</p>
<ol>
<li>将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要我们自己手工导入了）。</li>
<li><strong>编写测试类、测试类方法</strong>（注意：<strong>测试方法必须是公共的，无参数，无返回值的非静态方法</strong>）。</li>
<li>【灵魂】<strong>必须在测试方法上使用@Test注解</strong>（标注该方法是一个测试方法）。（在报错的地方使用alt+enter，导入JUnit4。这个是经典版本，但是版本5可读性更好。）</li>
<li>在测试方法中，编写程序调用被测试的方法即可。（测试某个方法直接右键该方法启动测试。测试全部方法，可以选择类或者模块启动。）</li>
<li>选中测试方法，右键选择“JUnit运行” ，如果测试<strong>通过</strong>则是<strong>绿色</strong>；如果测试<strong>失败</strong>，则是<strong>红色</strong>。</li>
</ol>
<p>先准备一个类，假设写了一个StringUtil工具类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;名字长度：&quot;</span>+name.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，写一个测试类，测试StringUtil工具类中的方法能否正常使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtilTest</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrintNumber</span><span class="params">()</span>&#123;</span><br><span class="line">        StringUtil.printNumber(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        StringUtil.printNumber(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完代码之后，我们会发现测试方法左边，会有一个绿色的三角形按钮。点击这个按钮，就可以运行测试方法。</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668507501024.png" alt="1668507501024"></p>
<h2 id="单元测试断言"><a href="#单元测试断言" class="headerlink" title="单元测试断言"></a>单元测试断言</h2><p>断言：意思是程序员可以预测程序的运行结果，检查程序的运行结果是否与预期一致。**</p>
<p>我们在StringUtil类中新增一个测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">(String data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们在StringUtilTest类中写一个测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtilTest</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetMaxIndex</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> StringUtil.getMaxIndex(<span class="literal">null</span>);</span><br><span class="line">       System.out.println(index1);</span><br><span class="line">        </span><br><span class="line">       <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> StringUtil.getMaxIndex(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">       System.out.println(index2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//断言机制：预测index2的结果</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;方法内部有Bug&quot;</span>,<span class="number">4</span>,index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试方法，结果如下图所示，表示我们预期值与实际值不一致</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668508226111.png" alt="1668508226111"></p>
<h2 id="Junit框架的常见注解"><a href="#Junit框架的常见注解" class="headerlink" title="Junit框架的常见注解"></a>Junit框架的常见注解</h2><p>常见注解(Junit 4.xxxx版本)</p>
<ol>
<li>@Test。测试方法。</li>
<li>@Before。用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。</li>
<li>@After。用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。</li>
<li>@BeforeClass。用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。</li>
<li>@AfterClass。用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。</li>
</ol>
<p>特点如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>被<span class="meta">@BeforeClass</span>标记的方法,执行在所有方法之前</span><br><span class="line"><span class="number">2.</span>被<span class="meta">@AfterCalss</span>标记的方法，执行在所有方法之后</span><br><span class="line"><span class="number">3.</span>被<span class="meta">@Before</span>标记的方法，执行在每一个<span class="meta">@Test</span>方法之前</span><br><span class="line"><span class="number">4.</span>被<span class="meta">@After</span>标记的方法，执行在每一个<span class="meta">@Test</span>方法之后</span><br></pre></td></tr></table></figure>

<p>常见注解(Junit 5.xxxx版本)</p>
<ol>
<li>@Test。测试方法。</li>
<li>@BeforeEach。用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。</li>
<li>@AfterEach。用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。</li>
<li>@BeforeAll。用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。</li>
<li>@AfterAll。用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。</li>
</ol>
<ul>
<li>开始执行的方法:初始化资源。</li>
<li>执行完之后的方法:释放资源。</li>
</ul>
<p>作用？应用场景？</p>
<p>假设我想在每个测试方法中使用Socket对象，并且用完之后，需要把Socket关闭。代码就可以按照下面的结构来设计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtilTest</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test1 Before 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test11 BeforeClass 执行了&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化Socket对象</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test2 After 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterCalss</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test22</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test22 AfterCalss 执行了&quot;</span>);</span><br><span class="line">         <span class="comment">//关闭Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="认识反射Reflection"><a href="#认识反射Reflection" class="headerlink" title="认识反射Reflection"></a>认识反射Reflection</h2><p>【核心思想】得到编译以后的class文件对象。</p>
<ul>
<li>反射指的是<strong>允许以编程方式访问已加载类的成分（成员变量、方法、构造器等）</strong>。</li>
<li>在java.lang.reflect包中。</li>
<li>主要是用来做框架的。好理解一点，我们在写代码的时候，IDEA给我们提示的可以调用的方法。</li>
</ul>
<p>反射学什么？</p>
<ol>
<li><strong>加载类，获取类的字节码</strong>：Class对象。<ol>
<li>反射第一步：获取类：Class。</li>
<li>获取类的构造器：Constructor。</li>
<li>获取类的成员变量：Field。</li>
<li>获取类的成员方法：Method。</li>
</ol>
</li>
<li>获取类的构造器：Constructor对象。</li>
<li>获取类的成员变量：Field对象。</li>
<li>获取类的成员方法：Method对象。</li>
</ol>
<p>之后再看反射的应用场景。</p>
<h2 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h2><p>反射第一步，获取Class类的对象。（3种方式。）</p>
<ol>
<li>Class c1 &#x3D; 类名.class。</li>
<li>调用Class提供的方法：public static Class.forName(String package)。</li>
<li>Object提供的方法：public Class getClass()。</li>
</ol>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/image-20240410171810088.png" alt="image-20240410171810088"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1Class</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获取全类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获取简单类名</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.d2_reflect.Student&quot;</span>);</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(c2 == c3); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取类的构造器"><a href="#获取类的构造器" class="headerlink" title="获取类的构造器"></a>获取类的构造器</h2><h3 id="Class类提供的几个方法"><a href="#Class类提供的几个方法" class="headerlink" title="Class类提供的几个方法"></a>Class类提供的几个方法</h3><ol>
<li>Constructor&lt;?&gt;[] getConstructors()。返回所有构造器对象的数组（<strong>只能拿public的</strong>）。</li>
<li>Constructor&lt;?&gt;[] getDeclaredConstructors()。返回所有构造器对象的数组，<strong>存在就能拿到</strong>。</li>
<li>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)。<strong>返回单个构造器对象</strong>（只能拿<strong>public</strong>的）。</T></li>
<li>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)。返回单个构造器对象，存在就能拿到。</T></li>
</ol>
<p>方便记忆：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get:获取</span><br><span class="line">Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个<span class="keyword">public</span>修饰的</span><br><span class="line">Constructor: 构造方法的意思</span><br><span class="line">后缀s: 表示可以获取多个，没有后缀s只能获取一个</span><br></pre></td></tr></table></figure>

<p>假设现在有一个Cat类，里面有几个构造方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们写一个测试方法，来测试获取类中所有的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2Constructor</span>()&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：必须先得到这个类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类的全部构造器</span></span><br><span class="line">        Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">//3、遍历数组中的每一个构造器对象。</span></span><br><span class="line">        <span class="keyword">for</span>(Constructor constructor: constructors)&#123;</span><br><span class="line">            System.out.println(constructor.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才的是获取Cat类中所有的构造器，接下来试一试单个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2Constructor</span>()&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：必须先得到这个类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类public修饰的空参数构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> c.getConstructor();</span><br><span class="line">        System.out.println(constructor1.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor1.getParameterCount());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、获取private修饰的有两个参数的构造器，第一个参数String类型，第二个参数int类型</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> </span><br><span class="line">            c.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(constructor2.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor1.getParameterCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取类构造器的作用"><a href="#获取类构造器的作用" class="headerlink" title="获取类构造器的作用"></a>获取类构造器的作用</h3><p>初始化对象返回。注意：这两个方法时属于Constructor的，需要用Constructor对象来调用。 </p>
<ol>
<li>T newInstance(Object… initargs)。根据指定的构造器创建对象。（反射后的构造器依然是创建对象的。）</li>
<li>public void  setAccessible(boolean flag)。设置为true,表示取消访问检查，进行暴力反射。（–&gt;反射会破坏封装性，私有的也可以执行了。）</li>
</ol>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>constructor1和constructor2分别表示Cat类中的两个构造器。现在我要把这两个构造器执行起来</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668578807439.png" alt="1668578807439"></p>
<p>由于构造器是private修饰的，先需要调用<code>setAccessible(true)</code> 表示禁止检查访问控制，然后再调用<code>newInstance(实参列表)</code> 就可以执行构造器，完成对象的初始化了。</p>
<p>代码如下：为了看到构造器真的执行， 故意在两个构造器中分别加了两个打印语句</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668579315586.png" alt="1668579315586"></p>
<p>代码的执行结果如下图所示：</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668579177901.png" alt="1668579177901"></p>
<p>注意：上面这种代码风格，看起来没什么必要，可以先稍微记一记，以后学习框架的时候有用。</p>
<h2 id="获取类的成员变量-使用"><a href="#获取类的成员变量-使用" class="headerlink" title="获取类的成员变量&amp;使用"></a>获取类的成员变量&amp;使用</h2><h3 id="Class类中提供的获取成员变量的方法"><a href="#Class类中提供的获取成员变量的方法" class="headerlink" title="Class类中提供的获取成员变量的方法"></a>Class类中提供的获取成员变量的方法</h3><ol>
<li>Field[] getFields()。返回所有成员变量对象的<strong>数组</strong>（只<strong>能拿public</strong>的）。</li>
<li>Field[] getDeclaredFields()。返回所有成员变量对象的<strong>数组</strong>，<strong>存在就能拿到</strong>。</li>
<li>Field getField(String name)。返回<strong>单个</strong>成员变量对象（只能拿<strong>public</strong>的）。</li>
<li>Field getDeclaredField(String name)。返回<strong>单个</strong>成员变量对象，<strong>存在就能拿到</strong>。</li>
</ol>
<p>记忆规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get:获取</span><br><span class="line">Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个<span class="keyword">public</span>修饰的</span><br><span class="line">Field: 成员变量的意思</span><br><span class="line">后缀s: 表示可以获取多个，没有后缀s只能获取一个</span><br></pre></td></tr></table></figure>

<h3 id="获取成员变量的作用"><a href="#获取成员变量的作用" class="headerlink" title="获取成员变量的作用"></a>获取成员变量的<strong>作用</strong></h3><p>依然是<strong>在某个对象中取值、赋值</strong>。</p>
<h3 id="Field类中用于取值、赋值的方法"><a href="#Field类中用于取值、赋值的方法" class="headerlink" title="Field类中用于取值、赋值的方法"></a>Field类中用于取值、赋值的方法</h3><ol>
<li>void set(Object obj, Object value)。赋值。</li>
<li>Object get(Object obj)。获取值。</li>
<li>setAccessible(boolean)。如果某成员变量是非public的，需要打开权限（暴力反射），然后再取值、赋值。</li>
</ol>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><ul>
<li>设有一个Cat类它有若干个成员变量，用Class类提供 的方法将成员变量的对象获取出来。</li>
</ul>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668579681294.png" alt="1668579681294"></p>
<p>执行完上面的代码之后，我们可以看到控制台上打印输出了，每一个成员变量的名称和它的类型。</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668579804732.png" alt="1668579804732"></p>
<ul>
<li>获取到成员变量的对象之后该如何使用呢？</li>
</ul>
<p>在Filed类中提供给给成员变量赋值和获取值的方法，如下图所示。</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668580075962.png" alt="1668580075962"></p>
<p>再次强调一下设置值、获取值的方法时Filed类的需要用Filed类的对象来调用，而且不管是设置值、还是获取值，都需要依赖于该变量所属的对象。代码如下</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668580288930.png" alt="1668580288930"></p>
<p>执行代码，控制台会有如下的打印</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668580517173.png" alt="1668580517173"></p>
<h2 id="获取类的成员方法"><a href="#获取类的成员方法" class="headerlink" title="获取类的成员方法"></a>获取类的成员方法</h2><p>使用反射技术获取方法对象并使用</p>
<ul>
<li>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</li>
</ul>
<p>Class类中用于获取成员方法的方法</p>
<ol>
<li>Method[] getMethods()。返回所有成员方法对象的<strong>数组</strong>（只能拿<strong>public</strong>的）。</li>
<li>Method[] getDeclaredMethods()。返回所有成员方法对象的<strong>数组</strong>，<strong>存在就能拿到</strong>。</li>
<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)。返回<strong>单个</strong>成员方法对象（只能拿<strong>public</strong>的）。</li>
<li>Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)。返回<strong>单个</strong>成员方法对象，<strong>存在就能拿到</strong>。</li>
</ol>
<p>使用反射技术获取方法对象并使用</p>
<ul>
<li>获取成员方法的<strong>作用依然是在某个对象中进行执行此方法</strong>。</li>
</ul>
<p>Method类中用于触发执行的方法</p>
<ol>
<li>Object invoke(Object obj, Object… args)。<ul>
<li>参数一：用obj对象调用该方法</li>
<li>参数二：调用方法的传递的参数（如果没有就不写）</li>
<li>返回值：方法的返回值（如果没有就不写）</li>
</ul>
</li>
<li>setAccessible(boolean)。如果某成员方法是非public的，需要打开权限（暴力反射），然后再触发执行。</li>
</ol>
<p>把<code>run()</code>方法和<code>eat(String name)</code>方法执行起来。看分割线之下的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3Method</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：先获取到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类中的全部成员方法</span></span><br><span class="line">        Method[] methods = c.getDecalaredMethods();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、遍历这个数组中的每一个方法对象</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;--&gt;&quot;</span>+method.getParameterCount()+<span class="string">&quot;--&gt;&quot;</span>+method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4、获取private修饰的run方法，得到Method对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDecalaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="comment">//执行run方法,在执行前需要取消权限检查</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        run.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs1</span> <span class="operator">=</span> run.invoke(cat);</span><br><span class="line">        System.out.println(rs1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、获取private 修饰的eat(String name)方法，得到Method对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs2</span> <span class="operator">=</span> eat.invoke(cat,<span class="string">&quot;鱼儿&quot;</span>);</span><br><span class="line">        System.out.println(rs2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下图所示：run()方法执行后打印<code>猫跑得贼快~~</code>，返回<code>null</code>； eat()方法执行完，直接返回<code>猫最爱吃:鱼儿</code></p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668582519455.png" alt="1668582519455"></p>
<h2 id="作用、应用场景"><a href="#作用、应用场景" class="headerlink" title="作用、应用场景"></a>作用、应用场景</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>基本作用：得到一个类的全部成分然后操作；</li>
<li>破坏封装性；</li>
<li>最重要的用途：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</li>
</ol>
<h3 id="一个简易的框架"><a href="#一个简易的框架" class="headerlink" title="一个简易的框架"></a>一个简易的框架</h3><p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/image-20240410220915153.png" alt="image-20240410220915153"></p>
<p>步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先写好两个类，一个Student类和Teacher类</span><br><span class="line"><span class="number">2.</span>写一个ObjectFrame类代表框本架</span><br><span class="line">	在ObjectFrame类中定义一个saveObject(Object obj)方法，用于将任意对象存到文件中去</span><br><span class="line">	参数：Object obj: 就表示要存入文件中的对象</span><br><span class="line">	</span><br><span class="line"><span class="number">3.</span>编写方法内部的代码，往文件中存储对象的属性名和属性值</span><br><span class="line">	<span class="number">1</span>)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。</span><br><span class="line">	<span class="number">2</span>)接着就通过反射获取类的成员变量信息了（变量名、变量值）</span><br><span class="line">	<span class="number">3</span>)把变量名和变量值写到文件中去</span><br></pre></td></tr></table></figure>

<p>写一个ObjectFrame表示自己设计的框架，代码如下图所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectFrame</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;模块名\\src\\data.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//1)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。</span></span><br><span class="line">		<span class="comment">//2)接着就通过反射获取类的成员变量信息了（变量名、变量值）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> obj.getClass(); <span class="comment">//获取字节码</span></span><br><span class="line">        ps.println(<span class="string">&quot;---------&quot;</span>+class.getSimpleName()+<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Field[] fields = c.getDeclaredFields(); <span class="comment">//获取所有成员变量</span></span><br><span class="line">		<span class="comment">//3)把变量名和变量值写到文件中去</span></span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">            ps.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自己设计的框架，往文件中写入Student对象的信息和Teacher对象的信息。</p>
<p>先准备好Student类和Teacher类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个测试类，在测试中类创建一个Student对象，创建一个Teacher对象，用ObjectFrame的方法把这两个对象所有的属性名和属性值写到文件中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5Frame</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黑马吴彦祖&quot;</span>,<span class="number">45</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">185.3</span>, <span class="string">&quot;篮球，冰球，阅读&quot;</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;播妞&quot;</span>,<span class="number">999.9</span>);</span><br><span class="line">        </span><br><span class="line">        ObjectFrame.save(s1);</span><br><span class="line">        ObjectFrame.save(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开data.txt文件，内容如下图所示，说明框架的功能已经实现了。</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1668584556229.png" alt="1668584556229"></p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="认识注解-定义注解"><a href="#认识注解-定义注解" class="headerlink" title="认识注解&amp;定义注解"></a>认识注解&amp;定义注解</h2><ul>
<li>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</li>
<li>Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</li>
</ul>
<h2 id="自定义注解-—-格式"><a href="#自定义注解-—-格式" class="headerlink" title="自定义注解 — 格式"></a>自定义注解 — 格式</h2><p>自定义注解就是自己做一个注解来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123;</span><br><span class="line">	<span class="keyword">public</span> 属性类型 属性名() <span class="keyword">default</span> 默认值 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>属性类型：Java支持的数据类型基本上都支持。</li>
</ul>
<p>注解的作用</p>
<ul>
<li><strong>对Java中类、方法、成员变量做标记，然后进行特殊处理</strong>，至于到底做何种处理由业务需求来决定。</li>
<li>例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</li>
</ul>
<p>特殊属性</p>
<ul>
<li>value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</li>
<li>但是如果有多个属性,  且多个属性没有默认值，那么value名称是不能省略的。</li>
</ul>
<p>比如：现在我们自定义一个MyTest注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;	<span class="comment">//default true 表示默认值为true,使用时可以不赋值。</span></span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好MyTest注解之后，我们可以使用MyTest注解在类上、方法上等位置做标记。注意使用注解时需要加@符号，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest1</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：注解的属性名如何是value的话，并且只有value没有默认值，使用注解时value名称可以省略。比如现在重新定义一个MyTest2注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest2&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">//特殊属性</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好MyTest2注解后，再将@MyTest2标记在类上，此时value属性名可以省略，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest2(&quot;孙悟空&quot;)</span> <span class="comment">//等价于 @MyTest2(value=&quot;孙悟空&quot;)</span></span><br><span class="line"><span class="meta">@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest1</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的本质是<strong>接口</strong></p>
<p>想要搞清楚注解本质是什么东西，我们可以把注解的字节码进行反编译，使用XJad工具进行反编译。经过对MyTest1注解字节码反编译我们会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>MyTest1注解本质上是接口，每一个注解接口都继承子Annotation接口</span><br><span class="line"><span class="number">2.</span>MyTest1注解中的属性本质上是抽象方法</span><br><span class="line"><span class="number">3.</span><span class="meta">@MyTest1</span>实际上是作为MyTest接口的实现类对象</span><br><span class="line"><span class="number">4.</span><span class="meta">@MyTest1(aaa=&quot;孙悟空&quot;,bbb=false,ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span>里面的属性值，可以通过调用aaa()、bbb()、ccc()方法获取到。 【别着急，继续往下看，再解析注解时会用到】</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669604928912.png" alt="1669604928912"></p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解：注解注解的注解。 </p>
<p>元注解有两个：</p>
<ul>
<li>@Target: 约束自定义注解只能在哪些地方使用。</li>
<li>@Retention：申明注解的生命周期。</li>
</ul>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669605746113.png" alt="1669605746113"></p>
<h3 id="Target注解和-Retention注解"><a href="#Target注解和-Retention注解" class="headerlink" title="@Target注解和@Retention注解"></a>@Target注解和@Retention注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>是用来声明注解只能用在那些位置，比如：类上、方法上、成员变量上等</span><br><span class="line"><span class="meta">@Retetion</span>是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669605786028.png" alt="1669605786028"></p>
<h3 id="Target元注解的使用："><a href="#Target元注解的使用：" class="headerlink" title="@Target元注解的使用："></a>@Target元注解的使用：</h3><p>比如定义一个MyTest3注解，并添加@Target注解用来声明MyTest3的使用位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>	<span class="comment">//声明@MyTest3注解只能用在类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们把@MyTest3用来类上观察是否有错，再把@MyTest3用在方法上、变量上再观察是否有错</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669606261919.png" alt="1669606261919"></p>
<p>如果我们定义MyTest3注解时，使用@Target注解属性值写成下面样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest3注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>	</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再观察，@MyTest用在类上、方法上、变量上是否有错</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669606451308.png" alt="1669606451308"></p>
<h3 id="Retetion元注解的使用"><a href="#Retetion元注解的使用" class="headerlink" title="@Retetion元注解的使用"></a>@Retetion元注解的使用</h3><p>定义MyTest3注解时，给MyTest3注解添加@Retetion注解来<strong>声明MyTest3注解保留的时期</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retetion</span>是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期</span><br><span class="line">	<span class="meta">@Retetion(RetetionPloicy.SOURCE)</span>: 注解保留到源代码时期、字节码中就没有了</span><br><span class="line">	<span class="meta">@Retetion(RetetionPloicy.CLASS)</span>: 注解保留到字节码中、运行时注解就没有了</span><br><span class="line">	<span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span>：注解保留到运行时期</span><br><span class="line">	【自己写代码时，比较常用的是保留到运行时期】</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest3注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>	</span><br><span class="line"><span class="comment">//控制使用了@MyTest3注解的代码中，@MyTest3保留到运行时期</span></span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</p>
<ul>
<li>可以通过反射技术把类上、方法上、变量上的注解对象获取出来，然后通过调用方法就可以获取注解上的属性值了。</li>
</ul>
<p>解析注解套路如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果注解在类上，先获取类的字节码对象，再获取类上的注解</span><br><span class="line"><span class="number">2.</span>如果注解在方法上，先获取方法对象，再获取方法上的注解</span><br><span class="line"><span class="number">3.</span>如果注解在成员变量上，先获取成员变量对象，再获取变量上的注解</span><br><span class="line">总之：注解在谁身上，就先获取谁，再用谁获取谁身上的注解</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669607820853.png" alt="1669607820853"></p>
<p>解析来看一个案例，来演示解析注解的代码编写</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669607882128.png" alt="1669607882128"></p>
<p>按照需求要求一步一步完成</p>
<p>① 先定义一个MyTest4注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest4注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>	</span><br><span class="line"><span class="comment">//控制使用了@MyTest4注解的代码中，@MyTest4保留到运行时期</span></span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest4&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">aaa</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] bbb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 定义有一个类Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest4(value=&quot;蜘蛛侠&quot;,aaa=99.9, bbb=&#123;&quot;至尊宝&quot;,&quot;黑马&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest4(value=&quot;孙悟空&quot;,aaa=199.9, bbb=&#123;&quot;紫霞&quot;,&quot;牛夫人&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 写一个测试类AnnotationTest3解析Demo类上的MyTest4注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest3</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类上的注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取类上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)c.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类中test1方法上的注解MyTest4注解</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取方法上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)m.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h2><p>注解是用来写框架的，比如现在我们要模拟Junit写一个测试框架，要求有@MyTest注解的方法可以被框架执行，没有@MyTest注解的方法不能被框架执行。</p>
<p>第一步：先定义一个MyTest注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>	</span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：写一个测试类AnnotationTest4，在类中定义几个被@MyTest注解标记的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest4</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====test1====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====test2====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====test2====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">AnnotationTest4</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationTest4</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> AnnotationTest4.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析AnnotationTest4类中所有的方法对象</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m: methods)&#123;</span><br><span class="line">            <span class="comment">//3.判断方法上是否有MyTest注解，有就执行该方法</span></span><br><span class="line">            <span class="keyword">if</span>(m.isAnnotationPresent(MyTest.class))&#123;</span><br><span class="line">            	m.invoke(a);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>代理思想就是被代理者没有能力，或者不愿意去完成某件事情，需要找个人（代理）代替自己去完成这件事。</p>
<p><strong>动态代理</strong>主要是对被代理对象的<strong>行为</strong>进行代理。是一个对象。</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669619922161.png" alt="1669619922161"></p>
<p>先把有唱歌和跳舞功能的接口，和实现接口的大明星类定义出来：</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669620054411.png" alt="1669620054411"></p>
<h2 id="动态代理的开发步骤"><a href="#动态代理的开发步骤" class="headerlink" title="动态代理的开发步骤"></a>动态代理的开发步骤</h2><ol>
<li>必须<strong>定义接口</strong>，里面<strong>定义一些行为</strong>，用来<strong>约束被代理对象和代理对象都要完成的事情</strong>。</li>
<li>定义一个<strong>实现类实现接口</strong>，这个实现类的对象代表<strong>被代理的对象</strong>。</li>
<li>定义一个<strong>测试类，在里面创建被代理对象，然后为其创建一个代理对象返回。（重点）</strong></li>
<li>代理对象中，需要模拟收首付款，真正触发被代理对象的行为，然后接收尾款操作。</li>
<li>通过返回的代理对象进行方法的调用，观察动态代理的执行流程。</li>
</ol>
<h2 id="如何创建代理对象"><a href="#如何创建代理对象" class="headerlink" title="如何创建代理对象"></a>如何创建代理对象</h2><ul>
<li>Java中代理的代表类是：java.lang.reflect.Proxy，它提供了一个静态方法，用于<strong>为被代理对象，产生一个代理对象</strong>返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">InvocationHandler h)</span> </span><br><span class="line"></span><br><span class="line">为被代理对象返回一个代理对象。</span><br><span class="line">参数一：类加载器 加载代理类，产生代理对象。，。</span><br><span class="line">参数二：真实业务对象的接口。(被代理的方法交给代理对象)</span><br><span class="line">参数三：代理的核心处理程序。</span><br></pre></td></tr></table></figure>

<p>写一个为BigStar生成动态代理对象的工具类。这里需要用Java为开发者提供的一个<strong>生成代理对象的类叫Proxy类</strong>。</p>
<p>通过<strong>Proxy类的newInstance(…)方法</strong>可以为实现了同一接口的类生成代理对象。 调用方法时需要<strong>传递三个参数</strong>：</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669620794550.png" alt="1669620794550"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStar bigStar)</span>&#123;</span><br><span class="line">       <span class="comment">/* newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                InvocationHandler h)</span></span><br><span class="line"><span class="comment">                参数1：用于指定一个类加载器</span></span><br><span class="line"><span class="comment">                参数2：指定生成的代理长什么样子，也就是有哪些方法</span></span><br><span class="line"><span class="comment">                参数3：用来指定生成的代理对象要干什么事情</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">        <span class="comment">// Star starProxy = ProxyUtil.createProxy(s);</span></span><br><span class="line">        <span class="comment">// starProxy.sing(&quot;好日子&quot;) starProxy.dance()</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">starProxy</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 回调方法</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// 代理对象要做的事情，会在这里写代码</span></span><br><span class="line">                        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;sing&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备话筒，收钱20万&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;dance&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备场地，收钱1000万&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStar, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> starProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用我们写好的ProxyUtil工具类，为BigStar对象生成代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigStar</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigStar</span>(<span class="string">&quot;杨超越&quot;</span>);</span><br><span class="line">        <span class="type">Star</span> <span class="variable">starProxy</span> <span class="operator">=</span> ProxyUtil.createProxy(s);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> starProxy.sing(<span class="string">&quot;好日子&quot;</span>);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        starProxy.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类，结果如下：</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669621045622.png" alt="1669621045622"></p>
<h2 id="通过代理对象调用方法，执行流程？"><a href="#通过代理对象调用方法，执行流程？" class="headerlink" title="通过代理对象调用方法，执行流程？"></a>通过代理对象调用方法，执行流程？</h2><ul>
<li>先走向代理。</li>
<li>代理中可以真正触发被代理对象的方法执行。</li>
<li>回到代理中，由代理负责返回结果给调用者。</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>需求</p>
<ul>
<li>模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时。</li>
</ul>
<p>分析</p>
<ul>
<li>定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。</li>
<li>定义一个实现类UserServiceImpl实现UserService，并完成相关功能，且统计每个功能的耗时。</li>
<li>定义测试类，创建实现类对象，调用方法。</li>
</ul>
<p>现有如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用户业务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 登录功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String loginName,String passWord)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">// 查询用户，返回数组的形式。</span></span><br><span class="line">    String[] selectUsers() <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService接口的实现类，每一个方法中要计算方法运行时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户业务实现类（面向接口编程）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String loginName, String passWord)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录成功，欢迎光临本系统~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录失败，用户名或密码错误~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;login方法耗时：&quot;</span>+(time2-time1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除了1万个用户~&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;deleteUsers方法耗时：&quot;</span>+(time2-time1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectUsers() <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;查询出了3个用户&quot;</span>);</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;张全蛋&quot;</span>, <span class="string">&quot;李二狗&quot;</span>, <span class="string">&quot;牛爱花&quot;</span>&#125;;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;selectUsers方法耗时：&quot;</span>+(time2-time1));</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本案例存在哪些问题？</p>
<ul>
<li>答：业务对象的的每个方法都要进行性能统计，存在大量重复的代码。</li>
</ul>
<p>每一个方法中计算耗时的代码都是重复的，这些重复的代码并不属于UserSerivce的主要业务代码。</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669621335888.png" alt="1669621335888"></p>
<p>接下来打算把计算每一个方法的耗时操作交给代理对象来做。</p>
<p>优化的关键步骤</p>
<ol>
<li>必须有接口，实现类要实现接口（代理通常是基于接口实现的）。</li>
<li>创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。</li>
</ol>
<p>先在UserService类中把计算耗时的代码删除，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户业务实现类（面向接口编程）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String loginName, String passWord)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录成功，欢迎光临本系统~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录失败，用户名或密码错误~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除了1万个用户~&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectUsers() <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;查询出了3个用户&quot;</span>);</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;张全蛋&quot;</span>, <span class="string">&quot;李二狗&quot;</span>, <span class="string">&quot;牛爱花&quot;</span>&#125;;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为UserService生成一个动态代理对象，在动态代理中调用目标方法，在调用目标方法之前和之后记录毫秒值，并计算方法运行的时间。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createProxy</span><span class="params">(UserService userService)</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceProxy</span></span><br><span class="line">            <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            ProxyUtil.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                                                                            			<span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(                                                                             Object proxy, </span></span><br><span class="line"><span class="params">                              Method method, </span></span><br><span class="line"><span class="params">                                  Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;                             <span class="keyword">if</span>(</span><br><span class="line">                    method.getName().equals(<span class="string">&quot;login&quot;</span>) ||                                             method.getName().equals(<span class="string">&quot;deleteUsers&quot;</span>)||</span><br><span class="line">                    method.getName().equals(<span class="string">&quot;selectUsers&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">//方法运行前记录毫秒值         </span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">//执行方法</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                    <span class="comment">//执行方法后记录毫秒值</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    System.out.println(method.getName() + <span class="string">&quot;方法执行耗时：&quot;</span> + (endTime - startTime)/ <span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> rs;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                    <span class="keyword">return</span> rs;                                                                &#125;</span><br><span class="line">           &#125;                                                                 &#125;);</span><br><span class="line">        <span class="comment">//返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> userServiceProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中为UserService创建代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：使用动态代理解决实际问题，并掌握使用代理的好处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1、创建用户业务对象。</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ProxyUtil.createProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、调用用户业务的功能。</span></span><br><span class="line">        userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        userService.deleteUsers();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] names = userService.selectUsers();</span><br><span class="line">        System.out.println(<span class="string">&quot;查询到的用户是：&quot;</span> + Arrays.toString(names));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下图所示</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669622545712.png" alt="1669622545712"></p>
<p>动态代理对象的执行流程如下图所示，每次用代理对象调用方法时，都会执行InvocationHandler中的invoke方法。</p>
<p><img src="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/1669622605490.png" alt="1669622605490"></p>
<p>动态代理的优点</p>
<ul>
<li>可以在不改变方法源码的情况下，实现对方法功能的增强，提高了代码的复用。</li>
<li>简化了编程工作、提高了开发效率，同时提高了软件系统的可扩展性。</li>
<li>可以为被代理对象的所有方法做代理。</li>
<li>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/" data-id="cluthi17t0001mguhceutgsz3" data-title="【Java基础】【java.lang.reflect】Junit单元测试、反射" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【Java基础】【java.lang】多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-04-09T12:36:41.000Z" itemprop="datePublished">2024-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/">【Java基础】【java.lang】多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线程</p>
<ul>
<li>线程(Thread)是一个程序内部的一条执行流程。</li>
<li>程序中如果只有一条执行流程，那这个程序就是单线程的程序。</li>
</ul>
<p>多线程</p>
<ul>
<li>多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）。</li>
<li>例如：买票系统、百度网盘下载、消息通信、淘宝、京东系统都离不开多线程技术。</li>
</ul>
<h1 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h1><p>Java是通过java.lang.Thread 类的对象来代表线程的。 </p>
<p>注意main方法由一条默认的主线负责执行。在main里面启动的线程称为子线程。</p>
<h2 id="方式1：继承Thread类"><a href="#方式1：继承Thread类" class="headerlink" title="方式1：继承Thread类"></a>方式1：继承Thread类</h2><p>步骤</p>
<ol>
<li>定义一个子类MyThread继承线程类java.lang.Thread。</li>
<li>重写run()方法。</li>
<li>创建MyThread类的对象。</li>
<li>调用线程对象的start()方法启动线程（启动后还是执行run方法的）。</li>
</ol>
<p>优缺点</p>
<ul>
<li>优点：编码简单。</li>
<li>缺点：线程类已经继承Thread，<strong>无法继承其他类，不利于功能的扩展</strong>。</li>
</ul>
<p>注意事项</p>
<ol>
<li>启动线程必须是<strong>调用start方法</strong>，不是调用run方法。<ul>
<li>如果直接调用run方法就不认为是一条线程启动了，而是把Thread当做一个普通对象，此时run方法中的执行的代码会成为主线程的一部分。</li>
</ul>
</li>
<li>不要把主线程任务放在启动子线程之前（否则先跑完主线程才启动子线程）。<ul>
<li>直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。</li>
<li>只有调用start方法才是启动一个新的线程执行。</li>
<li>这样主线程一直是先跑完的，相当于是一个单线程的效果了。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写Thread类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个测试类，在测试类中创建MyThread线程对象，并启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="comment">// main方法是由一条默认的主线程负责执行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建MyThread线程类的对象代表一个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 4、启动线程（自动执行run方法的）</span></span><br><span class="line">        t.start(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyThread和main线程在相互抢夺CPU的执行权（<strong>注意：哪一个线程先执行，哪一个线程后执行，目前我们是无法控制的，每次输出结果都会不一样</strong>）。</p>
<h2 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h2><p>步骤</p>
<ol>
<li><p>定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法。</p>
</li>
<li><p>创建MyRunnable任务对象。</p>
</li>
<li><p>把MyRunnable任务对象交给Thread线程对象处理。</p>
<p>public Thread(Runnable target)。封装Runnable对象成为线程对象。</p>
</li>
<li><p>调用线程对象的start()方法启动线程。</p>
</li>
</ol>
<p>优缺点</p>
<ul>
<li>优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强。</li>
<li>缺点：需要多一个Runnable对象。</li>
</ul>
<p>先准备一个Runnable接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、定义一个任务类，实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 2、重写runnable的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程要执行的任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个测试类，在测试类中创建线程对象，并执行线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建任务对象。</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4、把任务对象交给一个线程对象处理。</span></span><br><span class="line">        <span class="comment">//  public Thread(Runnable target)</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类写法（简化代码风格）</p>
<ol>
<li>可以创建Runnable的匿名内部类形式（任务对象）。</li>
<li>再交给Thread线程对象。</li>
<li>再调用线程对象的start()启动线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、直接创建Runnable接口的匿名内部类形式（任务对象）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程1输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式1：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程2输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式2：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程3输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式3：实现Callable接口"><a href="#方式3：实现Callable接口" class="headerlink" title="方式3：实现Callable接口"></a>方式3：实现Callable接口</h2><p>原因：</p>
<ul>
<li>前面两种的问题：假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>JDK 5.0提供了Callable接口和FutureTask类来实现（多线程的第三种创建方式）。</li>
<li>这种方式最大的优点：可以返回线程执行完毕后的结果。</li>
</ul>
<p>步骤</p>
<ol>
<li>创建任务对象<ul>
<li>定义一个类实现<strong>Callable接口</strong>，<strong>重写call方法</strong>，封装要做的事情，和要返回的数据。</li>
<li>把Callable类型的<strong>对象封装成FutureTask（线程任务对象）</strong>。</li>
</ul>
</li>
<li>把线程任务对象交给Thread对象。</li>
<li>调用Thread对象的start方法启动线程。</li>
<li>线程执行完毕后，<strong>通过FutureTask对象的的get方法去获取</strong>线程任务执行的结果。</li>
</ol>
<p>未来任务对象的作用？</p>
<ol>
<li>是一个任务对象，实现了Runnable对象。</li>
<li>可以在线程执行完毕后，<strong>通过FutureTask对象的的get方法去获取</strong>线程任务执行的结果。</li>
</ol>
<p>先准备一个Callable接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、让子类继承Thread线程类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写Thread类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个测试类，在测试类中创建线程并启动线程，还要获取返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3、创建一个Callable的对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 4、把Callable的对象封装成一个FutureTask对象（任务对象）</span></span><br><span class="line">        <span class="comment">// 未来任务对象的作用？</span></span><br><span class="line">        <span class="comment">// 1、是一个任务对象，实现了Runnable对象.</span></span><br><span class="line">        <span class="comment">// 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。</span></span><br><span class="line">        FutureTask&lt;String&gt; f1  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="comment">// 5、把任务对象交给一个Thread对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f1).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取线程执行完毕后返回的结果。</span></span><br><span class="line">        <span class="comment">// 注意：如果执行到这儿，假如上面的线程还没有执行完毕</span></span><br><span class="line">        <span class="comment">// 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> f1.get();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask的API</p>
<ul>
<li>构造器：public FutureTask&lt;&gt;(Callable call)。把Callable对象封装成FutureTask对象。</li>
<li>方法：public V get() throws Exception。获取线程执行call方法返回的结果。</li>
</ul>
<p>优缺点</p>
<ul>
<li>优点：线程任务类只是实现接口，可以继续继承类和实现接口，<strong>扩展性强</strong>；可以在线程执行完毕后去<strong>获取线程执行的结果</strong>。</li>
<li>缺点：<strong>编码复杂</strong>一点。</li>
</ul>
<h2 id="3种方法比较"><a href="#3种方法比较" class="headerlink" title="3种方法比较"></a>3种方法比较</h2><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>继承Thread类</td>
<td>编程比较简单，可以直接使用Thread类中的方法</td>
<td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td>
</tr>
<tr>
<td>实现Runnable接口</td>
<td>扩展性强，实现该接口的同时还可以继承其他的类。</td>
<td>编程相对复杂，不能返回线程执行的结果</td>
</tr>
<tr>
<td>实现Callable接口</td>
<td>扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果</td>
<td>编程相对复杂</td>
</tr>
</tbody></table>
<h1 id="Thread的常用方法"><a href="#Thread的常用方法" class="headerlink" title="Thread的常用方法"></a>Thread的常用方法</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol>
<li>public void run()。线程的任务方法。</li>
<li>public void start()。线程的任务方法。</li>
<li>public String getName()。<strong>获取</strong>当前线程的<strong>名称</strong>，线程名称默认是Thread-索引。</li>
<li>public void setName(String name)。为线程<strong>设置名称</strong>。</li>
<li>public static Thread currentThread()。<strong>获取当前</strong>执行的线程<strong>对象</strong>。</li>
<li>public static void sleep(long time)。让当前执行的线程<strong>休眠</strong>多少毫秒后，再继续执行。</li>
<li>public final void join()…。让调用当前这个方法的线程<strong>先执行完</strong>！</li>
</ol>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ol>
<li>public Thread(String name)。可以为当前线程指定名称。</li>
<li>public Thread(Runnable target)。封装Runnable对象成为线程对象。</li>
<li>public Thread(Runnable target, String name)。封装Runnable对象成为线程对象，并指定线程名称。</li>
</ol>
<p>其他</p>
<p>Thread类还提供了诸如：yield、interrupt、守护线程、线程优先级等线程的控制方法，在开发中很少使用，用到再说。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="什么是线程安全问题"><a href="#什么是线程安全问题" class="headerlink" title="什么是线程安全问题"></a>什么是线程安全问题</h2><ul>
<li><strong>多个线程，同时访问同一个共享资源，并存在修改该资源</strong>的时候，可能会出现业务安全问题。</li>
</ul>
<p>取钱的线程安全问题</p>
<ul>
<li>场景：小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元，如果小明和小红同时来取钱，并且2人各自都在取钱10万元，可能会出现什么问题呢？</li>
</ul>
<h2 id="用程序模拟线程安全问题"><a href="#用程序模拟线程安全问题" class="headerlink" title="用程序模拟线程安全问题"></a>用程序模拟线程安全问题</h2><p>先定义一个共享的账户类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId; <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明 小红同时过来的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个是取钱的线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 取钱(小明，小红)</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，再写一个测试类，在测试类中创建两个线程对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// 1、创建一个账户对象，代表两个人的共享账户。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-110&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 2、创建两个线程，分别代表小明 小红，再去同一个账户对象中取钱10万。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start(); <span class="comment">// 小明</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start(); <span class="comment">// 小红</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，会发现两个人都取了10万块钱，余额为-10万了。</p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="认识线程同步"><a href="#认识线程同步" class="headerlink" title="认识线程同步"></a>认识线程同步</h2><ul>
<li>线程同步：解决线程安全问题的方案。</li>
<li>思想：让多个线程实现先后依次访问共享资源，这样就解决了安全问题。</li>
</ul>
<p>常见方案</p>
<ul>
<li>加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来。</li>
</ul>
<h2 id="方式1：同步代码块"><a href="#方式1：同步代码块" class="headerlink" title="方式1：同步代码块"></a>方式1：同步代码块</h2><ul>
<li>作用：把访问共享资源的<strong>核心代码给上锁</strong>，以此保证线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁) &#123;</span><br><span class="line">	访问共享资源的核心代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快捷键：ctrl+alt+enter，选择第9个</span></span><br><span class="line"><span class="comment">//同步锁例如可以写“黑马”，因为它在常量中只有一份</span></span><br><span class="line"><span class="comment">//但是有个问题，就是小明来取锁住了自己家的账户，其他家的人也取不了钱了……（锁的对象太大！影响无关线程的执行）</span></span><br><span class="line"><span class="comment">//所以同步锁可以用“this”</span></span><br><span class="line"><span class="comment">//拓展：假设遇到多个线程调用静态方法，官方建议使用“类名.class”作为锁</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原理：<strong>每次只允许一个线程加锁后进入</strong>，执行完毕后自动解锁，其他线程才可以进来执行。</li>
<li>同步锁的注意事项：对于当前同时执行的线程来说，<strong>同步锁必须是同一把（同一个对象）</strong>，否则会出bug。</li>
</ul>
<p>只需要修改DrawThread类中的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明 小红线程同时过来的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="comment">// this正好代表共享资源！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【锁对象如何选择的问题】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象</span><br><span class="line"><span class="number">2.</span>对于实例方法，建议使用<span class="built_in">this</span>作为锁对象</span><br><span class="line"><span class="number">3.</span>对于静态方法，建议把类的字节码(类名.class)当做锁对象</span><br></pre></td></tr></table></figure>

<h2 id="方式2：同步方法"><a href="#方式2：同步方法" class="headerlink" title="方式2：同步方法"></a>方式2：同步方法</h2><ul>
<li>作用：把访问共享资源的核心方法给上锁，以此保证线程安全。</li>
<li>原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。</li>
</ul>
<p>同步方法底层原理</p>
<ul>
<li>同步方法其实底层也是<strong>有隐式锁对象</strong>的，只是<strong>锁的范围是整个方法代码</strong>。</li>
<li>如果方法是实例方法：同步方法默认用this作为的锁对象。</li>
<li>如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</li>
</ul>
<p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名称(形参列表) &#123;</span><br><span class="line">	操作共享资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块好还是同步方法好？</p>
<ul>
<li>范围上：<strong>同步代码块锁的范围更小</strong>，同步方法锁的范围更大。（锁的范围越小，<strong>性能越好</strong>~）</li>
<li><strong>可读性：同步方法更好</strong>。（计算机性能上去了，前一个差别不大~）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.money -= money;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式3：Lock锁"><a href="#方式3：Lock锁" class="headerlink" title="方式3：Lock锁"></a>方式3：Lock锁</h2><ul>
<li>Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，<strong>更灵活、更方便、更强大</strong>。</li>
<li>Lock<strong>是接口，不能直接实例化</strong>，可以采用它的<strong>实现类ReentrantLock</strong>来构建Lock锁对象。</li>
</ul>
<p>构造器</p>
<ol>
<li>public ReentrantLock()。获得Lock锁的实现类对象。</li>
</ol>
<p>常用方法</p>
<ol>
<li>void lock()。获得锁。</li>
<li>void unlock()。释放锁。</li>
</ol>
<p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>首先在成员变量位子，需要创建一个Lock接口的实现类对象（这个对象就是锁对象）</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="number">2.</span>在需要上锁的地方加入下面的代码</span><br><span class="line">	 lk.lock(); <span class="comment">// 加锁</span></span><br><span class="line">	 <span class="comment">//...中间是被锁住的代码...</span></span><br><span class="line">	 lk.unlock(); <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p>使用Lock锁改写前面DrawThread中取钱的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lk.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lk.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得用try-catch-finally来保证一定会解锁！</p>
<h1 id="线程通信-了解"><a href="#线程通信-了解" class="headerlink" title="线程通信[了解]"></a>线程通信[了解]</h1><p>当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺。</p>
<p>线程通信的常见模型（生产者与消费者模型）</p>
<ul>
<li>生产者线程负责生产数据。</li>
<li>消费者线程负责消费生产者生产的数据。</li>
<li>注意：生产者生产完数据应该等待自己，通知消费者消费；消费者消费完数据也应该等待自己，再通知生产者生产！</li>
</ul>
<p>Object类的等待和唤醒方法：</p>
<ol>
<li>void wait()。让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法。</li>
<li>void notify()。唤醒正在等待的单个线程。</li>
<li>void notifyAll()。唤醒正在等待的所有线程。</li>
</ol>
<p>注意</p>
<ul>
<li>上述方法应该使用当前同步锁对象进行调用。</li>
</ul>
<p>分析一下完成这个案例的思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先确定在这个案例中，什么是共享数据？</span><br><span class="line">	答：这里案例中桌子是共享数据，因为厨师和顾客都需要对桌子上的包子进行操作。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>再确定有那几条线程？哪个是生产者，哪个是消费者？</span><br><span class="line">	答：厨师是生产者线程，<span class="number">3</span>条生产者线程； </span><br><span class="line">	   顾客是消费者线程，<span class="number">2</span>条消费者线程</span><br><span class="line">	   </span><br><span class="line"><span class="number">3.</span>什么时候将哪一个线程设置为什么状态</span><br><span class="line">	生产者线程(厨师)放包子：</span><br><span class="line">		 <span class="number">1</span>)先判断是否有包子</span><br><span class="line">		 <span class="number">2</span>)没有包子时，厨师开始做包子, 做完之后把别人唤醒，然后让自己等待</span><br><span class="line">		 <span class="number">3</span>)有包子时，不做包子了，直接唤醒别人、然后让自己等待</span><br><span class="line">		 	</span><br><span class="line">	消费者线程(顾客)吃包子：</span><br><span class="line">		 <span class="number">1</span>)先判断是否有包子</span><br><span class="line">		 <span class="number">2</span>)有包子时，顾客开始吃包子, 吃完之后把别人唤醒，然后让自己等待</span><br><span class="line">		 <span class="number">3</span>)没有包子时，不吃包子了，直接唤醒别人、然后让自己等待</span><br></pre></td></tr></table></figure>

<p>先写桌子类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放1个包子的方法</span></span><br><span class="line">    <span class="comment">// 厨师1 厨师2 厨师3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">// 判断是否有包子。</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(name + <span class="string">&quot;做的肉包子&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;做了一个肉包子~~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有包子了，不做了。</span></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 吃货1 吃货2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 有包子，吃了</span></span><br><span class="line">                System.out.println(name  + <span class="string">&quot;吃了：&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line">                list.clear();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有包子</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写测试类，在测试类中，创建3个厨师线程对象，再创建2个顾客对象，并启动所有线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//   需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上</span></span><br><span class="line">        <span class="comment">//      2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。</span></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建3个生产者线程（3个厨师）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建2个消费者线程（2个吃货）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="认识线程池"><a href="#认识线程池" class="headerlink" title="认识线程池"></a>认识线程池</h2><p>线程池就是一个可以<strong>复用线程</strong>的技术。</p>
<p>不使用线程池的问题</p>
<ul>
<li>用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，  而<strong>创建新线程的开销是很大的</strong>，并且<strong>请求过多</strong>时，肯定会产生大量的线程出来，这样会<strong>严重影响系统的性能</strong>。</li>
</ul>
<p>线程池：正在进行的称为工作线程WorkThread，等待执行的任务在任务队列（WorkQueue）。这些任务对象必须要实现Runnable或者Callable对象。</p>
<h2 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h2><p>JDK 5.0起提供了代表线程池的<strong>接口：ExecutorService</strong>。</p>
<p>如何得到线程池对象?</p>
<ol>
<li>方式一：使用ExecutorService的<strong>实现类ThreadPoolExecutor</strong>自创建一个线程池对象。</li>
<li>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象。</li>
</ol>
<h3 id="ThreadPoolExecutor构造器【重要】"><a href="#ThreadPoolExecutor构造器【重要】" class="headerlink" title="ThreadPoolExecutor构造器【重要】"></a>ThreadPoolExecutor构造器【重要】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span><br></pre></td></tr></table></figure>

<ol>
<li>参数一：corePoolSize : 指定线程池的核心线程的数量。                         </li>
<li>参数二：maximumPoolSize：指定线程池的最大线程数量。（一般要大于corePoolSize，多出来的就是临时线程。）</li>
<li>参数三：keepAliveTime ：指定临时线程的存活时间。</li>
<li>参数四：unit：指定临时线程存活的时间单位(秒、分、时、天）。</li>
<li>参数五：workQueue：指定线程池的任务队列。</li>
<li>参数六：threadFactory：指定线程池的线程工厂。（负责创建线程。）</li>
<li>参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理）。</li>
</ol>
<p>理解</p>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20240409162613513.png" alt="image-20240409162613513"></p>
<p>用构造器创建线程池对象的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>核心线程–&gt;任务队列–&gt;临时线程–&gt;until占满最大线程–&gt;拒绝新任务。</p>
<p>(1)临时线程什么时候创建？</p>
<ul>
<li><strong>新任务提交时</strong>，发现<strong>核心线程都在忙</strong>、<strong>任务队列满了</strong>、并且<strong>还可以创建临时线程</strong>，此时会创建临时线程。</li>
</ul>
<p>(2)什么时候开始拒绝新的任务？</p>
<ul>
<li><strong>核心线程和临时线程都在忙</strong>、<strong>任务队列也满了</strong>、<strong>新任务过来时</strong>才会开始拒绝任务。</li>
</ul>
<p>程池执行的任务可以有2种：</p>
<ol>
<li>Runnable任务；</li>
<li>callable任务。</li>
</ol>
<h2 id="线程池处理Runnable任务"><a href="#线程池处理Runnable任务" class="headerlink" title="线程池处理Runnable任务"></a>线程池处理Runnable任务</h2><h3 id="ExecutorService常用方法"><a href="#ExecutorService常用方法" class="headerlink" title="ExecutorService常用方法"></a>ExecutorService常用方法</h3><ol>
<li>void execute(Runnable command)。执行 Runnable 任务。</li>
<li>Future<T> submit(Callable<T> task)。执行 <strong>Callable</strong> 任务，返回未来任务对象，用于获取线程返回的结果。</T></T></li>
<li>void shutdown()。等<strong>全部任务执行完毕后，再关闭线程池</strong>！（关闭线程池的2种方法：1.点红方块停止，2.调用本方法。注意，执行了含有线程池的程序之后，线程池不停止是正常现象！）</li>
<li>List<Runnable> shutdownNow()。立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务。</Runnable></li>
</ol>
<h3 id="新任务拒绝策略（参数七：handler）"><a href="#新任务拒绝策略（参数七：handler）" class="headerlink" title="新任务拒绝策略（参数七：handler）"></a>新任务拒绝策略（参数七：handler）</h3><ol>
<li>ThreadPoolExecutor.AbortPolicy。<strong>丢弃任务并抛出</strong>。RejectedExecutionException异常。是<strong>默认</strong>的策略。</li>
<li>ThreadPoolExecutor.DiscardPolicy。<strong>丢弃任务，但是不抛出异常</strong>，这是<strong>不推荐</strong>的做法。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy。<strong>抛弃队列中等待最久的任务</strong>， 然后把当前任务加入队列中。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy。由<strong>主线程负责调用任务的run()方法</strong>从而<strong>绕过线程池直接执行</strong>。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>先准备一个线程任务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 任务是干啥的？</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ==&gt; 输出666~~&quot;</span>);</span><br><span class="line">        <span class="comment">//为了模拟线程一直在执行，这里睡久一点</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line"><span class="comment">//下面4个任务在任务队列里排队</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面2个任务，会被临时线程的创建时机了</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"><span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">pool.execute(target);</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，结果输出如下</p>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/1668067745116.png" alt="1668067745116"></p>
<h2 id="线程池处理Callable任务"><a href="#线程池处理Callable任务" class="headerlink" title="线程池处理Callable任务"></a>线程池处理Callable任务</h2><p>Callable任务与Runnable任务最大的不同：执行完毕后可以返回结果。</p>
<p>上一小节提到的submit()方法。</p>
<p>先准备一个Callable线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 描述线程的任务，返回线程执行返回后的结果。</span></span><br><span class="line">        <span class="comment">// 需求：求1-n的和返回。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;求出了1-&quot;</span> + n + <span class="string">&quot;的和是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再准备一个测试类，在测试类中创建线程池，并执行callable任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">8</span>,</span><br><span class="line">            TimeUnit.SECONDS, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、执行完Callable任务后，需要获取返回结果。</span></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后，结果如下图所示</p>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/1668067964048.png" alt="1668067964048"></p>
<p>说明线程2复用了。</p>
<h2 id="Executors工具类实现线程池"><a href="#Executors工具类实现线程池" class="headerlink" title="Executors工具类实现线程池"></a>Executors工具类实现线程池</h2><p>是一个线程池的工具类，提供了很多静态方法用于返回不同特点的线程池对象。 </p>
<p>常用方法：</p>
<ol>
<li>public static ExecutorService newFixedThreadPool(int nThreads)。<strong>创建固定线程数量的线程池</strong>，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</li>
<li>public static ExecutorService newSingleThreadExecutor()。<strong>创建只有一个线程的线程池</strong>对象，<strong>如果该线程出现异常而结束，那么线程池会补充一个新线程</strong>。（不会死掉！）</li>
<li>public static ExecutorService newCachedThreadPool()。线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。</li>
<li>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)。创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</li>
</ol>
<p>注意 ：这些方法的<strong>底层，都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象</strong>。</p>
<p>【核心线程数量配置多少？】行业通用—&gt;</p>
<ul>
<li>计算密集型的任务：核心线程数量 &#x3D; CPU核数 + 1；</li>
<li>IO密集型的任务：核心线程数量 &#x3D; CPU核数 * 2；</li>
</ul>
<p>【Executors使用可能存在的陷阱】</p>
<ul>
<li>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。（小的系统也最好不要用，容易留安全隐患。）</li>
<li><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20240409192641654.png" alt="image-20240409192641654"></li>
</ul>
<h1 id="其他细节知识：并发、并行"><a href="#其他细节知识：并发、并行" class="headerlink" title="其他细节知识：并发、并行"></a>其他细节知识：并发、并行</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>正在运行的程序（软件）就是一个独立的进程。</li>
<li><strong>线程</strong>是<strong>属于进程</strong>的，<strong>一个进程中可以同时运行很多个线程</strong>。</li>
<li><strong>进程中的多个线程</strong>其实是<strong>并发和并行</strong>执行的。</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li><strong>进程中的线程是由CPU负责调度执行</strong>的，但<strong>CPU能同时处理线程的数量有限</strong>，<strong>为了保证全部线程都能往前执行</strong>，<strong>CPU会轮询为系统的每个线程服务</strong>，由于<strong>CPU切换的速度很快</strong>，给我们的<strong>感觉这些线程在同时执行</strong>，这就是并发。</li>
<li></li>
</ul>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><ul>
<li><strong>在同一个时刻</strong>上，同时<strong>有多个线程在被CPU调度执行</strong>。</li>
</ul>
<p>【多线程到底是怎么执行的？】</p>
<p>并发和并行同时进行的！</p>
<ul>
<li>并发：CPU分时轮询的执行线程。</li>
<li>并行：同一个时刻同时在执行。</li>
</ul>
<h1 id="其他细节知识：线程的生命周期"><a href="#其他细节知识：线程的生命周期" class="headerlink" title="其他细节知识：线程的生命周期"></a>其他细节知识：线程的生命周期</h1><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul>
<li>也就是线程从生到死的过程中，经历的各种状态及状态转换。</li>
<li>理解线程这些状态有利于提升并发编程的理解能力。</li>
</ul>
<h2 id="Java线程的状态"><a href="#Java线程的状态" class="headerlink" title="Java线程的状态"></a>Java线程的状态</h2><ul>
<li>Java总共定义了<strong>6种</strong>状态。</li>
<li>6种状态都定义在<strong>Thread类的内部枚举类</strong>中。(Thread.State可以调出来。)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">     NEW,</span><br><span class="line">     RUNNABLE,</span><br><span class="line">     BLOCKED,</span><br><span class="line">     WAITING,</span><br><span class="line">     TIMED_WAITING,</span><br><span class="line">     TERMINATED;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>线程状态</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>NEW(新建)</td>
<td>线程刚被创建，但是并未启动。</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程已经调用了start()，等待CPU调度</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态；。</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法（sleep,wait）有超时参数，调用他们将进入Timed Waiting状态。</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<h3 id="线程的6种状态互相转换"><a href="#线程的6种状态互相转换" class="headerlink" title="线程的6种状态互相转换"></a>线程的6种状态互相转换</h3><p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20240409194225380.png" alt="image-20240409194225380"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="clur1v70l00000cuhgtan2vux" data-title="【Java基础】【java.lang】多线程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【Java基础】【java.net】网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-04-09T11:50:05.000Z" itemprop="datePublished">2024-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">【Java基础】【java.net】网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h1><h2 id="基本的通信架构"><a href="#基本的通信架构" class="headerlink" title="基本的通信架构"></a>基本的通信架构</h2><p>基本的通信架构有2种形式：CS架构（ Client客户端&#x2F;Server服务端 ） 、 BS架构(Browser浏览器&#x2F;Server服务端)。</p>
<p>无论是CS架构，还是BS架构的软件都必须依赖网络编程！</p>
<h3 id="CS架构"><a href="#CS架构" class="headerlink" title="CS架构"></a>CS架构</h3><p>例如微信、IDEA。</p>
<p>Client客户端</p>
<ul>
<li>需要程序员开发。</li>
<li>用户需要安装。</li>
</ul>
<p>Server服务端</p>
<ul>
<li>需要程序员开发实现。</li>
</ul>
<h3 id="BS架构"><a href="#BS架构" class="headerlink" title="BS架构"></a>BS架构</h3><p>例如浏览器、网页。</p>
<p>Browser浏览器</p>
<ul>
<li><strong>不需要</strong>程序员开发实现。</li>
<li>用户需要安装浏览器。</li>
</ul>
<p>Server服务端</p>
<ul>
<li>需要程序员开发实现。</li>
</ul>
<h1 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h1><ol>
<li><strong>IP地址</strong>：设备在网络中的地址，是唯一的标识。</li>
<li><strong>端口号</strong>：应用程序在设备中唯一的标识。</li>
<li><strong>协议</strong>：连接和数据在网络中传输的规则。</li>
</ol>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240409203035483.png" alt="image-20240409203035483"></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>设备在网络中的地址，是唯一的标识。</p>
<ul>
<li>IP（Internet Protocol）：全称“互联网协议地址”，是<strong>分配给上网设备的唯一标志</strong>。</li>
<li>IP地址有两种形式：IPv4、IPv6。<ul>
<li><strong>IPv4地址</strong>是用<strong>32bit</strong>(4Bytes)来表示，分成4段表示，使用<strong>点分十进制</strong>表示法来表示。</li>
<li><strong>IPv6地址</strong>是用共<strong>128bit</strong>来表示，分成8段表示，使用<strong>冒分十六进制</strong>表示法来表示。即，每段每四位编码成一个十六进制位表示， 数之间用冒号（:）分开。</li>
</ul>
</li>
</ul>
<p>IP域名：</p>
<p>例如，<a target="_blank" rel="noopener" href="https://www.baidu.com/%E3%80%82%E6%9C%AC%E6%9C%BA%E5%85%88%E5%8E%BBDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%A5%EF%BC%8C%E6%9F%A5%E5%88%B0ip%E5%9C%B0%E5%9D%80%E5%B9%B6%E8%BF%94%E5%9B%9E%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9F%A5%E4%B8%8D%E5%88%B0%EF%BC%8C%E5%B0%B1%E5%8E%BB%E8%BF%90%E8%90%A5%E5%95%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%82%A3%E9%87%8C%E5%8E%BB%E6%9F%A5%E3%80%82">https://www.baidu.com/。本机先去DNS服务器查，查到ip地址并返回，如果查不到，就去运营商服务器那里去查。</a></p>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410104003448.png" alt="image-20240410104003448"></p>
<p>公网IP、内网IP：</p>
<ul>
<li><strong>公网IP</strong>：是<strong>可以连接互联网</strong>的IP地址；<strong>内网IP</strong>：也叫局域网IP，<strong>只能组织机构内部使用</strong>。</li>
<li><strong>192.168. 开头</strong>的就是<strong>常见的局域网地址</strong>，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。</li>
</ul>
<p>特殊IP地址：</p>
<ul>
<li><strong>127.0.0.1、localhost</strong>：代表<strong>本机IP</strong>，只会寻找当前所在的主机。</li>
</ul>
<p>IP常用命令：</p>
<ul>
<li><strong>ipconfig：查看本机IP地址</strong>。</li>
<li><strong>ping IP地址：检查网络是否连通</strong>。</li>
</ul>
<p>在Java中的代表类：</p>
<ul>
<li>代表IP地址。</li>
</ul>
<p>InetAddress的常用方法：</p>
<ol>
<li>public static InetAddress getLocalHost()。获取<strong>本机IP</strong>，会<strong>以一个InetAddress的对象返回</strong>。</li>
<li>public static InetAddress getByName(String host)。<strong>根据ip地址或者域名</strong>，<strong>返回一个InetAdress对象</strong>。</li>
<li>public String getHostName()。<strong>获取</strong>该ip地址对象对应的<strong>主机名</strong>。</li>
<li>public String getHostAddress()。<strong>获取</strong>该ip地址对象中的<strong>ip地址信息</strong>。</li>
<li>public boolean isReachable(int timeout)。在<strong>指定毫秒</strong>内，判断主机与该ip对应的主机<strong>是否能连通</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取本机IP地址对象的</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip1</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip1.getHostName());</span><br><span class="line">        System.out.println(ip1.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取指定IP或者域名的IP地址对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());</span><br><span class="line">        System.out.println(ip2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ping www.baidu.com</span></span><br><span class="line">        System.out.println(ip2.isReachable(<span class="number">6000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p><strong>应用程序</strong>在<strong>设备</strong>中<strong>唯一</strong>的标识。标记正在计算机设备上运行的应用程序的，被规定为一个 <strong>16 位的二进制</strong>，范围是 0~65535。</p>
<p>分类</p>
<ul>
<li>周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） </li>
<li><strong>注册端口</strong>：1024~49151，分配给用户进程或某些应用程序。（注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。）</li>
<li>动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。</li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><strong>连接和数据在网络中传输的规则</strong>。网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议。（为了让全球所有的上网设备都能够互联。）</p>
<p>开放式网络互联标准：OSI网络参考模型</p>
<ul>
<li>OSI网络参考模型：全球网络互联标准。 </li>
<li>TCP&#x2F;IP网络模型：事实上的国际标准。</li>
</ul>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410105817922.png" alt="image-20240410105817922"></p>
<p>传输层的2个通信协议</p>
<ul>
<li>UDP(User Datagram Protocol)：用户数据报协议。</li>
<li>TCP(Transmission Control Protocol)：传输控制协议。</li>
</ul>
<p>UDP协议</p>
<ul>
<li>特点：<strong>无连接、不可靠通信</strong>。</li>
<li>不事先建立连接，<strong>数据按照包发</strong>，一包数据包含：<strong>自己的IP、程序端口，目的地IP、程序端口和数据</strong>（<strong>限制在64KB内</strong>）等。</li>
<li>发送方不管对方是否在线，数据在中间丢失也不管，如果接收方收到数据也不返回确认，故是不可靠的 。（但是通信效率高，用于语音通话、视频直播。）</li>
</ul>
<p>TCP协议</p>
<ul>
<li>特点：<strong>面向连接、可靠通信</strong>。</li>
<li>TCP的最终目的：要保证在不可靠的信道上实现可靠的传输。</li>
<li>TCP主要有三个步骤实现可靠传输：<strong>三次握手建立</strong>连接，传输数据进行确认，<strong>四次挥手断开</strong>连接。（通信效率相对不高，用于网页、文件下载、支付。）</li>
<li>可以进行大数据量的传输。</li>
</ul>
<p>TCP协议：三次握手建立可靠连接</p>
<ul>
<li>可靠连接：确定通信双方，收发消息都是正常无问题的！（全双工）</li>
</ul>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410110231817.png" alt="image-20240410110231817"></p>
<ul>
<li>传输数据会进行确认，以保证数据传输的可靠性。</li>
</ul>
<p>TCP协议：四次握手断开连接</p>
<ul>
<li>目的：确保双方数据的收发都已经完成！</li>
</ul>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410110434580.png" alt="image-20240410110434580"></p>
<h1 id="UDP通信代码（入门案例）"><a href="#UDP通信代码（入门案例）" class="headerlink" title="UDP通信代码（入门案例）"></a>UDP通信代码（入门案例）</h1><ul>
<li>特点：无连接、不可靠通信。</li>
<li>不事先建立连接；发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。（类似于拿盘子扔韭菜……）</li>
<li>Java提供了一个<strong>java.net.DatagramSocket类</strong>来实现UDP通信。</li>
</ul>
<h2 id="DatagramSocket-用于创建客户端、服务端"><a href="#DatagramSocket-用于创建客户端、服务端" class="headerlink" title="DatagramSocket: 用于创建客户端、服务端"></a>DatagramSocket: 用于创建客户端、服务端</h2><p>构造器</p>
<ol>
<li>public DatagramSocket()。创建客户端的Socket对象, 系统会随机分配一个端口号。</li>
<li>public DatagramSocket(int port)。创建服务端的Socket对象, 并指定端口号。</li>
</ol>
<p>方法</p>
<ol>
<li>public void send(DatagramPacket dp)。发送数据包。</li>
<li>public void receive(DatagramPacket p)。使用数据包接收数据。</li>
</ol>
<h2 id="DatagramPacket：创建数据包"><a href="#DatagramPacket：创建数据包" class="headerlink" title="DatagramPacket：创建数据包"></a>DatagramPacket：创建数据包</h2><p>构造器</p>
<ol>
<li>public DatagramPacket(byte[] buf, int length, InetAddress address, int port)。创建发出去的<strong>数据包对象</strong>。</li>
<li>public DatagramPacket(byte[] buf, int length)。创建用来接收数据的数据包。</li>
</ol>
<p>方法</p>
<ol>
<li>public int getLength()。获取数据包，实际接收到的字节个数。</li>
</ol>
<h2 id="使用UDP通信实现：发送消息、接收消息"><a href="#使用UDP通信实现：发送消息、接收消息" class="headerlink" title="使用UDP通信实现：发送消息、接收消息"></a>使用UDP通信实现：发送消息、接收消息</h2><h3 id="客户端实现步骤"><a href="#客户端实现步骤" class="headerlink" title="客户端实现步骤"></a>客户端实现步骤</h3><ol>
<li>创建DatagramSocket对象（客户端对象） –&gt;  扔韭菜的人。</li>
<li>创建DatagramPacket对象封装需要发送的数据（数据包对象） –&gt;  韭菜盘子。</li>
<li>使用DatagramSocket对象的<strong>send方法</strong>，传入DatagramPacket对象   –&gt; 开始抛出韭菜。</li>
<li>释放资源。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建客户端对象（发韭菜出去的人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子）</span></span><br><span class="line">       <span class="comment">/* public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">             InetAddress address, int port)</span></span><br><span class="line"><span class="comment">               参数一：封装要发出去的数据。</span></span><br><span class="line"><span class="comment">               参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">               参数三：服务端的IP地址（找到服务端主机）</span></span><br><span class="line"><span class="comment">               参数四：服务端程序的端口。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我是快乐的客户端，我爱你abc&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length</span><br><span class="line">                , InetAddress.getLocalHost(),  <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式发送这个数据包的数据出去了</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端数据发送完毕~~~&quot;</span>);</span><br><span class="line">        socket.close(); <span class="comment">// 释放资源！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端实现步骤"><a href="#服务端实现步骤" class="headerlink" title="服务端实现步骤"></a>服务端实现步骤</h3><ol>
<li>创建DatagramSocket对象并指定端口（服务端对象）                      –&gt; 接韭菜的人。</li>
<li>创建DatagramPacket对象接收数据（数据包对象）                 –&gt; 韭菜盘子。</li>
<li>使用DatagramSocket对象的<strong>receive方法</strong>，传入DatagramPacket对象  –&gt; 开始接收韭菜。</li>
<li>释放资源。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">// 64KB.</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">        <span class="comment">// 接收多少就倒出多少</span></span><br><span class="line">        <span class="comment">// 获取本次数据包接收了多少数据。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(packet.getPort());</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UDP通信代码（多发多收）"><a href="#UDP通信代码（多发多收）" class="headerlink" title="UDP通信代码（多发多收）"></a>UDP通信代码（多发多收）</h1><p>客户端可以反复发送数据</p>
<p>客户端实现步骤</p>
<ul>
<li>创建DatagramSocket对象（发送端对象） –&gt;  扔韭菜的人。</li>
<li>使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序。</li>
<li>如果用户输入的不是exit,  把数据封装成DatagramPacket    –&gt;  韭菜盘子。</li>
<li>使用DatagramSocket对象的send方法将数据包对象进行发送 –&gt;  开始抛出韭菜。</li>
<li>释放资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门：实现客户端反复的发。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建客户端对象（发韭菜出去的人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子）</span></span><br><span class="line">       <span class="comment">/* public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">             InetAddress address, int port)</span></span><br><span class="line"><span class="comment">               参数一：封装要发出去的数据。</span></span><br><span class="line"><span class="comment">               参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">               参数三：服务端的IP地址（找到服务端主机）</span></span><br><span class="line"><span class="comment">               参数四：服务端程序的端口。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一旦发现用户输入的exit命令，就退出客户端</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎下次光临！退出成功！&quot;</span>);</span><br><span class="line">                socket.close(); <span class="comment">// 释放资源</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出死循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length</span><br><span class="line">                    , InetAddress.getLocalHost(),  <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、开始正式发送这个数据包的数据出去了</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端实现步骤</p>
<ul>
<li>创建DatagramSocket对象并指定端口（接收端对象）–&gt; 接韭菜的人。</li>
<li>创建DatagramPacket对象接收数据（数据包对象） –&gt; 韭菜盘子。</li>
<li>使用DatagramSocket对象的receive方法传入DatagramPacket对象。</li>
<li>使用while死循环不断的进行第3步。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门-服务端反复的收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">// 64KB.</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、开始正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">            <span class="comment">// 接收多少就倒出多少</span></span><br><span class="line">            <span class="comment">// 获取本次数据包接收了多少数据。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.println(rs);</span><br><span class="line"></span><br><span class="line">            System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">            System.out.println(packet.getPort());</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提问：UDP的接收端为什么可以接收很多发送端的消息？</p>
<ul>
<li>接收端只负责接收数据包，无所谓是哪个发送端的数据包。</li>
</ul>
<h1 id="TCP通信（一发一收）"><a href="#TCP通信（一发一收）" class="headerlink" title="TCP通信（一发一收）"></a>TCP通信（一发一收）</h1><ul>
<li>特点：面向连接、可靠通信。</li>
<li>通信双方事先会采用“三次握手”方式建立可靠连接，实现端到端的通信；底层能保证数据成功传给服务端。</li>
<li>Java提供了一个<strong>java.net.Socket类</strong>来实现TCP通信。</li>
</ul>
<h2 id="TCP通信之-客户端开发"><a href="#TCP通信之-客户端开发" class="headerlink" title="TCP通信之-客户端开发"></a>TCP通信之-客户端开发</h2><ul>
<li>客户端程序就是通过java.net包下的Socket类来实现的。</li>
</ul>
<p>构造器</p>
<ol>
<li>public Socket(String host , int port)。根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket。</li>
</ol>
<p>常用方法</p>
<ol>
<li>public OutputStream getOutputStream()。获得字节输出流对象。（发）</li>
<li>public InputStream getInputStream()。获得字节输入流对象。（收）</li>
</ol>
<p>客户端发送消息</p>
<ol>
<li>创建客户端的Socket对象，请求与服务端的连接。</li>
<li>使用socket对象调用getOutputStream()方法得到字节输出流。（注意用的是字节流，所以使用的时候可能需要包装一下。）</li>
<li>使用字节输出流完成数据的发送。</li>
<li>释放资源：关闭socket管道。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-客户端开发：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Socket对象，并同时请求与服务端程序的连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、开始写数据出去了</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;在一起，好吗？&quot;</span>);</span><br><span class="line">        dos.close();</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放连接资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP通信-服务端程序的开发"><a href="#TCP通信-服务端程序的开发" class="headerlink" title="TCP通信-服务端程序的开发"></a>TCP通信-服务端程序的开发</h2><ul>
<li>服务端是通过java.net包下的ServerSocket类来实现的。</li>
</ul>
<p>构造器</p>
<ol>
<li>public ServerSocket(int port)。为服务端程序注册端口。</li>
</ol>
<p>常用方法</p>
<ol>
<li>public Socket accept()。阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。</li>
</ol>
<p>实现步骤</p>
<ol>
<li>创建ServerSocket对象，注册服务端端口。</li>
<li>调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</li>
<li>通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。</li>
<li>释放资源：关闭socket管道。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、使用数据输入流读取客户端发送过来的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        <span class="comment">// 其实我们也可以获取客户端的IP地址</span></span><br><span class="line">        System.out.println(socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">        dis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP通信（多发多收）"><a href="#TCP通信（多发多收）" class="headerlink" title="TCP通信（多发多收）"></a>TCP通信（多发多收）</h1><ul>
<li>客户端使用死循环，让用户不断输入消息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-客户端开发：实现客户端可以反复的发消息出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Socket对象，并同时请求与服务端程序的连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一旦用户输入了exit，就退出客户端程序</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎您下次光临！退出成功！&quot;</span>);</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、开始写数据出去了</span></span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端也使用死循环，控制服务端收完消息，继续等待接收下一个消息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：实现服务端反复发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 5、使用数据输入流读取客户端发送过来的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(rs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;离线了！&quot;</span>);</span><br><span class="line">                dis.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP通信（多线程改进）"><a href="#TCP通信（多线程改进）" class="headerlink" title="TCP通信（多线程改进）"></a>TCP通信（多线程改进）</h1><p>目前我们开发的服务端程序，可否支持与多个客户端同时通信 ？</p>
<ul>
<li>不可以的。因为服务端现在只有一个主线程，只能处理一个客户端的消息。</li>
</ul>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410150207421.png" alt="image-20240410150207421"></p>
<p>本次是如何实现服务端同时接收多个客户端的消息的？</p>
<ul>
<li><strong>主线程</strong>定义了<strong>循环负责接收客户端Socket管道连接</strong>。</li>
<li>每<strong>接收到一个Socket通信管道</strong>后<strong>分配一个独立的线程</strong>负责处理它。</li>
</ul>
<p>首先，我们需要写一个服务端的读取数据的线程类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，再改写服务端的主程序代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展案例-【群聊的实现】-思路</p>
<p>客户端和客户端是不能直接通信的。全群聊的效果必须要有服务端在中间做中转。</p>
<ul>
<li>客户端 —&gt; 服务端。</li>
<li>客户端 —&gt; 多个客户端。</li>
</ul>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410150623261.png" alt="image-20240410150623261"></p>
<ul>
<li>是指一个客户端把消息发出去，其他在线的全部客户端都可以收到消息。</li>
<li>需要用到<strong>端口转发的设计思想</strong>。</li>
<li>服务端需要把在线的Socket管道存储起来，一旦收到一个消息要推送给其他管道。</li>
</ul>
<p>可以在服务端创建一个存储Socket的集合，每当一个客户端连接服务端，就可以把客户端Socket存储起来；当一个客户端给服务端发消息时，再遍历集合通过每个Socket将消息再转发给其他客户端。</p>
<p>然后改造服务端代码</p>
<p>由于服务端读取数据是在线程类中完成的，所以我们改<code>SerReaderThread</code>类就可以了。服务端的主程序不用改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">// 把这个消息分发给全部客户端进行接收。</span></span><br><span class="line">                    sendMsgToAll(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                    Server.onLineSockets.remove(socket);</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgToAll</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 发送给全部在线的socket管道接收。</span></span><br><span class="line">        <span class="keyword">for</span> (Socket onLineSocket : Server.onLineSockets) &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> onLineSocket.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BS架构程序（简易版）"><a href="#BS架构程序（简易版）" class="headerlink" title="BS架构程序（简易版）"></a>BS架构程序（简易版）</h1><p>案例：</p>
<p>要求从浏览器中访问服务器，并立即让服务器响应一个很简单的网页给浏览器展示，网页内容就是“黑马程序员666”。</p>
<p>BS架构的基本原理</p>
<ul>
<li>客户端使用浏览器发起请求（不需要开发客户端）。</li>
<li>注意：服务器必须给浏览器响应HTTP协议规定的数据格式，否则浏览器不识别返回的数据。</li>
<li>http:&#x2F;&#x2F;服务器IP:服务器端口，例如，<a href="http://127.0.0.1:8080。">http://127.0.0.1:8080。</a></li>
</ul>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410151156205.png" alt="image-20240410151156205"></p>
<p>HTTP协议规定</p>
<p>必须满足如下形式：</p>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410151235576.png" alt="image-20240410151235576"></p>
<p><strong>注意：数据是由多行组成的，必须按照规定的格式来写。</strong></p>
<p>先写一个线程类，用于按照HTTP协议的格式返回数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//  立即响应一个网页内容：“黑马程序员”给浏览器展示。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">// 必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写服务端的主程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展</p>
<p>每次请求都开一个新线程，到底好不好？</p>
<ul>
<li>高并发时，容易宕机！</li>
<li>可以使用线程池进行优化。</li>
</ul>
<p><img src="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20240410151505454.png" alt="image-20240410151505454"></p>
<p>为了避免服务端创建太多的线程，可以把服务端用线程池改进，提高服务端的性能。</p>
<p>先写一个给浏览器响应数据的线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderRunnable</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//  立即响应一个网页内容：“黑马程序员”给浏览器展示。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">// 必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改写服务端的主程序，使用ThreadPoolExecutor创建一个线程池，每次接收到一个Socket就往线程池中提交任务就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建出一个线程池，负责处理通信管道的任务。</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">16</span> * <span class="number">2</span>, <span class="number">16</span> * <span class="number">2</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">8</span>) , Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="cluthi17v0002mguhc3hbc53m" data-title="【Java基础】【java.net】网络编程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【LeeCode】刷题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/08/%E3%80%90LeeCode%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2024-04-08T13:00:07.000Z" itemprop="datePublished">2024-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/08/%E3%80%90LeeCode%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">【LeeCode】刷题记录.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>作者：力扣官方题解 </li>
<li>来源：力扣（LeetCode）</li>
</ul>
<h1 id="LeeCode热题100"><a href="#LeeCode热题100" class="headerlink" title="LeeCode热题100"></a>LeeCode热题100</h1><h2 id="49、字母异位词分组（中）"><a href="#49、字母异位词分组（中）" class="headerlink" title="49、字母异位词分组（中）"></a>49、字母异位词分组（中）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/">https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/</a> </p>
<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<blockquote>
<p>为什么是哈希表相关的题？</p>
</blockquote>
<p>思路：</p>
<ul>
<li>当把单词中所有字母按照字母顺序表排列时，字母异位词的排序后的单词是相同的。</li>
<li>可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词。</li>
<li>哈希表的<strong>键</strong>为一组字母异位词的<strong>标志</strong>，哈希表的<strong>值</strong>为<strong>一组字母异位词列表</strong>。</li>
<li>具体做法：遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</li>
</ul>
<h3 id="方法1：字母排序"><a href="#方法1：字母排序" class="headerlink" title="方法1：字母排序"></a>方法1：字母排序</h3><ol>
<li>构造单词的字符排序，作为键。</li>
<li>将单词加入散列表。</li>
<li>返回答案。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复习</p>
<ul>
<li>char[] toCharArray() 。将此<strong>字符串转换为新的字符数组</strong>。</li>
<li>getOrDefault。HashMap的一个方法，<strong>返回指定键映射到的值</strong>，如果此映射不包含键的映射，则返回 defaultValue 。</li>
<li>向list中新增元素用add方法。</li>
<li>向哈希表中新增元素用put方法，同时传入键和值。</li>
</ul>
<p>复杂度分析</p>
<p><img src="/2024/04/08/%E3%80%90LeeCode%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20240408211642300.png" alt="image-20240408211642300"></p>
<h3 id="方法2：计数"><a href="#方法2：计数" class="headerlink" title="方法2：计数"></a>方法2：计数</h3><ul>
<li>互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的<strong>次数使用字符串表示，作为哈希表的键</strong>。</li>
<li>字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。</li>
<li>首先统计字符的出现顺序，然后构造键，把具有相通特征的字符串的单词们放在一组，最后返回结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                counts[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); 	<span class="comment">//可变字符串对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counts[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                    sb.append(counts[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p><img src="/2024/04/08/%E3%80%90LeeCode%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20240408211900938.png" alt="image-20240408211900938"></p>
<h3 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h3><ul>
<li>通过分析，能否意识到单词和键的映射关系。</li>
<li>利用散列表高效储存结果。</li>
<li>数据结构和常见的库函数。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/08/%E3%80%90LeeCode%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" data-id="clur1v70q00010cuh2d982dfy" data-title="【LeeCode】刷题记录.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【Java基础】特殊文本文件、日志技术" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/08/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/" class="article-date">
  <time class="dt-published" datetime="2024-04-08T07:10:11.000Z" itemprop="datePublished">2024-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/08/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/">【Java基础】特殊文本文件、日志技术</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="特殊文件概述"><a href="#特殊文件概述" class="headerlink" title="特殊文件概述"></a>特殊文件概述</h1><p>认识</p>
<ul>
<li>普通文件.txt。</li>
<li>属性文件.properties。</li>
<li>XML文件.xml。</li>
</ul>
<p>为什么要用特殊文件？</p>
<ul>
<li>存储多个用户的用户名和密码，txt不可以解析，但是properties、xml可以。</li>
<li>存储多个用户的用户名、密码、家乡和性别，txt、properties不可以解析，xml可以。</li>
<li>可以存储有关系的数据，作为<strong>系统的配置文件</strong>，<strong>作为信息进行传输</strong>。</li>
</ul>
<p>我们主要学什么？</p>
<ul>
<li>了解它们的特点、作用。</li>
<li>学习使用程序读取它们里面的数据。</li>
<li>学习使用程序把数据存储到这些文件里。（用得不多。）</li>
</ul>
<h1 id="日志技术"><a href="#日志技术" class="headerlink" title="日志技术"></a>日志技术</h1><p>把程序运行的信息，记录到文件中，方便程序员定位bug、并了解程序的执行情况等。</p>
<h1 id="特殊文件：properties属性文件"><a href="#特殊文件：properties属性文件" class="headerlink" title="特殊文件：properties属性文件"></a>特殊文件：properties属性文件</h1><ul>
<li>是一个<strong>Map集合</strong>（<strong>键值对集合</strong>），但是我们<strong>一般不会当集合使用</strong>。</li>
<li>核心作用：Properties是用来代表属性文件的，通过Properties可以读写属性文件里的键值对。</li>
</ul>
<h2 id="（读）构造器"><a href="#（读）构造器" class="headerlink" title="（读）构造器"></a>（读）构造器</h2><ol>
<li>public Properties()。用于构建Properties集合对象（空容器）。</li>
</ol>
<h2 id="（读）常用方法"><a href="#（读）常用方法" class="headerlink" title="（读）常用方法"></a>（读）常用方法</h2><ol>
<li>public void load(InputStream is)。通过字节输入流，读取属性文件里的键值对数据。</li>
<li>public void load(Reader reader)。通过字符输入流，读取属性文件里的键值对数据。</li>
<li>public String getProperty(String key)。根据键获取值(其实就是get方法的效果)。</li>
<li>public Set<String> stringPropertyNames()。获取全部键的集合（其实就是ketSet方法的效果）。</String></li>
</ol>
<p>读取步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、创建一个Properties的对象出来（键值对集合，空容器）</span><br><span class="line"><span class="number">2</span>、调用load(字符输入流/字节输入流)方法，开始加载属性文件中的键值对数据到properties对象中去</span><br><span class="line"><span class="number">3</span>、调用getProperty(键)方法，根据键取值</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用Properties类读取属性文件中的键值对信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Properties的对象出来（键值对集合，空容器）</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始加载属性文件中的键值对数据到properties对象中去</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;properties-xml-log-app\\src\\users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、根据键取值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;赵敏&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;张无忌&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、遍历全部的键和值。</span></span><br><span class="line">        <span class="comment">//获取键的集合</span></span><br><span class="line">        Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="comment">//再根据键获取值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        properties.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（写）构造器"><a href="#（写）构造器" class="headerlink" title="（写）构造器"></a>（写）构造器</h2><ol>
<li>public Properties()。用于构建Properties集合对象（空容器）。</li>
</ol>
<h2 id="（写）常用方法"><a href="#（写）常用方法" class="headerlink" title="（写）常用方法"></a>（写）常用方法</h2><ol>
<li>public Object setProperty(String key, String value)。保存键值对数据到Properties对象中去。</li>
<li>public void store(OutputStream os, String comments)。把键值对数据，通过字节输出流写出到属性文件里去。注意这里需要写评论信息。</li>
<li>public void store(Writer w, String comments)。把键值对数据，通过字符输出流写出到属性文件里去。</li>
</ol>
<p>步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、先准备一个.properties属性文件，按照格式写几个键值对</span><br><span class="line"><span class="number">1</span>、创建Properties对象出来，</span><br><span class="line"><span class="number">2</span>、调用setProperty存储一些键值对数据</span><br><span class="line"><span class="number">3</span>、调用store(字符输出流/字节输出流, 注释)，将Properties集合中的键和值写到文件中</span><br><span class="line">	注意：第二个参数是注释，必须得加；</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Properties对象出来，先用它存储一些键值对数据</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;minmin&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;殷素素&quot;</span>, <span class="string">&quot;cuishan&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;susu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把properties对象中的键值对数据存入到属性文件中去</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/users2.properties&quot;</span>)</span><br><span class="line">                         , <span class="string">&quot;i saved many users!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="特殊文件：XML文件"><a href="#特殊文件：XML文件" class="headerlink" title="特殊文件：XML文件"></a>特殊文件：XML文件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>是什么？</p>
<ul>
<li>XML（ 全称EXtensible Markup Language， <strong>可扩展标记语言</strong> ）。</li>
<li>本质是一种数据的格式，可以用来存储复杂的数据结构，和数据关系。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>XML中的<strong>“&lt;标签名&gt;” 称为一个标签或一个元素</strong>，一般是<strong>成对出现</strong>的。</li>
<li>XML中的<strong>标签名可以自己定义</strong>（可扩展），但<strong>必须要正确的嵌套</strong>。</li>
<li>XML中<strong>只能有一个根标签</strong>。</li>
<li>XML中的标签<strong>可以有属性</strong>。</li>
<li>如果一个文件中放置的是XML格式的数据，这个文件就是XML文件，后缀一般要写成**.xml**。</li>
</ul>
<h3 id="XML的创建"><a href="#XML的创建" class="headerlink" title="XML的创建"></a>XML的创建</h3><ul>
<li>就是创建一个XML类型的文件，要求文件的后缀必须使用xml，如hello_world.xml。</li>
</ul>
<h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><ul>
<li>(1)XML文件的后缀名为：xml，文档声明（抬头）<strong>必须是第一行</strong>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> &gt; //自动</span></span><br><span class="line"><span class="meta">    version：XML默认的版本号码、该属性是必须存在</span></span><br><span class="line"><span class="meta">    encoding：本XML文件的编码</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>(2)XML中可以定义注释信息：<!--- 注释内容 --></p>
</li>
<li><p>(3)<strong>根标签<xx>有且只能有一个</xx></strong>。下面可以写子标签，子标签里面可以存属性，例如id&#x3D;”1”。再往下可以继续写子标签。</p>
</li>
<li><p>(4)标签必须承成对出现，又开始有结束： <name></name>。</p>
</li>
<li><p>(5)必须能够正确的嵌套。</p>
</li>
<li><p>XML中书写“&lt;”、“&amp;”等，可能会出现冲突，导致报错，此时可以用如下特殊字符替代。注意，XML可以在浏览器中直接渲染，在IDEA里面右键-open in expolrer（将这些特殊字符转换完成）。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span>    &lt;  小于</span><br><span class="line"><span class="symbol">&amp;gt;</span>    &gt;  大于</span><br><span class="line"><span class="symbol">&amp;amp;</span>   &amp;  和号</span><br><span class="line"><span class="symbol">&amp;apos;</span>  &#x27;  单引号</span><br><span class="line"><span class="symbol">&amp;quot;</span>  &quot;  引号</span><br><span class="line">例如：<span class="tag">&lt;<span class="name">data</span>&gt;</span> 3 <span class="symbol">&amp;lt;</span> 2 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> 5 <span class="symbol">&amp;gt;</span> 4 <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>XML中可以写一个叫<strong>CDATA的特殊数据区</strong>: <!--[CDATA[   …内容…  ]]-->，<strong>里面的内容可以随便写</strong>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data1</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">   		3 &lt; 2 &amp;&amp; 5 &gt; 4</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">data1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  根标签只能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一个用户&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张无忌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>minmin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span>&gt;</span>很多人<span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>敏敏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>wuji<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="作用和应用场景"><a href="#作用和应用场景" class="headerlink" title="作用和应用场景"></a>作用和应用场景</h3><ul>
<li>本质是一种数据格式，可以<strong>存储</strong>复杂的数据结构，和数据关系。</li>
<li>应用场景：经常用来做为<strong>系统的配置文件</strong>；或者作为一种特殊的数据结构，<strong>在网络中进行传输</strong>（现在用得不多但是也能作为一种方案）。</li>
</ul>
<h2 id="读取XML文件中的数据"><a href="#读取XML文件中的数据" class="headerlink" title="读取XML文件中的数据"></a>读取XML文件中的数据</h2><p>又叫，解析XML文件。使用程序读取XML文件中的数据。</p>
<ul>
<li>注意：程序员并不需要自己写原始的IO流代码来解析XML，难度较大！也相当繁琐！</li>
<li>其实，有很多开源的，好用的，解析XML的框架，最知名的是：<strong>Dom4j</strong>(第三方研发的)。</li>
</ul>
<h3 id="Dom4j下载"><a href="#Dom4j下载" class="headerlink" title="Dom4j下载"></a><strong>Dom4j</strong>下载</h3><ol>
<li>下载Dom4j框架，官网下载。</li>
<li>在项目中创建一个文件夹：lib。</li>
<li>将dom4j-2.1.3.jar文件复制到 lib 文件夹。</li>
<li>在jar文件上点右键，选择 Add as Library -&gt; 点击OK。</li>
<li>在类中导包使用。</li>
</ol>
<h3 id="DOM4J解析XML文件的思想：文档对象模型"><a href="#DOM4J解析XML文件的思想：文档对象模型" class="headerlink" title="DOM4J解析XML文件的思想：文档对象模型"></a>DOM4J解析XML文件的思想：文档对象模型</h3><p>思想</p>
<ol>
<li>首先用SAXReader解析器把文件内容一下子加载到内存中，变成一个Document（整个文档）对象。</li>
<li>通过Document对象就可以获取Element对象：元素（标签）。</li>
<li>Element又可以获取Attribute：属性、子元素、文本。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张无忌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>minmin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span> 3 <span class="symbol">&amp;lt;</span> 2 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> 5 &gt; 4 <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data1</span>&gt;</span></span><br><span class="line">			&lt;![CDATA[</span><br><span class="line">				3 &lt; 2 &amp;&amp; 5 &gt; 4</span><br><span class="line">			]]&gt;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">data1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>敏敏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>wuji<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span> 3 <span class="symbol">&amp;lt;</span> 2 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> 5 &gt; 4 <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data1</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">            	3 &lt; 2 &amp;&amp; 5 &gt; 4</span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">data1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>构造器</p>
<ol>
<li>public SAXReader()。构建Dom4J的解析器对象。Dom4j提供的解析器，可以认为是代表整个Dom4j框架。</li>
<li>public Document read(String url)。把XML文件读成Document对象。</li>
<li>public Document read(InputStream is)。通过字节输入流读取XML文件。</li>
</ol>
<p>常用方法</p>
<ol>
<li>Element getRootElement()。获得根元素对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();	<span class="comment">//获取了根元素</span></span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Element提供的方法"><a href="#Element提供的方法" class="headerlink" title="Element提供的方法"></a>Element提供的方法</h3><p>注意，<strong>只能从根元素一级一级向下解析</strong>。</p>
<ol>
<li>public String getName()。得到元素名字。</li>
<li>public List<Element> elements()。得到当前元素下所有子元素。</Element></li>
<li>public List<Element> elements(String name)。得到当前元素下指定名字的子元素返回集合。</Element></li>
<li>public Element element(String name)。得到当前元素下指定名字的子元素，<strong>如果有很多名字相同的返回第一个</strong>。</li>
<li>public String  attributeValue(String name)。通过属性名直接得到属性值。</li>
<li>public String elementText(子元素名)。得到指定名称的子元素的文本。</li>
<li>public String getText()。得到文本。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、获取根元素下的全部一级子元素。</span></span><br><span class="line">        <span class="comment">// List&lt;Element&gt; elements = root.elements();</span></span><br><span class="line">        List&lt;Element&gt; elements = root.elements(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            System.out.println(element.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取当前元素下的某个子元素。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">people</span> <span class="operator">=</span> root.element(<span class="string">&quot;people&quot;</span>);</span><br><span class="line">        System.out.println(people.getText());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下面有很多子元素user，默认获取第一个。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">user</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取元素的属性信息呢？</span></span><br><span class="line">        System.out.println(user.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">id</span> <span class="operator">=</span> user.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        System.out.println(id.getName());</span><br><span class="line">        System.out.println(id.getValue());</span><br><span class="line"></span><br><span class="line">        List&lt;Attribute&gt; attributes = user.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName() + <span class="string">&quot;=&quot;</span> + attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、如何获取全部的文本内容:获取当前元素下的子元素文本值</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        System.out.println(user.elementTextTrim(<span class="string">&quot;地址&quot;</span>)); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Element</span> <span class="variable">data</span> <span class="operator">=</span> user.element(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        System.out.println(data.getText());</span><br><span class="line">        System.out.println(data.getTextTrim()); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何往XML文件中写入数据？</p>
<ul>
<li>DOM4J也提供了往XML文件中写标签的方法，但是用起来比较麻烦，不好维护。这里不建议使用。</li>
<li>我们<strong>自己使用StringBuilder按照标签的格式拼接，然后再使用BufferedWriter写到XML文件中</strong>去就可以了。更加灵活。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、使用一个StringBuilder对象来拼接XML格式的数据。</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;book&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;name&gt;&quot;</span>).append(<span class="string">&quot;从入门到跑路&quot;</span>).append(<span class="string">&quot;&lt;/name&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;author&gt;&quot;</span>).append(<span class="string">&quot;dlei&quot;</span>).append(<span class="string">&quot;&lt;/author&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;price&gt;&quot;</span>).append(<span class="number">999.99</span>).append(<span class="string">&quot;&lt;/price&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;/book&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/book.xml&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充知识：约束XML文件的编写-了解"><a href="#补充知识：约束XML文件的编写-了解" class="headerlink" title="补充知识：约束XML文件的编写[了解]"></a>补充知识：约束XML文件的编写[了解]</h3><p>限制XML文件中的标签或者属性，只能按照规定的格式写。</p>
<p>专门用来限制xml书写格式的文档，比如：限制标签、属性应该怎么写。有两种约束技术：</p>
<ol>
<li>DTD约束文档。（<strong>不</strong>能够约束具体的数据类型。）</li>
<li>Schame约束文档。（能够约束具体的数据类型。）</li>
</ol>
<p>案例：利用DTD约束文档，约束一个XML文件的编写。（了解）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>编写DTD约束文档，后缀必须是.dtd</span><br><span class="line"><span class="number">2.</span>在需要编写的XML文件中导入该DTD约束文档（&lt;!DOCTYPE 书架 SYSTEM <span class="string">&quot;data.dtd&quot;</span>&gt;）</span><br><span class="line"><span class="number">3.</span>然后XML文件，就必须按照DTD约束文档指定的格式进行编写，否则报错！</span><br></pre></td></tr></table></figure>

<p>代码（了解）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ELEMENT 书架 (书+)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 书 (书名,作者,售价)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 书名 (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 作者 (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 售价 (<span class="keyword">#PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure>

<p>案例：利用schema约束文档，约束一个XML文件的编写。（了解）</p>
<p>步骤（了解）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>编写schema约束文档，后缀必须是.xsd，具体的形式到代码中观看。</span><br><span class="line"><span class="number">2.</span>在需要编写的XML文件中导入该schema约束文档</span><br><span class="line"><span class="number">3.</span>按照约束内容编写XML文件的标签。</span><br></pre></td></tr></table></figure>

<h1 id="日志技术-1"><a href="#日志技术-1" class="headerlink" title="日志技术"></a>日志技术</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>场景引入</p>
<ul>
<li>希望系统能记住某些数据是被谁操作的，比如被谁删除了？</li>
<li>想分析用户浏览系统的具体情况，以便挖掘用户的具体喜好？</li>
<li>当系统在开发中或者上线后出现了bug，崩溃了，该通过什么去分析、定位bug？</li>
</ul>
<p>日志</p>
<ul>
<li>好比生活中的日记，可以记录你生活中的点点滴滴。</li>
<li>程序中的日志，通常就是一个文件，里面记录的是<strong>程序运行过程中的各种信息</strong>。</li>
</ul>
<p>输出语句的弊端</p>
<ul>
<li>日志会展示在控制台。</li>
<li>不能更方便的将日志记录到其他的位置（文件，数据库）。</li>
<li>想取消日志，需要修改源代码才可以完成。</li>
</ul>
<p>日志技术</p>
<ul>
<li>可以将系统执行的信息，方便的记录到指定的位置（控制台、文件中、数据库中）。</li>
<li>可以随时以开关的形式控制日志的启停，无需侵入到源代码中去进行修改。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>输出语句</strong></th>
<th><strong>日志技术</strong></th>
</tr>
</thead>
<tbody><tr>
<td>输出位置</td>
<td>输出到控制台</td>
<td>可以将日志信息写入到文件或者数据库中</td>
</tr>
<tr>
<td>取消日志</td>
<td>需要修改代码，灵活性比较差</td>
<td>不需要修改代码，灵活性比较好</td>
</tr>
<tr>
<td>多线程</td>
<td>性能较差</td>
<td>性能较好</td>
</tr>
</tbody></table>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h3><ol>
<li>JUL（java.util.loggiing）。</li>
<li>Log4j。</li>
<li>Logback。</li>
<li>其他实现。</li>
</ol>
<h3 id="日志接口"><a href="#日志接口" class="headerlink" title="日志接口"></a>日志接口</h3><p>为了减轻负担，设置接口让大家都遵守。</p>
<ol>
<li>Commons Logging (JCL)。</li>
<li>Simple Logging Facade for Java (SLF4J)。</li>
</ol>
<ul>
<li>日志框架：牛人或者第三方公司已经做好的实现代码，后来者直接可以拿去使用。</li>
<li>日志接口：设计日志框架的一套标准，日志框架需要实现这些接口。</li>
<li>注意1：因为对Commons Logging接口不满意，有人就搞了SLF4J；因为对Log4j的性能不满意，有人就搞了Logback。</li>
<li>注意2：<strong>Logback是基于slf4j的日志规范实现的框架</strong>。</li>
</ul>
<h3 id="Logback日志框架"><a href="#Logback日志框架" class="headerlink" title="Logback日志框架"></a>Logback日志框架</h3><p>网站：<a target="_blank" rel="noopener" href="https://logback.qos.ch/index.html">https://logback.qos.ch/index.html</a> </p>
<p>Logback日志框架有以下几个模块：</p>
<ol>
<li>logback-core。<strong>基础模块</strong>，是其他两个模块依赖的基础（<strong>必须有</strong>）。</li>
<li>logback-classic。功能模块，<strong>完整实现了slf4j API</strong>的模块（<strong>必须有</strong>）。</li>
<li>logback-access。与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志的功能（可选，以后再接触）。</li>
</ol>
<p>想使用Logback日志框架，至少需要在项目中整合如下三个模块：</p>
<ol>
<li>slf4j-api。日志接口。</li>
<li>logback-core。基础模块。</li>
<li>logback-classic。功能模块。</li>
</ol>
<h2 id="Logback入门"><a href="#Logback入门" class="headerlink" title="Logback入门"></a>Logback入门</h2><p>需求：使用Logback日志框架，纪录系统的运行信息。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>导入Logback框架到项目中去。</span><br><span class="line"><span class="number">2.</span>将Logback框架的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）。</span><br><span class="line"><span class="number">3.</span>创建Logback框架提供的Logger对象，然后用Logger对象调用其提供的方法就可以记录系统的日志信息。</span><br><span class="line">创建一个日志记录日对象：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(“类名<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目库中去。</span><br><span class="line"><span class="number">2.</span>必须将Logback的核心配置文件logback.xml直接拷贝到src目录下。</span><br><span class="line"><span class="number">3.</span>在代码中获取日志的对象</span><br><span class="line"><span class="number">4.</span>调用日志对象的方法记录日志信息</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBackTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Logger日志对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;LogBackTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//while (true) &#123;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法开始执行~~~&quot;</span>);</span><br><span class="line">                chu(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法执行成功~~~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;chu法方法执行失败了，出现了bug~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数a:&quot;</span> + a);</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数b:&quot;</span> + b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;结果是：&quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logback-xml日志配置文件"><a href="#Logback-xml日志配置文件" class="headerlink" title="Logback.xml日志配置文件"></a>Logback.xml日志配置文件</h2><p>核心配置文件logback.xml，<strong>对Logback日志框架进行控制</strong>的。在记录日志时会读取配置文件中的配置信息，从而记录日志的形式。</p>
<p>具体可以做哪些<strong>配置</strong>？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 可以配置日志输出的位置是文件、还是控制台。</span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">2. 可以配置日志输出的格式。</span><br><span class="line">3. 还可以配置日志关闭和开启、以及哪些日志输出哪些日志不输出。// 设置为 “ALL”或“OFF”。//设置只输出到配置文件或者控制台，可以删掉其中一行。</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;ALL&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如下图所示，控制日志往文件中输出，还是往控制台输出**</li>
</ul>
<p><img src="/2024/04/08/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/1668045955362.png" alt="1668045955362"></p>
<ul>
<li><strong>如下图所示，控制打开和关闭日志</strong></li>
</ul>
<p><img src="/2024/04/08/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/1668046078574.png" alt="1668046078574"></p>
<ul>
<li><p><strong>如下图所示，控制日志的输出的格式</strong></p>
<p>日志格式是由一些特殊的符号组成，可以根据需要删减不想看到的部分。比如不想看到线程名那就不要[%thread]。但是不建议同学们更改这些格式，因为这些都是日志很基本的信息。</p>
</li>
</ul>
<p><img src="/2024/04/08/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/1668046216355.png" alt="1668046216355"></p>
<h2 id="Logback设置日志级别【重要】"><a href="#Logback设置日志级别【重要】" class="headerlink" title="Logback设置日志级别【重要】"></a>Logback设置日志级别【重要】</h2><h3 id="认识日志级别"><a href="#认识日志级别" class="headerlink" title="认识日志级别"></a>认识日志级别</h3><p>日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（优先级依次升高）：</p>
<table>
<thead>
<tr>
<th><strong>日志级别</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>trace</td>
<td>追踪，指明程序运行轨迹</td>
</tr>
<tr>
<td>debug</td>
<td>调试，实际应用中一般将其作为最低级别，而 trace 则很少使用</td>
</tr>
<tr>
<td>info</td>
<td>输出重要的运行信息，数据连接、网络连接、IO操作等等，使用较多</td>
</tr>
<tr>
<td>warn</td>
<td>警告信息，可能会发生问题，使用较多</td>
</tr>
<tr>
<td>error</td>
<td>错误信息, 使用较多</td>
</tr>
</tbody></table>
<h3 id="日志级别的作用"><a href="#日志级别的作用" class="headerlink" title="日志级别的作用"></a>日志级别的作用</h3><p>用于<strong>控制系统中哪些日志级别是可以输出的</strong>。</p>
<h3 id="如何设置日志级别"><a href="#如何设置日志级别" class="headerlink" title="如何设置日志级别"></a>如何设置日志级别</h3><p>可以在配置文件中书写日志级别：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">“info</span>&quot;&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只有日志的级别是<strong>大于或等于</strong>核心配置文件配置的日志级别，<strong>才会被记录</strong>，否则不记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/08/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/" data-id="cluqm6gm80000gcuh4guh74cp" data-title="【Java基础】特殊文本文件、日志技术" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【Java基础】【java.io】io流" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.io%E3%80%91io%E6%B5%81/" class="article-date">
  <time class="dt-published" datetime="2024-04-07T02:00:00.000Z" itemprop="datePublished">2024-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.io%E3%80%91io%E6%B5%81/">【Java基础】java.io包下的常用API-io流</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>之前学习的变量、数组、对象和集合都是内存中的数据容器，它们记住的数据在断电或者程序终止时会丢失。</p>
<p>如果想长期保存数据，应该怎么做？</p>
<ul>
<li>文件是非常重要的存储方式，在计算机硬盘中。</li>
<li>即便断电，或者程序终止了，存储在硬盘文件中的数据也不会丢失。</li>
</ul>
<p><strong>(1)File类</strong></p>
<p>File是java.io.包下的类， File类的对象，用于代表当前操作系统的文件（可以是<strong>文件</strong>、或<strong>文件夹</strong>）。</p>
<p>常见功能</p>
<ul>
<li>获取文件信息（大小，文件名，修改时间）。</li>
<li>创建文件&#x2F;文件夹。</li>
<li>删除文件&#x2F;文件夹。</li>
<li>判断文件的类型。</li>
<li>……</li>
</ul>
<p>注意：File类<strong>只能对文件本身</strong>进行操作，<strong>不能读写文件里面存储的数据</strong>。</p>
<p><strong>(2)IO流</strong></p>
<p>用于读写数据的（可以读写文件，或网络中的数据…）。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ol>
<li>public File(String pathname)。根据文件路径创建文件对象。（最重要！）</li>
<li>public File(String parent, String child)。根据父路径和子路径名字创建文件对象。</li>
<li>public File(File  parent, String child)。根据父路径对应文件对象和子路径名字创建文件对象。</li>
</ol>
<ul>
<li>File对象既可以代表<strong>文件</strong>、也可以代表<strong>文件夹</strong>。</li>
<li>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也<strong>允许是不存在</strong>的。</li>
</ul>
<p>路径分隔符</p>
<ol>
<li>&#x2F;（<strong>推荐</strong>）</li>
<li>\\</li>
<li>File.separator</li>
</ol>
<p>绝对路径</p>
<ul>
<li>从盘符开始。</li>
<li>File file1 &#x3D; new File(“D:\itheima\a.txt”);</li>
</ul>
<p>相对路径（<strong>开发规范</strong>）</p>
<ul>
<li>不带盘符，默认直接到当前工程下的目录寻找文件。</li>
<li>File file3 &#x3D; new File(“模块名\a.txt”);</li>
</ul>
<h3 id="常用方法1：判断文件类型、获取文件信息"><a href="#常用方法1：判断文件类型、获取文件信息" class="headerlink" title="常用方法1：判断文件类型、获取文件信息"></a>常用方法1：判断文件类型、获取文件信息</h3><ol>
<li>public boolean exists()。判断当前文件对象，对应的文件路径是否存在，存在返回true。</li>
<li>public boolean isFile()。判断当前文件对象指代的是否是文件，是文件返回true，反之。</li>
<li>public boolean isDirectory()。判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。</li>
<li>public String getName()。获取文件的名称（包<strong>含后缀</strong>）。</li>
<li>public long length()。获取文件的大小，返回字节个数。（然后可以转换成SimpleDateFormat并用format格式化。）</li>
<li>public long lastModified()。获取文件的最后修改时间。</li>
<li>public String getPath()。获取创建文件对象时，使用的路径。</li>
<li>public String getAbsolutePath()。获取绝对路径。</li>
</ol>
<h3 id="常用方法2：创建文件、删除文件"><a href="#常用方法2：创建文件、删除文件" class="headerlink" title="常用方法2：创建文件、删除文件"></a>常用方法2：创建文件、删除文件</h3><p>创建文件</p>
<ol>
<li>public boolean createNewFile()。创建一个新的空的文件。（程序有可能担心我们乱写盘符，因此报异常，直接alt+enter抛出去就行。）</li>
<li>public boolean mkdir()。只能创建一级文件夹。</li>
<li>public boolean mkdirs()。可以创建<strong>多级</strong>文件夹。（强大！）</li>
</ol>
<p>删除文件</p>
<ol>
<li>public boolean delete()。删除文件、空文件夹。</li>
</ol>
<p>注意：delete方法默认<strong>只能删除文件和空文件夹，删除后的文件不会进入回收站</strong>。</p>
<h3 id="常用方法3：遍历文件夹"><a href="#常用方法3：遍历文件夹" class="headerlink" title="常用方法3：遍历文件夹"></a>常用方法3：遍历文件夹</h3><ol>
<li>public String[] list()。获取当前目录下所有的”<strong>一级文件名称</strong>“到一个字符串数组中去返回。</li>
<li>public File[] listFiles()。获取当前目录下所有的”<strong>一级文件对象</strong>“到一个文件对象数组中去返回（重点）。</li>
</ol>
<p>注意事项：</p>
<ol>
<li>当主调是文件，或者路径不存在时，返回null。</li>
<li>当主调是空文件夹时，返回一个长度为0的数组。</li>
<li>当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回。</li>
<li>当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件。</li>
<li>当主调是一个文件夹，但是没有权限访问该文件夹时，返回null。</li>
</ol>
<h1 id="前置：方法递归"><a href="#前置：方法递归" class="headerlink" title="前置：方法递归"></a>前置：方法递归</h1><p>为了实现文件的多级操作。</p>
<p>是什么？</p>
<ul>
<li>递归是一种算法，在程序设计语言中广泛应用。</li>
<li>从形式上说：方法调用自身的形式称为方法递归（ recursion）。</li>
</ul>
<p>形式</p>
<ul>
<li>直接递归：方法自己调用自己。（比较常见。）</li>
<li>间接递归：方法调用其他方法，其他方法又回调方法自己。</li>
</ul>
<p>注意</p>
<ul>
<li>递归如果没有<strong>控制好终止</strong>，会出现递归死循环，导致<strong>栈内存溢出错误</strong>。</li>
<li>递归调用的特点是：<strong>一层一层调用，再一层一层往回返。</strong></li>
</ul>
<h2 id="递归算法三要素"><a href="#递归算法三要素" class="headerlink" title="递归算法三要素"></a>递归算法三要素</h2><p>以求阶乘为例。</p>
<ol>
<li>递归的公式： f(n) &#x3D;  f(n-1) * n;</li>
<li>递归的终结点：f(1) 。</li>
<li>递归的方向必须走向终结点。</li>
</ol>
<h2 id="递归文件搜索"><a href="#递归文件搜索" class="headerlink" title="递归文件搜索"></a>递归文件搜索</h2><p>莫得公式，怎么办？</p>
<p>案例：在<code>D:\\</code>判断下搜索QQ.exe这个文件，然后直接输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先调用文件夹的listFiles方法，获取文件夹的一级内容，得到一个数组</span><br><span class="line"><span class="number">2.</span>然后再遍历数组，获取数组中的File对象</span><br><span class="line"><span class="number">3.</span>因为File对象可能是文件也可能是文件夹，所以接下来就需要判断</span><br><span class="line">	判断File对象如果是文件，就获取文件名，如果文件名是`QQ.exe`则打印，否则不打印</span><br><span class="line">	判断File对象如果是文件夹，就递归执行<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>步骤</span><br><span class="line">所以：把<span class="number">1</span>，<span class="number">2</span>,<span class="number">3</span>步骤写成方法，递归调用即可。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件搜索的实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;QQ.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去目录下搜索某个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 要搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、把非法的情况都拦截住</span></span><br><span class="line">        <span class="keyword">if</span>(dir == <span class="literal">null</span> || !dir.exists() || dir.isFile())&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 代表无法搜索</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、dir不是null,存在，一定是目录对象。</span></span><br><span class="line">        <span class="comment">// 获取当前目录下的全部一级文件对象。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4、遍历全部一级文件对象。</span></span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">// 5、判断文件是否是文件,还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 是文件，判断这个文件名是否是我们要找的</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;找到了：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">                        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                        runtime.exec(f.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是文件夹，继续重复这个过程（递归）</span></span><br><span class="line">                    searchFile(f, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：删除一个非空文件夹。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、File默认不可以删除非空文件夹</span><br><span class="line"><span class="number">2</span>、我们需要遍历文件夹，先删除里面的内容，再删除自己。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<p>得空补上。</p>
<h1 id="前置：字符集"><a href="#前置：字符集" class="headerlink" title="前置：字符集"></a>前置：字符集</h1><h2 id="常见字符集"><a href="#常见字符集" class="headerlink" title="常见字符集"></a>常见字符集</h2><p><strong>标准ASCII字符集</strong></p>
<ul>
<li>ASCII(American Standard Code for Information Interchange)： 美国信息交换标准代码，包括了<strong>英文、数字、符号</strong>等。</li>
<li>标准ASCII使用1个字节存储一个字符，0~127作为码点，<strong>首位是0</strong>，总共可表示128个字符，对美国佬来说完全够用。</li>
</ul>
<p><strong>GBK</strong>（汉字内码扩展规范，国标）</p>
<ul>
<li>汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成<strong>两个字节</strong>的形式存储。</li>
<li>注意：GBK兼容了ASCII字符集。GBK规定，汉字的第一个字节的第一位必须是1。</li>
</ul>
<p>Unicode字符集(统一码，也叫万国码)</p>
<ul>
<li>Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集。</li>
<li>提供多重编码方案。最早是UTF-32，4个字节表示一个字符，但是占内存太大，通信效率变低。</li>
</ul>
<p><strong>UTF-8</strong></p>
<ul>
<li>是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字节，2个字节，3个字节，4个字节。</li>
<li>英文字符、数字等只占1个字节（兼容标准ASCII编码），<strong>汉字字符占用3个</strong>字节。</li>
<li><strong>注意：技术人员在开发时都应该使用UTF-8编码</strong>！</li>
<li>UTF-8编码方式(二进制)<ul>
<li>0xxxxxxx （ASCII码）</li>
<li>110xxxxx  10xxxxxx</li>
<li>1110xxxx  10xxxxxx  10xxxxxx</li>
<li>11110xxx  10xxxxxx  10xxxxxx  10xxxxxx</li>
</ul>
</li>
</ul>
<p>注意事项</p>
<ul>
<li>注意1：字符编码时使用的字符集，和解码时使用的<strong>字符集必须一致，否则会出现乱码</strong>。</li>
<li>注意2：<strong>英文、数字一般不会乱码</strong>，因为很多字符集都兼容了ASCII编码。</li>
</ul>
<h2 id="字符集的编码、解码操作"><a href="#字符集的编码、解码操作" class="headerlink" title="字符集的编码、解码操作"></a>字符集的编码、解码操作</h2><p>String类下的方法和构造器。</p>
<p>编码：把字符按照指定字符集编码成字节。</p>
<ol>
<li>byte[] getBytes()。使用<strong>平台的默认字符集</strong>将该String编码为一系列字节，将结果存储到新的字节数组中。</li>
<li>byte[] getBytes(String charsetName)。使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 。</li>
</ol>
<p>解码：把字节按照指定字符集解码成字符。</p>
<ol>
<li>String(byte[] bytes)。通过使用<strong>平台的默认字符集</strong>解码指定的字节数组来构造新的String。</li>
<li>String(byte[] bytes, String charsetName)。通过指定的字符集解码指定的字节数组来构造新的String。</li>
</ol>
<h1 id="IO流（字节流）"><a href="#IO流（字节流）" class="headerlink" title="IO流（字节流）"></a>IO流（字节流）</h1><p>IO流概述：输入输出流，用来读写数据的。</p>
<ul>
<li>I指Input，称为输入流：负责把数据读到内存中去。</li>
<li>O指Output，称为输出流：负责写数据出去。</li>
</ul>
<p>怎么学？</p>
<ol>
<li>先搞清楚IO流的分类、体系。</li>
<li>再挨个学习每个IO流的作用、用法。</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>按照流的方向，分为输入流、输出流。</li>
<li>按照数据的最小单位，分为字节流（适合操作所有类型的文件）、字符流（只适合操作纯文本文件）。</li>
<li>–&gt;所以一共是4大基础流：<ol>
<li>字节输入流。以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流。</li>
<li>字节输出流。以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流。</li>
<li>字符输入流。以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流。</li>
<li>字符输出流。以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。</li>
</ol>
</li>
</ul>
<h2 id="IO流的体系"><a href="#IO流的体系" class="headerlink" title="IO流的体系"></a>IO流的体系</h2><ul>
<li>java.io包下：<ul>
<li>字节流–&gt;字节输入流（InputStream）、字节输出流（OutputStream）；</li>
<li>字符流–&gt;字符输入流（Reader）、字符输出流（Writer）。</li>
</ul>
</li>
<li>上述都是抽象类。然后对应有实现类，是在前面加个File：<ul>
<li>字节流–&gt;字节输入流（FileInputStream）、字节输出流（FileOutputStream）；</li>
<li>字符流–&gt;字符输入流（FileReader）、字符输出流（FileWriter）。</li>
</ul>
</li>
</ul>
<p><img src="/2024/04/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.io%E3%80%91io%E6%B5%81/IO%E6%B5%81%E4%BD%93%E7%B3%BB.jpg"></p>
<h2 id="FileInputStream文件字节输入流"><a href="#FileInputStream文件字节输入流" class="headerlink" title="FileInputStream文件字节输入流"></a>FileInputStream文件字节输入流</h2><p>以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public FileInputStream(File file)。创建字节输入流管道与源文件接通。</li>
<li>public FileInputStream(String pathname)。创建字节输入流管道与源文件接通。（是1的简化写法，也是推荐写法，系统里帮忙创建了File类。）</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>public int read()。<strong>每次读取一个字节</strong>返回，如果发现没有数据可读会返回-1。返回值表示当前这一次读取的字节个数。</li>
<li>public int read(byte[] buffer)。每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1。</li>
</ol>
<h3 id="FileInputStream读取一个字节"><a href="#FileInputStream读取一个字节" class="headerlink" title="FileInputStream读取一个字节"></a>FileInputStream读取一个字节</h3><p>使用FileInputStream读取文件中的字节数据，步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建FileInputStream文件字节输入流管道，与源文件接通。</span><br><span class="line"><span class="number">2.</span>调用read()方法开始读取文件的字节数据。</span><br><span class="line"><span class="number">3.</span>调用close()方法释放资源</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输入流，每次读取一个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建文件字节输入流管道，与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((<span class="string">&quot;file-io-app\\src\\itheima01.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件的字节数据。</span></span><br><span class="line">        <span class="comment">// public int read():每次读取一个字节返回，如果没有数据了，返回-1.</span></span><br><span class="line">        <span class="type">int</span> b; <span class="comment">// 用于记住读取的字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、流使用完毕之后，必须关闭！释放系统资源！</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的问题：</p>
<ol>
<li>这种方法读取数据的性能很差（从系统资源里面调）。（开发规范：尽量减少从硬件内存中读取数据的频次。）</li>
<li>读取汉字会乱码。一个中文在UTF-8编码方案中是占3个字节，采用一次读取一个字节的方式，读一个字节就相当于读了1&#x2F;3个汉字，此时将这个字节转换为字符，会有乱码。</li>
</ol>
<h3 id="FileInputStream读取多个字节"><a href="#FileInputStream读取多个字节" class="headerlink" title="FileInputStream读取多个字节"></a>FileInputStream读取多个字节</h3><p>为了提高效率，我们可以使用另一个read(byte[] bytes)的重载方法，可以一次读取多个字节，至于一次读多少个字节，就在于你传递的数组有多大。</p>
<p>使用FileInputStream一次读取多个字节的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建FileInputStream文件字节输入流管道，与源文件接通。</span><br><span class="line"><span class="number">2.</span>调用read(<span class="type">byte</span>[] bytes)方法开始读取文件的字节数据。</span><br><span class="line"><span class="number">3.</span>调用close()方法释放资源</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用FileInputStream每次读取多个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流对象代表字节输入流管道与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima02.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件中的字节数据：每次读取多个字节。</span></span><br><span class="line">        <span class="comment">//  public int read(byte b[]) throws IOException</span></span><br><span class="line">        <span class="comment">//  每次读取多个字节到字节数组中去，返回读取的字节数量，读取完毕会返回-1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环改造。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。  abc 66</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意：读取多少，倒出多少。(否则填不满的位置还是存放之前的内容)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 性能得到了明显的提升！！</span></span><br><span class="line">        <span class="comment">// 这种方案也不能避免读取汉字输出乱码的问题！！</span></span><br><span class="line"></span><br><span class="line">        is.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的问题：</p>
<ol>
<li>使用FileInputStream每次读取多个字节，读取性能得到了提升。</li>
<li>但读取汉字输出还是会乱码。</li>
</ol>
<p>使用字节流读取中文，<strong>如何保证输出不乱码</strong>，怎么解决？</p>
<ul>
<li>方式1：自己定义一个字节数组与被读取的文件大小一样大，然后使用该字节数组，一次读完文件的全部字节。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、准备一个字节数组，大小与文件的大小正好一样大。</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> f.length();</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) size];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buffer);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>

<ul>
<li>方式2：Java官方为InputStream提供了如下方法，可以直接把文件的全部字节读取到一个字节数组中返回。&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; public byte[] <strong>readAllBytes</strong>() throws IOException。直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、调用方法读取所有字节，返回一个存储所有字节的字节数组。</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>

<p>注意：<strong>一次读取所有字节虽然可以解决乱码问题，但是文件不能过大，如果文件过大，可能导致内存溢出。</strong></p>
<p>—&gt;读写文本内容更适合用<strong>字符流</strong>。字节流适合做数据的转移，例如，文件复制等。</p>
<h2 id="FileOutputStream文件字节输出流"><a href="#FileOutputStream文件字节输出流" class="headerlink" title="FileOutputStream文件字节输出流"></a>FileOutputStream文件字节输出流</h2><p>作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去。</p>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public FileOutputStream(File file)。创建字节输出流管道与源文件对象接通。</li>
<li>public FileOutputStream(String filepath)。创建字节输出流管道与源文件路径接通。</li>
<li>public FileOutputStream(File file，boolean append)。创建字节输出流管道与源文件对象接通，可<strong>追加数据</strong>。</li>
<li>public FileOutputStream(String filepath，boolean append)。创建字节输出流管道与源文件路径接通，可<strong>追加数据</strong>。</li>
</ol>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>public void write(int a)。写一个字节出去。</li>
<li>public void write(byte[] buffer)。写一个字节数组出去。</li>
<li>public void write(byte[] buffer , int pos , int len)。写一个字节数组的一部分出去。</li>
<li>public void close() throws IOException。关闭流。</li>
</ol>
<p>FileOutputStream往文件中写数据的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建FileOutputStream文件字节输出流管道，与目标文件接通。</span><br><span class="line"><span class="number">2.</span>调用wirte()方法往文件中写数据</span><br><span class="line"><span class="number">3.</span>调用close()方法释放资源</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输出流FileOutputStream的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="comment">// 覆盖管道：覆盖之前的数据</span></span><br><span class="line"><span class="comment">//        OutputStream os =</span></span><br><span class="line"><span class="comment">//                new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加数据的管道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/itheima04out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始写字节数据出去了</span></span><br><span class="line">        os.write(<span class="number">97</span>); <span class="comment">// 97就是一个字节，代表a</span></span><br><span class="line">        os.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// &#x27;b&#x27;也是一个字节</span></span><br><span class="line">        <span class="comment">// os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我爱你中国abc&quot;</span>.getBytes();</span><br><span class="line">        os.write(bytes);</span><br><span class="line"></span><br><span class="line">        os.write(bytes, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换行符</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        os.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例：字节流复制文件"><a href="#案例：字节流复制文件" class="headerlink" title="案例：字节流复制文件"></a>案例：字节流复制文件</h3><p>需求：要复制一张图片，从磁盘<code>D:/resource/meinv.png</code>的一个位置，复制到<code>C:/data/meinv.png</code>位置。</p>
<p>思路：源路径–(创建字节输入流管道)-&gt;内存(字节数组)–(创建字节输出流管道)-&gt;新路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>需要创建一个FileInputStream流与源文件接通，创建FileOutputStream与目标文件接通</span><br><span class="line"><span class="number">2.</span>然后创建一个数组，使用FileInputStream每次读取一个字节数组的数据，存如数组中</span><br><span class="line"><span class="number">3.</span>然后再使用FileOutputStream把字节数组中的有效元素，写入到目标文件中</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：使用字节流完成对文件的复制操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：复制照片。</span></span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.png&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">        <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字节流非常适合做一切文件的复制操作。	任何文件的底层都是字节，字节流做复制，是一字不漏的转移完全部字节，只要复制后的文件格式一致就没问题!</p>
<h1 id="IO流资源释放"><a href="#IO流资源释放" class="headerlink" title="IO流资源释放"></a>IO流资源释放</h1><p>如果前面的操作出现问题，那就没有机会执行close()方法了。</p>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><ul>
<li><strong>finally代码区</strong>的特点：无论try中的程序是正常执行了，还是出现了异常，最后都<strong>一定会执行finally区</strong>，除非JVM终止。（注意千万不要在finally里面返回数据，不然就是一场空。）</li>
<li>作用：一般用于在程序执行完成后进行<strong>资源的释放操作</strong>（专业级做法）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源的操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(os != <span class="literal">null</span>) os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><p>JDK7以后的资源释放。</p>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象<span class="number">1</span>; 资源对象<span class="number">2</span>;)&#123;</span><br><span class="line">    使用资源的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    处理异常的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：注意到没有，这里没有释放资源的代码。它会自动是否资源</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握释放资源的方式：try-with-resource</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    	<span class="keyword">try</span> (</span><br><span class="line">          <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.png&quot;</span>);</span><br><span class="line">          <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">          <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.png&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意小括号里面只能放置资源变量（流对象）。</li>
<li>什么是资源？资源都是会实现AutoCloseable接口的，都会有一个close方法。</li>
<li>资源放到小括号里面后，用完会被自动调用其close方法完成资源的释放操作。</li>
</ul>
<h1 id="IO流（字符流）"><a href="#IO流（字符流）" class="headerlink" title="IO流（字符流）"></a>IO流（字符流）</h1><ul>
<li>字节流：适合复制文件等，不适合读写文本文件。</li>
<li>字符流：适合读写文本文件内容。</li>
</ul>
<p>作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去。</p>
<h2 id="FileReader文件字符输入流"><a href="#FileReader文件字符输入流" class="headerlink" title="FileReader文件字符输入流"></a>FileReader文件字符输入流</h2><h3 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public FileReader(File file)。创建字符输入流管道与源文件接通。</li>
<li>public FileReader(String pathname)。创建字符输入流管道与源文件接通。</li>
</ol>
<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>public int read()。<strong>每次读取一个字符返回</strong>，如果发现没有数据可读会返回-1。</li>
<li>public int read(char[] buffer)。每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1。</li>
</ol>
<p>FileReader读取文件的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建FileReader对象与要读取的源文件接通</span><br><span class="line"><span class="number">2.</span>调用read()方法读取文件中的字符</span><br><span class="line"><span class="number">3.</span>调用close()方法关闭流</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输入流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字符输入流管道与源文件接通</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 2、一个字符一个字符的读（性能较差）</span></span><br><span class="line"><span class="comment">//            int c; // 记住每次读取的字符编号。</span></span><br><span class="line"><span class="comment">//            while ((c = fr.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print((char) c);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 每次读取一个字符的形式，性能肯定是比较差的。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、每次读取多个字符。（性能是比较不错的！）</span></span><br><span class="line">            <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字符。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileWriter文件字符输出流"><a href="#FileWriter文件字符输出流" class="headerlink" title="FileWriter文件字符输出流"></a>FileWriter文件字符输出流</h2><p>作用：以内存为基准，把内存中的数据以字符的形式写出到文件中去。</p>
<h3 id="构造器-3"><a href="#构造器-3" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public FileWriter(File file)。创建字节输出流管道与源文件对象接通。</li>
<li>public FileWriter(String filepath)。创建字节输出流管道与源文件<strong>路径</strong>接通。</li>
<li>public FileWriter(File file，boolean append)。创建字节输出流管道与源文件对象接通，可追加数据。</li>
<li>public FileWriter(String filepath，boolean append)。创建字节输出流管道与源文件路径接通，可<strong>追加</strong>数据。</li>
</ol>
<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>void write(int c)。写一个字符。</li>
<li>void write(String str)。写一个字符串。</li>
<li>void write(String str, int off, int len)。写一个字符串的一部分。</li>
<li>void write(char[] cbuf)。写入一个字符数组。</li>
<li>void write(char[] cbuf, int off, int len)。写入字符数组的一部分。</li>
</ol>
<p>步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建FileWirter对象与要读取的目标文件接通</span><br><span class="line"><span class="number">2.</span>调用write(字符数据/字符数组/字符串)方法读取文件中的字符</span><br><span class="line"><span class="number">3.</span>调用close()方法关闭流</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输出流：写字符数据出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 0、创建一个文件字符输出流管道与目标文件接通。</span></span><br><span class="line">                <span class="comment">// 覆盖管道</span></span><br><span class="line">                <span class="comment">// Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;);</span></span><br><span class="line">                <span class="comment">// 追加数据的管道</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima02out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 1、public void write(int c):写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            fw.write(<span class="number">97</span>);</span><br><span class="line">            <span class="comment">//fw.write(&#x27;磊&#x27;); // 写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、public void write(String c)写一个字符串出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">            <span class="type">char</span>[] buffer = &#123;<span class="string">&#x27;黑&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">            fw.write(buffer);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">            fw.write(buffer, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效。</p>
<ol>
<li>public void flush() throws IOException。刷新流，就是将内存中缓存的数据立即写到文件中去生效！刷新流之后数据流可以继续使用。（数据在内存中装满了会自动刷新写进文件然后继续接。）</li>
<li>public void close() throws IOException。<strong>关闭流的操作，包含了刷新！</strong>关闭之后就不可以继续用了。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>字节流适合做一切文件数据的拷贝（音视频，文本）；字节流不适合读取中文内容输出。</li>
<li>字符流适合做文本文件的操作（读，写）。</li>
</ul>
<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p>更新（原因&#x2F;区别）</p>
<ul>
<li>前面学的以File开头的实现类称为原始流&#x2F;低级流。</li>
<li>以Buffered开头称为包装流&#x2F;处理流。对原始流进行包装，以提高原始流读写数据的性能。</li>
</ul>
<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>原理</p>
<ul>
<li>字节缓冲输入流自带了8KB缓冲池；字节缓冲输出流也自带了8KB缓冲池。</li>
</ul>
<p>构造器</p>
<ol>
<li>public BufferedInputStream(InputStream is)。把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能。</li>
<li>public BufferedOutputStream(OutputStream os)。把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能。</li>
</ol>
<p>功能上并无很大变化，性能提升。</p>
<h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p>原理：</p>
<ul>
<li>自带8K（8192）的字符缓冲池，可以提高字符输入流、输出流读取字符数据的性能。</li>
</ul>
<p>构造器：</p>
<ol>
<li>public BufferedReader(Reader r)。把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能。</li>
<li>public String readLine()。（新增，按照行读取。）读取一行数据返回，如果没有数据可读了，会返回null。</li>
<li>public BufferedWriter(Writer r)。把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能。</li>
<li>public void newLine()。（新增，换行。）</li>
</ol>
<p>案例：拷贝出师表并恢复顺序。</p>
<h2 id="原始流、缓冲流的性能分析-重点"><a href="#原始流、缓冲流的性能分析-重点" class="headerlink" title="原始流、缓冲流的性能分析[重点]"></a>原始流、缓冲流的性能分析[重点]</h2><p>测试用例：</p>
<ul>
<li>分别使用原始的字节流，以及字节缓冲流复制一个很大视频。</li>
</ul>
<p>测试步骤：</p>
<ol>
<li>使用低级的字节流按照一个一个字节的形式复制文件。</li>
<li>使用低级的字节流按照字节数组的形式复制文件。</li>
<li>使用高级的缓冲字节流按照一个一个字节的形式复制文件。</li>
<li>使用高级的缓冲字节流按照字节数组的形式复制文件。</li>
</ol>
<ul>
<li><strong>默认情况下，采用一次复制1024个字节，缓冲流完胜。</strong></li>
<li><strong>一次读取8192个字节时，低级流和缓冲流性能相当。</strong>相差的那几毫秒可以忽略不计。</li>
<li><strong>数组越大性能越高，低级流和缓冲流性能相当。</strong>相差的那几秒可以忽略不计。</li>
<li>数组大到一定程度，性能已经提高了多少了，甚至缓冲流的性能还没有低级流高。</li>
</ul>
<p>结论：推荐使用哪种方式提高字节流读写数据的性能？</p>
<ul>
<li><strong>缓冲流的性能不一定比低级流高，其实低级流自己加一个数组，性能其实是不差。</strong>只不过缓冲流帮你加了一个相对而言大小比较合理的数组 。</li>
<li>建议使用<strong>字节缓冲输入流、字节缓冲输出流，结合字节数组的方式，目前来看是性能最优</strong>的组合。</li>
</ul>
<h1 id="IO流-转换流"><a href="#IO流-转换流" class="headerlink" title="IO流-转换流"></a>IO流-转换流</h1><p>转换流：可以将字节流转换为字符流，并且可以指定编码方案。</p>
<ul>
<li>解决不同编码时，字符流读取文本内容乱码的问题。</li>
<li>解决思路：先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了</li>
</ul>
<p>原因：</p>
<ul>
<li>FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码，因为FileReader它遇到汉字默认是按照3个字节来读取的，而GBK格式的文件一个汉字是占2个字节，这样就会导致乱码。</li>
<li>如果代码编码和被读取的文本文件的编码是不一致的，使用字符流读取文本文件时就会出现乱码！</li>
</ul>
<h2 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h2><ul>
<li>InputStreamzhuan转换为Reader，是Reader的子类，也算是字符输入流。</li>
<li>不能单独使用，内部需要封装一个InputStream的子类对象，再指定一个编码表，如果<strong>不指定编码表，默认会按照UTF-8形式</strong>进行转换。</li>
</ul>
<p>常用方法：</p>
<ol>
<li>public InputStreamReader(InputStream is)。把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样）。</li>
<li>public InputStreamReader(InputStream is ，String charset)。把原始的字节输入流，按照指定字符集编码转成字符输入流(重点)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、得到文件的原始字节流（GBK的字节流形式）</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima06.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输入流包装成缓冲字符输入流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">                )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h2><p>如何控制写出去的字符使用的字符集编码？</p>
<ol>
<li>调用String提供的getBytes方法。</li>
<li>用字符输出转换流实现。</li>
</ol>
<ul>
<li>OutputStream转换为Writer，是Writer的子类，算是字符输出流。</li>
<li>不能单独使用，内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。</li>
<li>作用：可以控制写出去的字符使用什么字符集编码。 </li>
<li>解决思路：获取字节输出流，再按照指定的字符集编码将其转换成字符输出流，以后写出去的字符就会用该字符集编码了。</li>
</ul>
<p>常用方法：</p>
<ol>
<li>public OutputStreamWriter(OutputStream os)。可以把原始的字节输出流，按照代码默认编码转换成字符输出流。</li>
<li>public OutputStreamWriter(OutputStream os，String charset)。可以把原始的字节输出流，按照指定编码转换成字符输出流(重点)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定写出去的字符编码。</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字节输出流</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima07out.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输出流包装成缓冲字符输出流</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(<span class="string">&quot;我是中国人abc&quot;</span>);</span><br><span class="line">            bw.write(<span class="string">&quot;我爱你中国123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO流-打印流"><a href="#IO流-打印流" class="headerlink" title="IO流-打印流"></a>IO流-打印流</h1><h2 id="PrintStream-PrintWriter（打印流）"><a href="#PrintStream-PrintWriter（打印流）" class="headerlink" title="PrintStream&#x2F;PrintWriter（打印流）"></a>PrintStream&#x2F;PrintWriter（打印流）</h2><ul>
<li>作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去。</li>
<li>优势：能上都是使用方便，性能高效（核心优势）。</li>
</ul>
<h3 id="PrintStream构造器"><a href="#PrintStream构造器" class="headerlink" title="PrintStream构造器"></a>PrintStream构造器</h3><p>继承自字节输出流OutputStream，支持写字节。</p>
<ol>
<li>public PrintStream(OutputStream&#x2F;File&#x2F;String)。打印流直接通向字节输出流&#x2F;文件&#x2F;文件路径。</li>
<li>public PrintStream(String fileName, Charset charset)。可以指定写出去的字符编码。</li>
<li>public PrintStream(OutputStream out, boolean autoFlush)。可以指定实现自动刷新。</li>
<li>public PrintStream(OutputStream out, boolean autoFlush, String encoding)。可以指定实现自动刷新，并可指定字符的编码。</li>
</ol>
<h3 id="PrintStream常用方法"><a href="#PrintStream常用方法" class="headerlink" title="PrintStream常用方法"></a>PrintStream常用方法</h3><ol>
<li>public void println(Xxx xx)。打印任意类型的数据出去。</li>
<li>public void write(int&#x2F;byte[]&#x2F;byte[]一部分)。可以支持写字节数据出去。</li>
</ol>
<h3 id="PrintWriter构造器"><a href="#PrintWriter构造器" class="headerlink" title="PrintWriter构造器"></a>PrintWriter构造器</h3><p>继承自字符输出流Writer，支持写字符。</p>
<ol>
<li>public PrintWriter(OutputStream&#x2F;Writer&#x2F;File&#x2F;String)。打印流直接通向字节输出流&#x2F;文件&#x2F;文件路径。</li>
<li>public PrintWriter(String fileName, Charset charset)。可以指定写出去的字符编码。</li>
<li>public PrintWriter(OutputStream out&#x2F;Writer, boolean autoFlush)。可以指定实现自动刷新。</li>
<li>public PrintWriter(OutputStream out, boolean autoFlush, String encoding)。可以指定实现自动刷新，并可指定字符的编码。</li>
</ol>
<h3 id="PrintWriter常用方法"><a href="#PrintWriter常用方法" class="headerlink" title="PrintWriter常用方法"></a>PrintWriter常用方法</h3><ol>
<li>public void println(Xxx xx)。打印<strong>任意类型</strong>的数据出去。</li>
<li>public void write(int&#x2F;String&#x2F;char[]&#x2F;..)。可以支持写字符数据出去。</li>
</ol>
<h2 id="PrintStream和PrintWriter的区别"><a href="#PrintStream和PrintWriter的区别" class="headerlink" title="PrintStream和PrintWriter的区别"></a>PrintStream和PrintWriter的区别</h2><ul>
<li>打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势）。</li>
<li>PrintStream继承自字节输出流OutputStream，因此支持写字节数据的方法。</li>
<li>PrintWriter继承自字符输出流Writer，因此支持写字符数据出去。</li>
</ul>
<p>注意：高级流方法不能直接追加true来控制，需要先包装成低级流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new PrintWriterStream(new FileOutputStream(&quot;path&quot;,true))</span><br></pre></td></tr></table></figure>

<p>输出语句的重定向。</p>
<ul>
<li>打印流的一种应用。</li>
<li>可以把输出语句的打印位置改到某个文件中去。</li>
<li>System.out.println(“老骥伏枥”)这个语句的out实际上是帮我们创建了一个打印对象，然后默认打印到控制台上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老骥伏枥&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;志在千里&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io-app2/src/itheima09.txt&quot;</span>); )&#123;</span><br><span class="line">            <span class="comment">// 把系统默认的打印流对象改成自己设置的打印流</span></span><br><span class="line">            System.setOut(ps);<span class="comment">//定向到这里了</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;烈士暮年&quot;</span>);	</span><br><span class="line">            System.out.println(<span class="string">&quot;壮心不已&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO流-数据流"><a href="#IO流-数据流" class="headerlink" title="IO流-数据流"></a>IO流-数据流</h1><p>需求：把数据和数据的类型一并写到文件中去，读取的时候也将数据和数据类型一并读出来。有两个：DataInputStream和DataOutputStream。</p>
<h2 id="DataOutputStream类"><a href="#DataOutputStream类" class="headerlink" title="DataOutputStream类"></a>DataOutputStream类</h2><p>允许把数据和其类型一并写出去。</p>
<h3 id="构造器-4"><a href="#构造器-4" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public DataOutputStream(OutputStream out)。创建新数据输出流<strong>包装基础的字节输出流</strong>。</li>
</ol>
<h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>public final void writeByte(int v) throws IOException。将byte类型的数据写入基础的字节输出流。</li>
<li>public final void writeInt(int v) throws IOException。将int类型的数据写入基础的字节输出流。</li>
<li>public final void writeDouble(Double v) throws IOException。将double类型的数据写入基础的字节输出流。</li>
<li>public final void writeUTF(String str) throws IOException。将字符串数据以UTF-8编码成字节写入基础的字节输出流。</li>
<li>public void write(int&#x2F;byte[]&#x2F;byte[]一部分)。支持写字节数据出去。</li>
</ol>
<h2 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h2><p>用于<strong>读取</strong>数据输出流写出去的数据。 </p>
<h3 id="构造器-5"><a href="#构造器-5" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public DataInputStream(InputStream is)。创建新数据输入流<strong>包装基础的字节输入流</strong>。</li>
</ol>
<h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>Public final byte readByte() throws IOException。读取字节数据返回。</li>
<li>public final int readInt() throws IOException。读取int类型的数据返回。</li>
<li>public final double readDouble() throws IOException。读取double类型的数据返回。</li>
<li>public final String readUTF() throws IOException。读取字符串数（UTF-8）据返回。</li>
<li>public int readInt()&#x2F;read(byte[])。支持读字节数据进来。</li>
</ol>
<p>注意：二者需要搭配使用，存进去的是什么类型，读取就要怎么读，而且存进去的数据并不是为了读者直接来看的。（在通信中非常方便。）</p>
<h1 id="IO流-序列化流"><a href="#IO流-序列化流" class="headerlink" title="IO流-序列化流"></a>IO流-序列化流</h1><p>序列化</p>
<ul>
<li>对象序列化：把Java对象写入到文件中去。</li>
<li>对象反序列化：把文件里的Java对象读出来。</li>
</ul>
<h2 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h2><p>可以把Java对象进行序列化：把Java对象存入到文件中去。</p>
<h3 id="构造器-6"><a href="#构造器-6" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public ObjectOutputStream(OutputStream out)。创建对象字节输出流，<strong>包装基础的字节输出流</strong>。</li>
</ol>
<h3 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>public final void writeObject(Object o) throws IOException。把对象写出去。</li>
</ol>
<p>注意：<strong>对象如果要参与序列化，必须实现序列化接口（java.io.Serializable）！</strong>相当于一个标记，虽然接口里面什么都没有，但是虚拟机需要。</p>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p>可以把Java对象进行反序列化：把存储在文件中的Java对象读入到内存中来。</p>
<h3 id="构造器-7"><a href="#构造器-7" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>public ObjectInputStream(InputStream is)。创建对象字节输入流，<strong>包装基础的字节输入流</strong>。</li>
</ol>
<h3 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>public final Object readObject()。把存储在文件中的Java对象读出来。</li>
</ol>
<p>注意：如果成员变量中<strong>加transient修饰符</strong>，这个成员变量将不参与序列化。</p>
<p>如果要一次系列化多个对象，怎么做？</p>
<ul>
<li>用一个ArrayList集合存储多个对象，然后直接对集合进行序列化即可。</li>
<li>注意：ArrayList集合已经实现了序列化接口！</li>
</ul>
<h1 id="补充知识：-IO框架"><a href="#补充知识：-IO框架" class="headerlink" title="补充知识： IO框架"></a>补充知识： IO框架</h1><h2 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h2><ul>
<li>解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多框架都是第三方研发的。</li>
<li>好处：在框架的基础上开发，可以得到优秀的软件架构，并能提高开发效率</li>
<li>框架的形式：一般是把类、接口等<strong>编译成class形式</strong>，再<strong>压缩成一个.jar结尾的文件</strong>发行出去。</li>
</ul>
<h2 id="什么是IO框架"><a href="#什么是IO框架" class="headerlink" title="什么是IO框架"></a>什么是IO框架</h2><ul>
<li>封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式来对文件进行操作，对数据进行读写等。</li>
</ul>
<h2 id="Commons-io框架"><a href="#Commons-io框架" class="headerlink" title="Commons-io框架"></a>Commons-io框架</h2><p>Commons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。</p>
<h3 id="FileUtils类提供的部分方法展示"><a href="#FileUtils类提供的部分方法展示" class="headerlink" title="FileUtils类提供的部分方法展示"></a>FileUtils类提供的部分方法展示</h3><ol>
<li>public static void copyFile(File srcFile, File destFile)。复制文件。</li>
<li>public static void copyDirectory(File srcDir, File destDir)。复制文件夹。</li>
<li>public static void deleteDirectory(File directory)。删除文件夹。</li>
<li>public static String readFileToString(File file, String encoding)。读数据。</li>
<li>public static void writeStringToFile(File file, String data, String charname, boolean append)。写数据。</li>
</ol>
<h3 id="IOUtils类提供的部分方法展示"><a href="#IOUtils类提供的部分方法展示" class="headerlink" title="IOUtils类提供的部分方法展示"></a>IOUtils类提供的部分方法展示</h3><ol>
<li>public static int copy(InputStream inputStream, OutputStream outputStream)。复制文件。</li>
<li>public static int copy(Reader reader, Writer writer)。复制文件。</li>
<li>public static void write(String data, OutputStream output, String charsetName)。写数据。</li>
</ol>
<h2 id="使用指北"><a href="#使用指北" class="headerlink" title="使用指北"></a>使用指北</h2><ol>
<li>下载：<a target="_blank" rel="noopener" href="https://commons.apache.org/io/download_io.cgi">Commons IO – Download Apache Commons IO</a> Binary的zip包。</li>
<li>复制“commons-io-2.11.0.jar”包。</li>
<li>项目文件夹邮件，新建Directory，取名“lib”。粘贴。</li>
<li>右键lib文件夹，选择“Add as library”。</li>
<li>可以使用了。</li>
</ol>
<p>最后，其实Java原生自己从1.7也提供了File类的copy、readString等方法来做，但是功能上还没有第三方框架强大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.io%E3%80%91io%E6%B5%81/" data-id="cluthi17o0000mguhh0avgbbu" data-title="【Java基础】java.io包下的常用API-io流" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【Java基础】【java.util】集合（Map、Stream流）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/06/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.util%E3%80%91%E9%9B%86%E5%90%88%EF%BC%88Map%E3%80%81Stream%E6%B5%81%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-06T07:09:27.000Z" itemprop="datePublished">2024-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/06/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.util%E3%80%91%E9%9B%86%E5%90%88%EF%BC%88Map%E3%80%81Stream%E6%B5%81%EF%BC%89/">【Java基础】集合（Map、Stream流）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><p><strong>需要存储一一对应的数据时，就可以考虑使用Map集合来做。</strong></p>
<ul>
<li>Map集合称为<strong>双列集合</strong>，格式：{key1&#x3D;value1 , key2&#x3D;value2 , key3&#x3D;value3 , …}， <strong>一次需要存一对数据</strong>做为一个元素。</li>
<li>Map集合的每个元素“key&#x3D;value”称为一个键值对&#x2F;键值对对象&#x2F;Entry对象，Map集合也被叫做“<strong>键值对集合</strong>”。</li>
<li>Map集合的<strong>所有键是不允许重复的</strong>，但值可以重复，<strong>键和值是一一对应的</strong>，每一个键只能找到自己对应的值。</li>
</ul>
<h2 id="Map集合体系"><a href="#Map集合体系" class="headerlink" title="Map集合体系"></a>Map集合体系</h2><p>Map&lt;K,V&gt;是接口，下面有很多实现类：</p>
<ol>
<li>HashMap&lt;K , V&gt;。</li>
<li>LinkedHashMap&lt;K , V&gt;。（是1的子类。）</li>
<li>TreeMap&lt;K , V&gt;。</li>
</ol>
<p>特点：</p>
<ol>
<li>Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的。</li>
<li>HashMap（由<strong>键决定</strong>特点）: <strong>无序、不重复、无索引</strong>；  （用的最多）。</li>
<li>LinkedHashMap （由<strong>键决定</strong>特点）:由键决定的特点：有序、不重复、无索引。</li>
<li>TreeMap （由<strong>键决定</strong>特点）:<strong>按照（键的）大小默认升序</strong>排序、不重复、无索引。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典代码</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">//同样需要指定具体类。</span></span><br></pre></td></tr></table></figure>

<h2 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h2><ol>
<li>public V put(K key,V value)。添加元素。</li>
<li>public int size()。获取集合的大小。</li>
<li>public void clear()。清空集合。</li>
<li>public boolean isEmpty()。判断集合是否为空，为空返回true , 反之。</li>
<li>public V get(Object key)。<strong>根据键获取对应值</strong>。</li>
<li>public V remove(Object key)。根据键删除整个元素。</li>
<li>public  boolean containsKey(Object key)。判断是否包含某个键。（是精确匹配。）</li>
<li>public boolean containsValue(Object value)。判断是否包含某个值。（值的类型一定要注意。）</li>
<li>public Set<K> keySet()。获取全部键的集合。（会放到一个Set里面再返回。）</li>
<li>public Collection<V> values()。获取Map集合的全部值。（会放到一个Collection里面再返回，因为Set里面不允许有重复的值。）</li>
<li>putAll()。把其他Map集合的数据倒入到自己集合中来。</li>
</ol>
<h2 id="Map遍历方式"><a href="#Map遍历方式" class="headerlink" title="Map遍历方式"></a>Map遍历方式</h2><ol>
<li><strong>键找值</strong>。先获取Map集合全部的键，再通过遍历键来找值。</li>
<li><strong>键值对</strong>。把“键值对“看成一个整体进行遍历（难度较大）。</li>
<li><strong>Labmda</strong>。JDK 1.8开始之后的新技术（非常的简单）。</li>
</ol>
<h3 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h3><ol>
<li>public Set<K> keySet()。获取所有键的集合。</li>
<li>public V get(Object key)。根据键获取其对应的值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取Map集合的全部键</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="comment">// System.out.println(keys);</span></span><br><span class="line"><span class="comment">// [蜘蛛精, 牛魔王, 至尊宝, 紫霞]</span></span><br><span class="line"><span class="comment">//         key</span></span><br><span class="line"><span class="comment">// 2、遍历全部的键，根据键获取其对应的值</span></span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">    <span class="comment">// 根据键获取对应的值</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=====&gt;&quot;</span> + value);</span><br></pre></td></tr></table></figure>

<h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><p>使用增强for遍历时，元素类型无法确定。所以Java提供另一个方法：</p>
<ul>
<li>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()。获取所有“键值对”的集合。作为一个Set集合返回了，然后每个元素就是键值对类型，自然也就可以遍历了。</li>
</ul>
<p>Map.Entry提供的方法：</p>
<ol>
<li>K  getKey()。获取键。</li>
<li>V  getValue()。获取值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();	<span class="comment">//ctrl+alt+v</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : entries) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br></pre></td></tr></table></figure>

<h3 id="Labmda（简单，推荐）"><a href="#Labmda（简单，推荐）" class="headerlink" title="Labmda（简单，推荐）"></a>Labmda（简单，推荐）</h3><p>JDK 1.8开始。需要用到下面的方法：</p>
<ul>
<li>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)。结合lambda遍历Map集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历map集合，传递Lambda表达式</span></span><br><span class="line">map.forEach(( k,  v) -&gt; &#123;</span><br><span class="line">    System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//来看看原来的形式</span></span><br><span class="line"><span class="comment">//遍历map集合，传递匿名内部类（BiConsumer是一个接口）</span></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k, Double v)</span> &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//forEach内部其实是利用了第2种遍历方法（键值对）</span></span><br></pre></td></tr></table></figure>
<h2 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="(1)HashMap"></a>(1)HashMap</h2><p>HashMap（由<strong>键决定</strong>特点）: <strong>无序、不重复、无索引</strong>；  （用的最多）。</p>
<p>底层原理</p>
<ul>
<li>和HashSet的底层原理一样，基于哈希表实现。实际上：原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。</li>
<li>JDK8之前，哈希表 &#x3D; 数组+链表；JDK8开始，哈希表 &#x3D; 数组+链表+红黑树；哈希表是一种增删改查数据，性能都较好的数据结构。但是它是无序，不能重复，没有索引支持的（由键决定特点）。</li>
<li>HashMap的<strong>键依赖hashCode方法和equals方法保证键的唯一</strong>。</li>
<li>如果键存储的是自定义类型的对象，可以通过重写hashCode和equals方法，这样可以保证多个对象内容一样时，HashMap集合就能认为是重复的。</li>
</ul>
<h2 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="(2)LinkedHashMap"></a>(2)LinkedHashMap</h2><p>LinkedHashMap （由<strong>键决定</strong>特点）:由键决定的特点：有序、不重复、无索引。</p>
<p>底层原理</p>
<ul>
<li>底层数据结构依然是基于哈希表实现的，只是每个键值对元素又额外的多了一个双链表的机制记录元素顺序(保证有序)。实际上：原来学习的LinkedHashSet集合的底层原理就是LinkedHashMap。</li>
</ul>
<h2 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="(3)TreeMap"></a>(3)TreeMap</h2><p>TreeMap （由<strong>键决定</strong>特点）:<strong>按照（键的）大小默认升序</strong>排序、不重复、无索引。</p>
<p>底层原理</p>
<ul>
<li>特点：不重复、无索引、可排序(按照键的大小默认升序排序，只能对键排序)。</li>
<li>原理：TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。</li>
<li>TreeMap集合同样也支持两种方式来指定排序规则。<ul>
<li>让类实现Comparable接口，重写conpareTo()比较规则。</li>
<li>TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。</li>
</ul>
</li>
</ul>
<h2 id="补充知识：集合的嵌套"><a href="#补充知识：集合的嵌套" class="headerlink" title="补充知识：集合的嵌套"></a>补充知识：集合的嵌套</h2><p>集合中的元素又是一个集合。</p>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>JDK8开始最大的改变之一。（一共是两个：1.Lambda表达式，2.Stream流。）</p>
<h2 id="什么是Stream？"><a href="#什么是Stream？" class="headerlink" title="什么是Stream？"></a>什么是Stream？</h2><ul>
<li>也叫Stream流，是Jdk8开始新增的一套API (java.util.stream.*)，可以用于<strong>操作集合或者数组</strong>的数据。</li>
<li>优势： Stream流大量的<strong>结合了Lambda的语法风格</strong>来编程，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好。</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>有一个List集合，元素有<code>&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;</code>，找出姓张，且是3个字的名字，存入到一个新集合中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">System.out.println(names);</span><br></pre></td></tr></table></figure>

<p>传统方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出姓张，且是3个字的名字，存入到一个新集合中去。</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; name.length() == <span class="number">3</span>)&#123;</span><br><span class="line">        list.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>Stream流：（支持链式编程。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list2 = names.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(a -&gt; a.length()==<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<p>两次filter筛选，然后collect收集。</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>数据源。–&gt;获取其Stream流（理解为流水线，能与数据源建立联系）。</li>
<li>中间方法。调用流水线的各种方法对数据进行处理和计算。例如，过滤、排序、去重等。</li>
<li>获取结果。便利、统计、收集到一个新的集合中并返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要掌握下面四点：</span><br><span class="line">	<span class="number">1</span>、如何获取List集合的Stream流？</span><br><span class="line">	<span class="number">2</span>、如何获取Set集合的Stream流？</span><br><span class="line">	<span class="number">3</span>、如何获取Map集合的Stream流？</span><br><span class="line">	<span class="number">4</span>、如何获取数组的Stream流？</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><p>如何获取集合的Stream流？</p>
<ul>
<li>Collection类。default Stream<E> stream()。获取当前集合对象的Stream流。</li>
</ul>
<p>如何获取数组的Stream流？</p>
<ul>
<li>Arrays类。public static <T> Stream<T> stream(T[] array)。获取当前数组的Stream流。</li>
<li>Stream类。public static<T> Stream<T> of(T… values)。获取当前接收数据的Stream流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、如何获取List集合的Stream流？</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = names.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、如何获取Set集合的Stream流？</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(set, <span class="string">&quot;刘德华&quot;</span>,<span class="string">&quot;张曼玉&quot;</span>,<span class="string">&quot;蜘蛛精&quot;</span>,<span class="string">&quot;马德&quot;</span>,<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line">        stream1.filter(s -&gt; s.contains(<span class="string">&quot;德&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、如何获取Map集合的Stream流？</span></span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">172.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">166.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;卡尔扎巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; ks = keys.stream();</span><br><span class="line"></span><br><span class="line">        Collection&lt;Double&gt; values = map.values();</span><br><span class="line">        Stream&lt;Double&gt; vs = values.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream();</span><br><span class="line">        kvs.filter(e -&gt; e.getKey().contains(<span class="string">&quot;巴&quot;</span>))</span><br><span class="line">                .forEach(e -&gt; System.out.println(e.getKey()+ <span class="string">&quot;--&gt;&quot;</span> + e.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、如何获取数组的Stream流？</span></span><br><span class="line">        String[] names2 = &#123;<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;东方不败&quot;</span>, <span class="string">&quot;唐大山&quot;</span>, <span class="string">&quot;独孤求败&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; s1 = Arrays.stream(names2);</span><br><span class="line">        Stream&lt;String&gt; s2 = Stream.of(names2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h3><p>中间方法指的是调用完成后会返回新的Stream流，可以继续使用(支持链式编程)。（因此<strong>支持链式编程</strong>。）</p>
<p>常用方法</p>
<ol>
<li>Stream<T> filter(Predicate&lt;? super T&gt; predicate)。用于对流中的数据进行过滤。</li>
<li>Stream<T> sorted()。对元素进行升序排序。</li>
<li>Stream<T> sorted(Comparator&lt;? super T&gt; comparator)。对元素进行升序排序。</li>
<li>Stream<T> limit(long maxSize)。获取前几个元素。</li>
<li>Stream<T> skip(long n)。跳过前几个元素。</li>
<li>Stream<T> distinct()。去除流中重复的元素。</li>
<li><R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)。对元素进行加工，并返回对应的新流。</li>
<li>static <T> Stream<T> concat(Stream a, Stream b)。合并a和b两个流为一个流。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流提供的常见中间方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">88.5</span>, <span class="number">100.0</span>, <span class="number">60.0</span>, <span class="number">99.0</span>, <span class="number">9.5</span>, <span class="number">99.6</span>, <span class="number">25.0</span>);</span><br><span class="line">        <span class="comment">// 需求1：找出成绩大于等于60分的数据，并升序后，再输出。</span></span><br><span class="line">        scores.stream().filter(s -&gt; s &gt;= <span class="number">60</span>).sorted().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出.</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getAge() &gt;= <span class="number">23</span> &amp;&amp; s.getAge() &lt;= <span class="number">30</span>)</span><br><span class="line">            .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br><span class="line">            .forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：取出身高最高的前3名学生，并输出。</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">            .limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：取出身高倒数的2名学生，并输出。   s1 s2 s3 s4 s5 s6</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">            .skip(students.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).map(Student::getName)</span><br><span class="line">            .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals）</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>)</span><br><span class="line">            .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; st1 = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; st2 = Stream.of(<span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;李四2&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; allSt = Stream.concat(st1, st2); <span class="comment">//如果合并的两个类型不一样，需要用Object来接。</span></span><br><span class="line">        allSt.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p>终结方法指的是调用完成后，不会返回新Stream了，没法继续使用流了。</p>
<p>常用方法</p>
<ol>
<li>void forEach(Consumer action)。对此流运算后的元素执行遍历。</li>
<li>long count()。统计此流运算后的元素个数。</li>
<li>Optional<T> max(Comparator&lt;? super T&gt; comparator)。获取此流运算后的最大值元素。</li>
<li>Optional<T> min(Comparator&lt;? super T&gt; comparator)。获取此流运算后的最小值元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：Stream流的终结方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求1：请计算出身高超过168的学生有几人。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).count();</span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：请找出身高最高的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：请找出身高最矮的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">ss</span> <span class="operator">=</span> students.stream().min((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(ss);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。</span></span><br><span class="line">        <span class="comment">// 流只能收集一次。</span></span><br><span class="line">        List&lt;Student&gt; students1 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(students1);</span><br><span class="line"></span><br><span class="line">        Set&lt;Student&gt; students2 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(students2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。</span></span><br><span class="line">        Map&lt;String, Double&gt; map =</span><br><span class="line">                students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>)</span><br><span class="line">                        .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray();</span></span><br><span class="line">        Student[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).toArray(len -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>[len]);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法</p>
<ul>
<li>收集Stream流。就是把Stream流操作后的结果<strong>转回到集合或者数组</strong>中去返回。</li>
<li>Stream流：方便操作集合&#x2F;数组的手段；   集合&#x2F;数组：才是开发中的目的。</li>
</ul>
<ol>
<li>R collect(Collector collector)。把流处理后的结果<strong>收集到一个指定的集合</strong>中去。</li>
<li>Object[] toArray()。把流处理后的结果<strong>收集到一个数组</strong>中去。</li>
</ol>
<p>collect具体的收集方式</p>
<ol>
<li>public static <T> Collector toList()。把元素收集到List集合中。</li>
<li>public static <T> Collector toSet()。把元素收集到Set集合中。注意<strong>Set会去重</strong>。</li>
<li>public static  Collector toMap(Function keyMapper , Function valueMapper)。把元素收集到Map集合中。注意需要在收集的时候<strong>指定键和值</strong>。而且它不能帮我们去重，因此可能报错，要自己在中间加一个distict()方法。</li>
</ol>
<p>注意，<strong>流只能收集一次</strong>！不可以先用一个Steam对象接住Steam流，然后做两次收集操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/06/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.util%E3%80%91%E9%9B%86%E5%90%88%EF%BC%88Map%E3%80%81Stream%E6%B5%81%EF%BC%89/" data-id="cluo501ti00031cuhgion1pxs" data-title="【Java基础】集合（Map、Stream流）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【资源帖】学习Java和算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/06/%E3%80%90%E8%B5%84%E6%BA%90%E5%B8%96%E3%80%91%E5%AD%A6%E4%B9%A0Java%E5%92%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-04-06T03:13:33.000Z" itemprop="datePublished">2024-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/06/%E3%80%90%E8%B5%84%E6%BA%90%E5%B8%96%E3%80%91%E5%AD%A6%E4%B9%A0Java%E5%92%8C%E7%AE%97%E6%B3%95/">【资源帖】学习Java和算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java教程"><a href="#Java教程" class="headerlink" title="Java教程"></a>Java教程</h1><h2 id="学习路线【黑马程序员】"><a href="#学习路线【黑马程序员】" class="headerlink" title="学习路线【黑马程序员】"></a>学习路线【黑马程序员】</h2><ol>
<li>Java简版基础教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cv411372m/">https://www.bilibili.com/video/BV1Cv411372m/</a><ul>
<li>书：《Java核心技术 1》</li>
<li>书：《Head First Java》</li>
</ul>
</li>
<li>Java Web框架：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb/">https://www.bilibili.com/video/BV1m84y1w7Tb/</a></li>
<li>单体项目开发：<ul>
<li>苍穹外卖：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TP411v7v6/">https://www.bilibili.com/video/BV1TP411v7v6/</a></li>
</ul>
</li>
<li>微服务：<ul>
<li>MybatisPlus：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Xu411A7tL/">https://www.bilibili.com/video/BV1Xu411A7tL/</a></li>
<li>全套微服务技术栈：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LQ4y127n4/">https://www.bilibili.com/video/BV1LQ4y127n4/</a></li>
</ul>
</li>
<li>企业级项目实战（选择学习）：<ul>
<li>学成在线【在线教育】：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1j8411N7Bm/">https://www.bilibili.com/video/BV1j8411N7Bm/</a></li>
<li>黑马头条【企业级微服务项目】 ：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qs4y1v7x4/">https://www.bilibili.com/video/BV1Qs4y1v7x4/</a></li>
</ul>
</li>
<li>面试专题：<ul>
<li>2023版：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yT411H7YK">https://www.bilibili.com/video/BV1yT411H7YK</a></li>
<li>2021版：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15b4y117RJ">https://www.bilibili.com/video/BV15b4y117RJ</a></li>
</ul>
</li>
</ol>
<h2 id="资源帖"><a href="#资源帖" class="headerlink" title="资源帖"></a>资源帖</h2><p>JavaGuide：<a target="_blank" rel="noopener" href="https://javaguide.cn/home.html">JavaGuide（Java学习&amp;面试指南） | JavaGuide</a></p>
<p>JavaBooks：<a target="_blank" rel="noopener" href="https://gitee.com/itwanger/JavaBooks">https://gitee.com/itwanger/JavaBooks</a></p>
<h1 id="LeeCode刷题指南"><a href="#LeeCode刷题指南" class="headerlink" title="LeeCode刷题指南"></a>LeeCode刷题指南</h1><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/">力扣 (LeetCode) 全球极客挚爱的技术成长平台</a></p>
<h2 id="刷题指北"><a href="#刷题指北" class="headerlink" title="刷题指北"></a>刷题指北</h2><p>peach买个共享会员账号看考察频次。</p>
<h2 id="资源帖-1"><a href="#资源帖-1" class="headerlink" title="资源帖"></a>资源帖</h2><p>labuladong：<a target="_blank" rel="noopener" href="https://labuladong.online/algo/home/">本站简介 | labuladong 的算法笔记</a></p>
<p>代码随想录：<a target="_blank" rel="noopener" href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/06/%E3%80%90%E8%B5%84%E6%BA%90%E5%B8%96%E3%80%91%E5%AD%A6%E4%B9%A0Java%E5%92%8C%E7%AE%97%E6%B3%95/" data-id="clunjsaz1000030uh14smflz1" data-title="【资源帖】学习Java和算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【伴行青年】如何写一份受欢迎的校招简历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/05/%E3%80%90%E4%BC%B4%E8%A1%8C%E9%9D%92%E5%B9%B4%E3%80%91%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E6%A0%A1%E6%8B%9B%E7%AE%80%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2024-04-05T12:03:34.000Z" itemprop="datePublished">2024-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/05/%E3%80%90%E4%BC%B4%E8%A1%8C%E9%9D%92%E5%B9%B4%E3%80%91%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E6%A0%A1%E6%8B%9B%E7%AE%80%E5%8E%86/">【伴行青年】如何写一份受欢迎的校招简历</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol>
<li>过度包装设计。减弱主要信息能量，华而不实。</li>
<li>篇幅过长。</li>
<li>求职定位不明。</li>
<li>实践经历描述不当。</li>
<li>一份简历闯天下。<ul>
<li>JD：工作职责、工作胜任力。</li>
</ul>
</li>
<li>使用表格式简历。</li>
<li>啰啰嗦嗦重点不突出。</li>
<li>不该讲的乱讲。例如，创业、离职原因、到岗时间、离婚、错误检讨、薪资条件。</li>
</ol>
<h1 id="优秀简历的特征"><a href="#优秀简历的特征" class="headerlink" title="优秀简历的特征"></a>优秀简历的特征</h1><h2 id="版面设计"><a href="#版面设计" class="headerlink" title="版面设计"></a>版面设计</h2><p>简洁大方、布局清晰、模板分界。</p>
<h2 id="简历结构"><a href="#简历结构" class="headerlink" title="简历结构"></a>简历结构</h2><p>结构完整、详略得当、易于阅读。</p>
<h2 id="内容呈现"><a href="#内容呈现" class="headerlink" title="内容呈现"></a>内容呈现</h2><p>逻辑清晰、优势突出、数据支撑。</p>
<h2 id="人岗匹配"><a href="#人岗匹配" class="headerlink" title="人岗匹配"></a>人岗匹配</h2><p>有的放矢、贴近岗位JD、天生我才。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ol>
<li>脱颖而出、入得法眼。</li>
<li>顺畅读完，越读越喜欢。</li>
<li>打动人心，不如见一面。</li>
<li>为面试好印象做好铺垫。（面试官其实是根据初印象，步步求证是否确实是需要的人。）</li>
</ol>
<h1 id="简历的完整结构“2-2”"><a href="#简历的完整结构“2-2”" class="headerlink" title="简历的完整结构“2+2”"></a>简历的完整结构“2+2”</h1><p>通用的（非本专业&#x2F;技术岗）：</p>
<ol>
<li>基本信息：略写。7%。</li>
<li>自我评价：较详。20%。</li>
<li>工作经历：详写。（大力气。）70%。</li>
<li>学历、证书、技能：略写。3%。</li>
</ol>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul>
<li>姓名+求职意向+性别+年龄。（政治面貌：国企央企等写，外企不写，民企无所谓。）</li>
<li>联系方式：城市、电话、微信、邮箱。（不用写太多。城市可以写XX(意向城市)。联系方式三个必有一，推荐电话。）</li>
<li>个人照片：彩色、正面头像、有精气神。（匹配行业。）</li>
</ul>
<h2 id="自我评价-教育背景"><a href="#自我评价-教育背景" class="headerlink" title="自我评价&#x2F;教育背景"></a>自我评价&#x2F;教育背景</h2><p>社招：</p>
<ul>
<li>工作背景。例如，年份+领域&#x2F;行业+擅长&#x2F;熟悉&#x2F;掌握。</li>
<li>优势能力。四条分号隔开。专业软件可以写。</li>
<li>职业素养。</li>
</ul>
<p><strong>校招：</strong></p>
<ul>
<li>起止时段：学校、专业、学历、学位。</li>
<li>主修课程。</li>
<li>奖学金可以写。</li>
</ul>
<h2 id="工作经历-实习经历-项目经历"><a href="#工作经历-实习经历-项目经历" class="headerlink" title="工作经历&#x2F;实习经历&#x2F;项目经历"></a>工作经历&#x2F;实习经历&#x2F;项目经历</h2><p>社招：</p>
<ul>
<li>工作时段。（可以有总分，总的在某个公司，分的是不同岗位。最好是倒叙。）</li>
<li>工作职责。（前3-5个。）</li>
<li>工作业绩。（为了醒目，可以换个标志，比如五角星。一定要有数据，没数据也不要乱讲。）</li>
<li>工作获奖。（要有含金量的，行业、省市级以上，发明专利等。）</li>
</ul>
<p><strong>校招：</strong></p>
<ul>
<li>起止时段、公司、岗位。</li>
<li>工作职责、价值、奖项。</li>
</ul>
<h2 id="其他佐证"><a href="#其他佐证" class="headerlink" title="其他佐证"></a>其他佐证</h2><ul>
<li>学历背景：学校、专业。</li>
<li>语言能力：语种、级别。（只是针对某些需要语言能力的岗位。其他：听说读写能力流利，可作为工作语言。）</li>
<li>专业技能：证书、级别。（例如岗位资格证。）</li>
</ul>
<h2 id="校招和社招的区别"><a href="#校招和社招的区别" class="headerlink" title="校招和社招的区别"></a>校招和社招的区别</h2><ul>
<li>教育背景前置&#x2F;后置。</li>
<li>自我评价的有无。（复盘能力。）</li>
</ul>
<h1 id="优秀简历写作心法"><a href="#优秀简历写作心法" class="headerlink" title="优秀简历写作心法"></a>优秀简历写作心法</h1><p><strong>人岗匹配！！！</strong></p>
<ol>
<li>职场的本质是价值交换。（以终为始。）</li>
<li>见字如面，格式细节很重要，大小标题和逻辑关系。</li>
<li>凤头猪肚豹尾。自我评价漂亮客观，工作经历饱满有结果，其他佐证简短有力。</li>
<li>工作经历倒叙。写清楚总分，闭环表达，数据支撑。</li>
<li>工作<strong>年限5年以下，请用一张A4纸</strong>完成。</li>
<li>如果<strong>经历比较少，根据一段经历可以多挖掘</strong>，例如，“1+3+6+x”主轴。</li>
</ol>
<h1 id="如何准备"><a href="#如何准备" class="headerlink" title="如何准备"></a>如何准备</h1><ol>
<li>确定自己身份：校招&#x2F;社招，确定目标岗位，了解岗位JD。</li>
<li>准备模板，通读三遍。准备素材，多多益善。（所有经历都可以准备。）</li>
<li>现有骨架，再填充。时间倒叙，先粗后细。</li>
<li>先写草稿，反复打磨。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/05/%E3%80%90%E4%BC%B4%E8%A1%8C%E9%9D%92%E5%B9%B4%E3%80%91%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E6%A0%A1%E6%8B%9B%E7%AE%80%E5%8E%86/" data-id="clumoru9q00018guh4mi0e9el" data-title="【伴行青年】如何写一份受欢迎的校招简历" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-【Java基础】【java.util】集合（Collection、List、Set）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/05/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.util%E3%80%91%E9%9B%86%E5%90%88%EF%BC%88Collection%E3%80%81List%E3%80%81Set%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-04-05T07:59:05.000Z" itemprop="datePublished">2024-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/05/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.util%E3%80%91%E9%9B%86%E5%90%88%EF%BC%88Collection%E3%80%81List%E3%80%81Set%EF%BC%89/">【Java基础】集合（Collection、List、Set）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="集合分类"><a href="#集合分类" class="headerlink" title="集合分类"></a>集合分类</h1><ol>
<li>单列集合（Collection）。元素是一个一个的。</li>
<li>双列集合（Map）。元素是一对一的。</li>
</ol>
<h1 id="单列集合（Collection）"><a href="#单列集合（Collection）" class="headerlink" title="单列集合（Collection）"></a>单列集合（Collection）</h1><h2 id="Collection集合体系"><a href="#Collection集合体系" class="headerlink" title="Collection集合体系"></a>Collection<E>集合体系</h2><ol>
<li>子接口List<E>。<ol>
<li>实现类ArrayList<E>。</li>
<li>实现类LinkedList<E>。</li>
</ol>
</li>
<li>子接口Set。<ol>
<li>实现类HashSet<E>。<ol>
<li>LinkedHashSet<E>。</li>
</ol>
</li>
<li>实现类TreeSet<E>。</li>
</ol>
</li>
</ol>
<p>学习时要掌握的：</p>
<ol>
<li>有什么特点？</li>
<li>是否有特有功能？</li>
<li>适合什么业务场景？</li>
</ol>
<h2 id="Collection集合特点"><a href="#Collection集合特点" class="headerlink" title="Collection集合特点"></a>Collection集合特点</h2><h3 id="List系列"><a href="#List系列" class="headerlink" title="List系列"></a>List系列</h3><p>添加的元素<strong>有</strong>序、<strong>可</strong>重复、<strong>有</strong>索引。</p>
<ol>
<li>ArrayList、LinkedList有序、可重复、有索引。</li>
</ol>
<h3 id="Set系列"><a href="#Set系列" class="headerlink" title="Set系列"></a>Set系列</h3><p>添加的元素<strong>无</strong>序、<strong>不</strong>重复、<strong>无</strong>索引。</p>
<ol>
<li>HashSet。无序、不重复、无索引。</li>
<li>LinkedHashSet。<strong>有</strong>序、不重复、无索引。</li>
<li>TreeSet。<strong>按照大小默认升序排序</strong>、不重复、无索引。</li>
</ol>
<h2 id="Collection常用方法"><a href="#Collection常用方法" class="headerlink" title="Collection常用方法"></a>Collection常用方法</h2><p>为什么要学？</p>
<ul>
<li>因为Collection是单列集合的祖宗，它规定的方法（功能）是全部单列集合都会继承的。</li>
</ul>
<p>常用方法：</p>
<ol>
<li>public boolean add(E e)。把给定的对象添加到当前集合中 。由于允许数据重复，所以一定返回true。</li>
<li>public void clear() 。清空集合中所有的元素。</li>
<li>public boolean remove(E e)。把给定的对象在当前集合中删除。如果有多个<strong>重复</strong>元素只能<strong>删除第一个</strong>。</li>
<li>public boolean contains(Object obj)。判断当前集合中是否包含给定的对象。是精确匹配。</li>
<li>public boolean isEmpty()。判断当前集合是否为空。</li>
<li>public int size()。返回集合中元素的个数。</li>
<li>public Object[] toArray()。把集合中的元素，存储到数组中。Object类型是为了兼容各种类型的数据。</li>
<li>addAll(Collection&lt;? extends String&gt; c)。<code>把另一个集合中的全部数据倒入</code>，数据类型要一样。</li>
</ol>
<h2 id="Collection遍历方式"><a href="#Collection遍历方式" class="headerlink" title="Collection遍历方式"></a>Collection遍历方式</h2><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1. 迭代器"></a>1. 迭代器</h3><p>迭代器是用来遍历集合的专用方式(数组没有迭代器)，在Java中迭代器的代表是Iterator。</p>
<p>Collection集合获取迭代器的方法：</p>
<ul>
<li>**Iterator<E> iterator()**。返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素。<ol>
<li>从集合对象中获取迭代器对象。</li>
<li>判断当前位置是否有元素可以获取。不判断的话可能出现NoSuchElementException异常。</li>
<li>获取当前位置的元素，然后自动指向下一个元素。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line">System.out.println(c); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125; <span class="comment">//判断一次，取一次</span></span><br></pre></td></tr></table></figure>

<p>Iterator迭代器中的常用方法：</p>
<ul>
<li>boolean hasNext()。询问当前位置是否有元素存在，存在返回true ,不存在返回false。</li>
<li>E next()。获取当前位置的元素，并同时将迭代器对象指向下一个元素处。</li>
</ul>
<h3 id="2-增强for"><a href="#2-增强for" class="headerlink" title="2. 增强for"></a>2. 增强for</h3><p>为什么用增强的？因为Collection中没有规定集合的索引，只有List集合才支持索引。</p>
<ul>
<li>格式：for (元素的数据类型 <strong>变量名</strong> : 数组或者集合) { }。变量名相当于游标。（类似于Python中的for img in imgs这种写法。）</li>
<li>可以遍历集合或者数组。</li>
<li>遍历集合本质是迭代器遍历集合的简化写法。</li>
<li>简化写法：数组或集合**.for再回车**。</li>
</ul>
<h3 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3. lambda表达式"></a>3. lambda表达式</h3><p>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的方式来遍历集合。</p>
<p>方法：default void forEach(Consumer&lt;? super T&gt; action) 。结合lambda遍历集合。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用forEach方法</span></span><br><span class="line"><span class="comment">//由于参数是一个Consumer接口，所以可以传递匿名内部类</span></span><br><span class="line">c.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用lambda表达式对匿名内部类进行简化</span></span><br><span class="line">c.forEach((String s) -&gt;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">c.forEach(s -&gt;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">c.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">c.forEach(System.out::println); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br></pre></td></tr></table></figure>

<p>lambda表达式遍历Collection集合不算简洁，之后遍历Map才是简洁。</p>
<h1 id="一-List集合"><a href="#一-List集合" class="headerlink" title="(一)List集合"></a>(一)List集合</h1><p>ArrayList、LinkedList有序、可重复、有索引。但是<strong>底层数据结构不同</strong>（数据结构：存储、组织数据的方式），<strong>应用场景也不同</strong>。继承了Collection的功能。</p>
<p>创建（List是接口，所以需要指定具体的类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//经典代码，多态</span></span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>List集合因为支持索引，所以多了很多索引相关的方法：</p>
<ol>
<li>void add(int index,E element)。在此集合中的指定位置插入指定的元素。不写索引的话，默认是插入到最后。</li>
<li>E remove(int index)。删除指定索引处的元素，<strong>返回被删除的元素</strong>。</li>
<li>E set(int index,E element)。修改指定索引处的元素，<strong>返回被修改的元素</strong>。</li>
<li>E get(int index)。返回指定索引处的元素。</li>
</ol>
<h2 id="List集合支持的遍历方式"><a href="#List集合支持的遍历方式" class="headerlink" title="List集合支持的遍历方式"></a>List集合支持的遍历方式</h2><ol>
<li>普通for循环（只因为List有索引）。集合名.for<strong>i</strong>自动完成。</li>
<li>增强for&#x2F;foreach遍历。集合名.for自动完成。</li>
<li>迭代器。先创建迭代器，再判断并遍历。</li>
<li>Lambda表达式。forEach方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;蜘蛛精&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;至尊宝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;糖宝宝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; list.size(); i++)&#123;</span><br><span class="line">    <span class="comment">//i = 0, 1, 2</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.增强for遍历</span></span><br><span class="line"><span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.lambda表达式遍历</span></span><br><span class="line">list.forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure>

<h2 id="1-ArrayList集合的底层原理"><a href="#1-ArrayList集合的底层原理" class="headerlink" title="(1)ArrayList集合的底层原理"></a>(1)ArrayList集合的底层原理</h2><p>基于<strong>数组</strong>实现的。</p>
<p>特点（查询快、增删慢）：</p>
<ol>
<li>查询速度快（根据索引查询数据快）。查询数据通过地址值和索引定位，查询任意数据耗时相同。</li>
<li>删除效率低。可能需要把后面很多的数据进行前移。</li>
<li>添加效率极低。可能需要把后面很多的数据后移，再添加元素；或者也可能需要进行数组的扩容。</li>
</ol>
<p>底层原理：</p>
<ol>
<li>利用无参构造器创建的集合，会在底层创建一个默认查高难度为0的数组。</li>
<li>添加第一个元素时，底层会创建一个新的长度为10的数组。</li>
<li>存满时（添加第11个元素时），扩容1.5倍。</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>适合：根据索引查询数据，比如根据随机索引取数据（高效），或者数据量不是很大时。</li>
<li>不适合：数据量大的同时，又要频繁地进行增删操作。</li>
</ol>
<h2 id="2-LinkedList集合的底层原理"><a href="#2-LinkedList集合的底层原理" class="headerlink" title="(2)LinkedList集合的底层原理"></a>(2)LinkedList集合的底层原理</h2><p>基于<strong>双链表</strong>实现的（Java中大多数情况都使用双向链表）。</p>
<p>什么是链表？</p>
<ul>
<li>链表结构是由一个一个的节点组成，一个节点由数据值、下一个元素的地址组成。</li>
<li>链表中的结点是独立的对象，在内存中是不连续的，每个节点包含数据值和下一个节点的地址。</li>
<li>特点1：查询慢，无论查询哪个数据都要从头开始。</li>
<li>特点2：增删相对较快。但是对于首尾元素进行增删改查的速度是极快的。</li>
</ul>
<p>LinkedList<strong>新增</strong>了一些可以<strong>针对头尾</strong>进行操作的方法：</p>
<ol>
<li>public void addFirst(E e)。在该列表开头插入指定的元素。</li>
<li>public void addLast(E e)。将指定的元素追加到此列表的末尾。</li>
<li>public E getFirst()。返回此列表中的第一个元素。</li>
<li>public E getLast()。返回此列表中的最后一个元素。</li>
<li>public E removeFirst()。从此列表中删除并返回第一个元素。</li>
<li>public E removeLast()。从此列表中删除并返回最后一个元素。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>设计队列（特点：先进先出，后进后出）。队列只是在首尾增删元素。<ol>
<li>入队。addLast方法。</li>
<li>出队。removeFirst方法。</li>
</ol>
</li>
<li>设计栈（特点：先进后出，后进先出）。<ol>
<li>进栈（压栈）。push方法（其实就是调用的addFirst方法）。</li>
<li>出站（弹栈）。pop方法（其实就是调用的removeFirst方法）。</li>
</ol>
</li>
</ol>
<h1 id="二-Set集合"><a href="#二-Set集合" class="headerlink" title="(二)Set集合"></a>(二)Set集合</h1><p>添加的元素<strong>无</strong>序、<strong>不</strong>重复、<strong>无</strong>索引。</p>
<ol>
<li>HashSet。无序、不重复、无索引。</li>
<li>LinkedHashSet。<strong>有</strong>序、不重复、无索引。（是HashSet的子孙类。）</li>
<li>TreeSet。<strong>按照大小默认升序排序</strong>、不重复、无索引。</li>
</ol>
<p>创建（Set是接口，所以需要指定具体的类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一行经典代码</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();	<span class="comment">//无序、无索引、不重复（无序是指和添加元素的顺序无关）</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(); <span class="comment">//有序、无索引、不重复（有序是指和添加元素的顺序有关）</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">//可排序(升序)、无索引、不重复</span></span><br></pre></td></tr></table></figure>

<h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><p>要用的常用方法，基本上都是其父类Collection提供的。</p>
<h2 id="1-HashSet集合"><a href="#1-HashSet集合" class="headerlink" title="(1)HashSet集合"></a>(1)HashSet集合</h2><p>需要掌握的：</p>
<ol>
<li>为什么添加的元素无序、不重复、无索引？</li>
<li>增删改查数据有什么特点，适合什么场景？</li>
</ol>
<p>哈希值：</p>
<ul>
<li>一个int类型的数值，Java中每个对象都有一个哈希值。</li>
<li>Java中的所有对象，都可以调用Object类提供的hashCode方法，返回该对象自己的哈希值。</li>
</ul>
<p>对象哈希值的特点：</p>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的。</li>
<li>不同的对象，哈希值一般不同，但也有可能相同（哈希碰撞）。</li>
</ul>
<h2 id="HashSet集合的底层原理"><a href="#HashSet集合的底层原理" class="headerlink" title="HashSet集合的底层原理"></a>HashSet集合的底层原理</h2><ul>
<li>基于哈希表实现。</li>
<li>是一种增删改查性能都较好的数据结构。</li>
<li>JDK8以前：哈希表 &#x3D; 数组+链表</li>
<li>JDK8以后：哈希表 &#x3D; 数组+链表+<strong>红黑树</strong></li>
</ul>
<p>JDK8以前HashSet集合的底层原理：</p>
<ol>
<li>创建一个默认长度为16的数组，默认加载因子为0.75，数组名table；</li>
<li>使用元素的哈希值对数组的长度求余计算出应存入的位置；</li>
<li>判断当前位置是否为null，如果是null直接存入；</li>
<li>如果不为null，表示有元素，则调用equals方法比较相等，则不存；不相等，则存入数据。<ul>
<li>JDK8以前，新元素存入数组，占用老元素的位置，老元素挂下面；</li>
<li>JDK8以后，新元素挂在老元素下面。</li>
</ul>
</li>
</ol>
<p>往HashSet集合中存储元素时，底层调用了元素的两个方法：一个是hashCode方法<strong>获取元素的hashCode值</strong>（哈希值）；另一个是调用了<strong>元素的equals方法</strong>，用来比较新添加的元素和集合中已有的元素是否相同。 </p>
<ul>
<li>只有新添加元素的hashCode值和集合中以后元素的hashCode值相同、新添加的元素调用equals方法和集合中已有元素比较结果为true, 才认为元素重复。</li>
<li>如果hashCode值相同，equals比较不同，则以链表的形式连接在数组的同一个索引为位置。–&gt;导致的问题：如果数组快占满了，链表过长，导致查询性能降低。–&gt;哈希表的扩容机制（占满加载因子0.75*长度就会扩容，扩容成原来数组的两倍）。</li>
</ul>
<p>在JDK8以后的优化：</p>
<ul>
<li>当链表的长度超过8，且数组长度超过64时，就会自动把链表转换为红黑树。</li>
</ul>
<blockquote>
<!--补充二叉树：-->

<!--每个结点包含的内容：父节点地址、值、左子结点地址、右子结点地址。-->

<!--度：每个结点的子结点数量。在二叉树中，任意节点的度<=2。-->

<!--树高：树的总层数。-->

<!--根结点：最顶层的结点。-->

<!--左子结点。-->

<!--右子结点。-->

<!--左子树。-->

<!--右子树。-->

<!--在应用中用得比较多的是二叉查找树（排序树）。-->

<!--（1）规则：小的存左边，大的存右边，一样的不存。-->

<!--（2）问题：当数据已经是排好序的，导致查询性能和单链表一样，查询速度变慢。-->

<!--平衡二叉树。-->

<!--（1）在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。（一般左子树和右子树的深度之差不超过1。）-->

<!--红黑树。-->

<!--（1）**自平衡**的二叉树。-->

<!--（2）一种增删改查数据性能相对都较好的结构。-->
</blockquote>
<h2 id="深入理解HashSet集合去重的机制"><a href="#深入理解HashSet集合去重的机制" class="headerlink" title="深入理解HashSet集合去重的机制"></a>深入理解HashSet集合去重的机制</h2><p>注意：HashSet集合默认不能对内容一样的两个不同对象去重复！（因为不同对象哈希值不一样，因此存储位置不同，就会被认为不是重复的。）</p>
<p>如何让HashSet集合能够实现对内容一样的两个不同对象也能去重复？？？</p>
<ul>
<li>如果希望Set集合认为2个内容一样的对象是重复的，<br>必须重写对象的hashCode()和equals()方法。</li>
<li>在类中**右键-generate-euqals() and hashCode()**，一路next。这里euqals方法只要两个对象内容一样就返回true，hashCode方法只要两个对象内容一样，返回的哈希值就是一样的。</li>
</ul>
<h2 id="2-LinkedHashSet集合"><a href="#2-LinkedHashSet集合" class="headerlink" title="(2)LinkedHashSet集合"></a>(2)LinkedHashSet集合</h2><ul>
<li><strong>有序</strong>、不重复、无索引。</li>
<li>基于哈希表（数组+链表+<strong>红黑树</strong>）实现的。</li>
<li>每个元素都额外的多了一个<strong>双链表的机制</strong>记录它前后元素的位置。增删改查比较快，但是也更占内存。</li>
</ul>
<h2 id="3-TreeSet集合"><a href="#3-TreeSet集合" class="headerlink" title="(3)TreeSet集合"></a>(3)TreeSet集合</h2><ul>
<li><strong>排序</strong>、不重复、无索引。</li>
<li>基于<strong>红黑树</strong>实现的排序。增删改查性能较好。</li>
<li>对于数值类型：Integer , Double，默认按照数值本身的大小进行升序排序。</li>
<li>对于字符串类型：默认按照首字符的编号升序排序。</li>
<li>对于<strong>自定义类型如Student对象，TreeSet默认是无法直接排</strong>序的。</li>
</ul>
<p>自定义排序规则</p>
<ul>
<li>TreeSet集合存储自定义类型的对象时，必须指定排序规则，支持如下两种方式来指定比较规则。</li>
</ul>
<p><strong>排序方式1：</strong>让自定义的类（如学生类）<strong>实现Comparable接口</strong>，重写里面的<strong>compareTo方法</strong>来指定比较规则。但是要注意，如果值相等，就认为是重复的，只会保存一个对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：先让Student类，实现Comparable接口</span></span><br><span class="line"><span class="comment">//注意：Student类的对象是作为TreeSet集合的元素的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">	<span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        <span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步：重写compareTo方法</span></span><br><span class="line">    <span class="comment">//按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原理：</span></span><br><span class="line"><span class="comment">    在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的</span></span><br><span class="line"><span class="comment">    结果是正数、负数、还是零，决定元素放在后面、前面还是不存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">//this：表示将要添加进去的Student对象</span></span><br><span class="line">        <span class="comment">//o: 表示集合中已有的Student对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>排序方式2：</strong>通过调用<strong>TreeSet集合有参数构造器</strong>，可以设置Comparator对象（比较器对象，用于指定比较规则）。TreeSet自动选择自己自带的比较器对象进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建TreeSet集合时，传递比较器对象排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原理：当调用add方法时，底层会先用比较器，根据Comparator的compare方是正数、负数、还是零，决定谁在后，谁在前，谁不存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//下面代码中是按照学生的年龄升序排序</span></span><br><span class="line">Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="comment">//需求：按照学生的身高排序</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1,o2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用lambda表达式简化</span></span><br><span class="line"><span class="comment">//Set&lt;Student&gt; students = new TreeSet&lt;&gt;(o1,o2)-&gt;Double.compare(o1.getHeight(), o2.getHeight()));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建4个Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">23</span>, <span class="number">169.8</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Studnet对象到集合</span></span><br><span class="line">students.add(s1);</span><br><span class="line">students.add(s2);</span><br><span class="line">students.add(s3);</span><br><span class="line">students.add(s4);</span><br><span class="line">System.out.println(students); </span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>如果希望记住元素的添加顺序，需要存储重复的元素，又要<strong>频繁的根据索引查询数据</strong>？<ul>
<li>用<strong>ArrayList</strong>集合（有序、可重复、有索引），底层基于数组的。（常用）</li>
</ul>
</li>
<li>如果希望记住元素的<strong>添加顺序</strong>，且<strong>增删首尾数据</strong>的情况较多？<ul>
<li>用<strong>LinkedList</strong>集合（有序、可重复、有索引），底层基于双链表实现的。</li>
</ul>
</li>
<li>如果<strong>不在意元素顺序</strong>，也<strong>没有重复元素</strong>需要存储，只希望<strong>增删改查都快</strong>？<ul>
<li>用<strong>HashSet</strong>集合（无序，不重复，无索引），底层基于哈希表实现的。 （常用）</li>
</ul>
</li>
<li>如果希望记住元素的<strong>添加顺序</strong>，也<strong>没有重复元素</strong>需要存储，且希望增删改查都快？<ul>
<li>用<strong>LinkedHashSet</strong>集合（有序，不重复，无索引）， 底层基于哈希表和双链表。</li>
</ul>
</li>
<li>如果要对元素进行<strong>排序</strong>，也<strong>没有重复元素需要存储</strong>？且希望<strong>增删改查都快</strong>？<ul>
<li>用<strong>TreeSet</strong>集合，基于红黑树实现。</li>
</ul>
</li>
</ol>
<h1 id="注意事项：集合的并发修改异常问题"><a href="#注意事项：集合的并发修改异常问题" class="headerlink" title="注意事项：集合的并发修改异常问题"></a>注意事项：集合的并发修改异常问题</h1><h2 id="集合的并发修改异常"><a href="#集合的并发修改异常" class="headerlink" title="集合的并发修改异常"></a>集合的并发修改异常</h2><p>并发：多件事正在进行。</p>
<ul>
<li>使用<strong>迭代器遍历集合时</strong>，又<strong>同时在删除</strong>集合中的数据，程序就会出现<strong>并发修改异常</strong>的错误。<ul>
<li>原因：其实和之前用for循环的时候差不多，索引没有减1的话会导致有些元素没被删掉，但是迭代器知道程序员有可能出现这个错误，所以报了一个善意的提醒。</li>
<li>解决方法：不能用集合对象自己去删除数据。使<strong>用迭代器的remove方法</strong>。（现在一共学了3种方法：1. 每次减1，2. 倒着遍历，3. 用迭代器去删。）</li>
</ul>
</li>
<li>由于<strong>增强for循环</strong>遍历集合就是迭代器遍历集合的简化写法，因此，使用增强for循环遍历集合，又在同时删除集合中的数据时，程序也会出现并发修改异常的错误。<ul>
<li>原因：增强for循环相当于迭代器简化写法，但是又拿不到迭代器。类似地，使用lambda表达式也会出现这个问题，因为其内部使用的是增强for循环。</li>
</ul>
</li>
</ul>
<h2 id="怎么保证遍历集合同时删除数据时不出bug？"><a href="#怎么保证遍历集合同时删除数据时不出bug？" class="headerlink" title="怎么保证遍历集合同时删除数据时不出bug？"></a>怎么保证遍历集合同时删除数据时不出bug？</h2><ul>
<li>使用迭代器遍历集合，但用<strong>迭代器自己的删除方法</strong>删除数据即可。</li>
<li>如果能用for循环遍历时：可以倒着遍历并删除；或者从前往后遍历，但删除元素后做i–操作。</li>
</ul>
<h1 id="Collection集合其他知识"><a href="#Collection集合其他知识" class="headerlink" title="Collection集合其他知识"></a>Collection集合其他知识</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：<strong>数据类型…参数名称</strong>。</p>
<p>可变参数的特点和好处</p>
<ul>
<li>特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。</li>
<li>好处：常常用来灵活的接收数据。</li>
</ul>
<p>可变参数的注意事项</p>
<ul>
<li>可变参数<strong>在方法内部就是一个数组</strong>。</li>
<li><strong>一个形参列表中可变参数只能有一个</strong>。</li>
<li>可变参数<strong>必须放在形参列表的最后面</strong>。</li>
</ul>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>一个用来操作集合的工具类。</p>
<p>提供的静态方法</p>
<ol>
<li>public static <T> boolean addAll(Collection&lt;? super T&gt; c, T… elements)。给集合批量添加元素。</li>
<li>public static void shuffle(List&lt;?&gt; list) 。打乱List集合中的元素顺序。</li>
<li>public static <T> void sort(List<T> list)。对List集合中的元素进行升序排序。</li>
<li>public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; c)。对List集合中元素，按照比较器对象指定的规则进行排序。</li>
</ol>
<p>后两个是排序方法，3可以直接对自定义类型的List集合排序，但自定义类型必须实现了Comlarable接口，指定了比较规则才可以。</p>
<h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><p>斗地主。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xinranzero.com/2024/04/05/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.util%E3%80%91%E9%9B%86%E5%90%88%EF%BC%88Collection%E3%80%81List%E3%80%81Set%EF%BC%89/" data-id="cluo501th00021cuh85jl1uv2" data-title="【Java基础】集合（Collection、List、Set）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/10/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang.reflect%E3%80%91Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/">【Java基础】【java.lang.reflect】Junit单元测试、反射</a>
          </li>
        
          <li>
            <a href="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.lang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/">【Java基础】【java.lang】多线程</a>
          </li>
        
          <li>
            <a href="/2024/04/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E3%80%90java.net%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">【Java基础】【java.net】网络编程</a>
          </li>
        
          <li>
            <a href="/2024/04/08/%E3%80%90LeeCode%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">【LeeCode】刷题记录.md</a>
          </li>
        
          <li>
            <a href="/2024/04/08/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%89%B9%E6%AE%8A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF/">【Java基础】特殊文本文件、日志技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Rong Zhao<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>